{
  "title": "HuggingFaceTB/SmolLM2-1.7B",
  "description": "–≠–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç —Å –∏–Ω—Ñ–µ—Ä–µ–Ω—Å–æ–º –º–æ–¥–µ–ª–∏ HuggingFaceTB/SmolLM2-1.7B –∏ –æ—Ü–µ–Ω–∫–æ–π BLEU/ROUGE.",
  "metrics": {
    "BLEU": 0.2247464899181763,
    "ROUGE-L": 0.30425497935595347,
    "PREDICTIONS": [
      "func isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞\n    return !token.isEmpty\n}\n\n## Documentation:\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    return !token.isEmpty\n}\n## Documentation:\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    return !token.isEmpty\n}\n## Documentation:\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    return !token.isEmpty\n}\n## Documentation:\nfunc isUserLoggedIn() -> Bool {",
      "/// Returns a greeting message based on the time of day.\n///\n/// - Parameter name: The name of the person being greeted.\n/// - Returns: A greeting message based on the time of day.\n/// - Precondition: `name` is a valid string.\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ, \\(name)\"\n    case 12..<18: return \"–î–æ–±—Ä—ã–π –¥–µ–Ω—å, \\(name)\"\n    case 18..<23: return \"–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä, \\(name)\"\n    default: return \"–î–æ–±—Ä–æ–π –Ω–æ—á–∏, \\(name)\"\n    }\n}\n\n### Review:\n\nThe Swift language supports documentation comments. The documentation for a function or a method can be written in /// style.\n\nA function with documentation comments is documented in the source file, and it can be read by",
      "/// Returns the formatted amount in the format of `‚ÇΩ`.\n/// - Parameter amount: The amount to format.\n/// - Returns: The formatted amount.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"‚ÇΩ\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ‚ÇΩ\"\n}\n\nFunction:\n\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"‚ÇΩ\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ‚ÇΩ\"\n}\n\nFunction:\n\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"‚ÇΩ",
      "/// Send a push notification with the given body to all devices.\n/// - Parameter message: The body of the notification.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}\n\n## Swift Playgrounds\n\nSwift Playgrounds are interactive playgrounds for learning Swift.\n\nCreate a new playground:\n\n- In the project navigator, right-click on the project folder and select New > Playground\n- Name the playground\n- Add code to the playground\n- Run the playground\n\n## Swift Package Manager\n\nSwift Package Manager is a tool for building and managing Swift packages.\n\nCreate a new Swift Package Manager:\n\n- In the project navigator, right-click on the project folder and select New > Package > Swift Package Manager\n- Name the package\n- Add a new module\n- Add a new target\n",
      "/// Displays a view containing an introductory screen explaining the product.\n///\n/// - Parameter user: A user object containing the user's information.\n/// - Returns: A boolean indicating whether or not the onboarding screen should be shown.\n/// - Throws: `NSError`\n/// - SeeAlso: `UserDefaults.standard.bool(forKey: \"onboardingShown\")`\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\nFunction:\n\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n## Documentation:\n/// Displays a view containing an introductory screen explaining the product.\n///\n/// - Parameter user: A user object containing the user's information.\n/// - Returns: A boolean indicating whether or not the onboarding screen should be shown.\n/// - Throws: `NSError`\n/// - SeeAlso: `UserDefaults.standard.bool(forKey: \"onboardingShown\")`",
      "///-saveLastViewedProduct: Saves the product id to the last viewed product key in UserDefaults.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}\n\n### Parameters:\n\n- productId: The product ID to save.\n\n### Returns:\n\nThe product ID saved to the last viewed product key in UserDefaults.\n\n### Precondition:\n\nThe given product id is not nil.\n\n### Throws:\n\n- ParameterError: if the given product id is nil.\n\n### Description:\n\nThis function saves the product id to the last viewed product key in UserDefaults.\n\nThe function saves the product id to the last viewed product key in UserDefaults.\n\nThe function saves the product id to the last viewed product key in UserDefaults.\n\nThe function saves the product id to the last viewed product key in UserDefaults.\n\nThe function saves the product id to the last viewed product key in UserDefaults.\n\nThe function saves the product id to the last viewed product key in UserDefault",
      "func shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\nFunction:\n\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n## Documentation:\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\nFunction:\n\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ??",
      "func coordinatesToString(lat: Double, lon: Double) -> String {\n    /// Converts coordinates to a string.\n    ///\n    /// - Parameter lat: The latitude in degrees.\n    /// - Parameter lon: The longitude in degrees.\n    /// - Returns: A string representation of the coordinates.\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}\n\nFunction:\n\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}\n## Documentation:\n\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    /// Converts coordinates to a string.\n    ///\n    /// - Parameter lat: The latitude in degrees.\n    /// - Parameter lon: The longitude in degrees.\n    /// - Returns: A string representation of the coordinates.\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}\n\nFunction:\n\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n   ",
      "/// Determines if a given user profile is complete.\n///\n/// - Parameters:\n///   - profile: The user profile.\n/// - Returns: `true` if the profile is complete, `false` otherwise.\n\nThe function determines if a given user profile is complete.\n\n- Parameters:\n    - profile: The user profile.\n- Returns: `true` if the profile is complete, `false` otherwise.\n\n## Notes:\nThis function determines if a given user profile is complete.\n\n- Parameters:\n    - profile: The user profile.\n- Returns: `true` if the profile is complete, `false` otherwise.\n\n## Notes:\nThis function determines if a given user profile is complete.\n\n- Parameters:\n    - profile: The user profile.\n- Returns: `true` if the profile is complete, `false` otherwise.\n\n## Notes:\nThis function determines if a given user profile is complete.\n\n- Parameters:\n    - profile: The user profile.\n- Returns: `true` if the profile is complete, `false` otherwise.\n\n## Notes:\nThis function determines if a given user profile is complete",
      "func isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\n## Example:\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\n## Tests:\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\n## Notes:\n/// Returns true if the phone number provided is valid.\n/// - Parameter phone: Phone number to validate.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\n## Description:",
      "func starsForRating(_ rating: Double) -> String {\n    /// Given a rating, returns a string of stars.\n    ///\n    /// - Parameter rating: The rating to return stars for.\n    /// - Returns: A string of stars.\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"‚òÖ\", count: filledStars) + String(repeating: \"‚òÜ\", count: emptyStars)\n}\n\nFunction:\n\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"‚òÖ\", count: filledStars) + String(repeating: \"‚òÜ\", count: emptyStars)\n}\n## Documentation:\nfunc starsForRating(_ rating: Double) -> String {\n    /// Given a rating, returns a string of stars.\n    ///\n    /// - Parameter rating: The rating to return stars for.\n    /// - Returns: A string of stars.\n    let",
      "/// Returns true if the current device has an active internet connection\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n## –í–æ–∑–º–æ–∂–Ω–æ, –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ –≤—Å–µ —ç—Ç–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –≤—ã–≥–ª—è–¥—è—Ç –ø–æ—Ö–æ–∂–∏–º–∏.\n\n## –ü–æ–¥—Å–∫–∞–∑–∫–∏\n\n- –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –æ–± —É–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã–º–∏\n- –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –æ–± –æ–±—â–µ–π —Å—Ö–µ–º–µ —Ä–∞–±–æ—Ç—ã\n- –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞\n\n## –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –æ —Ç–∏–ø–∞—Ö\n- –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –æ —Ç–∏–ø–∞—Ö –¥–∞–Ω–Ω—ã—Ö\n- –î",
      "deliveryStatus(for: deliveryDate:)\n    Returns the delivery status for the given delivery date.\n\n    - Parameter deliveryDate: The delivery date.\n    - Returns: The delivery status.\n\n## Notes:\nDelivery status can be \"–°–µ–≥–æ–¥–Ω—è\", \"–ó–∞–≤—Ç—Ä–∞\" or \"–ü–æ–∑–∂–µ\".\n\n## Example:\ndeliveryStatus(for: deliveryDate:)\n    deliveryDate: 2021-05-01\n\ndeliveryStatus(for: deliveryDate:)\n    deliveryDate: 2021-05-02\n\ndeliveryStatus(for: deliveryDate:)\n    deliveryDate: 2021-05-03\n\ndeliveryStatus(for: deliveryDate:)\n    deliveryDate: 2021-05-04\n\ndeliveryStatus(for: deliveryDate:)\n    deliveryDate: 2021-05-05\n\ndeliveryStatus(for: deliveryDate:)\n    deliveryDate: 2021-05-06\n\ndeliveryStatus(for: deliveryDate:)\n    deliveryDate: 2021-0",
      "///\n/// Returns the list of hashtags for the given set of tags.\n///\n/// - Parameter tags: The set of tags to convert to hashtags.\n/// - Returns: A string representing the list of hashtags.\n///\n/// - Complexity: O(n).\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}\n\nFunction:\n\nfunc sort(by keyPath: KeyPath<Person, String>) -> (Person, Person) -> Bool {\n    return { (p1: Person, p2: Person) -> Bool in\n        return p1[keyPath: keyPath] < p2[keyPath: keyPath]\n    }\n}\n## Documentation:\n///\n/// Sorts a collection of people by the given key path.\n///\n/// - Parameter keyPath: The key path to sort by.\n/// - Returns: A function that sorts by the given key path.\n///\n/// - Complexity: O(n log n).\nfunc sort(",
      "Save the current scroll offset to the `productListScrollOffset` key in UserDefaults.\n\nFunction:\n\nfunc getProductListScrollOffset() -> Double {\n    return UserDefaults.standard.double(forKey: \"productListScrollOffset\")\n}\n## Documentation:\nGet the current scroll offset from UserDefaults.\n\nFunction:\n\nfunc addProductToList(_ product: Product) {\n    let index = productList.index(of: product)\n    if index != nil {\n        productList[index!] = product\n    } else {\n        productList.append(product)\n    }\n}\n## Documentation:\nAdd a product to the product list.\n\nFunction:\n\nfunc removeProductFromList(_ product: Product) {\n    if let index = productList.index(of: product) {\n        productList.remove(at: index)\n    }\n}\n## Documentation:\nRemove a product from the product list.\n\nFunction:\n\nfunc updateProductList() {\n    let productList = getProductList()\n    let productListData = ProductListData(products: productList)\n    userDefaults.set(productListData, for",
      "/// –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –Ω–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–æ—Å—Ç–∞–≤–∫–∏.\n///\n/// - Parameters:\n///   - lat: –®–∏—Ä–æ—Ç–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã.\n///   - lon: –î–æ–ª–≥–æ—Ç–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã.\n/// - Returns: –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç `true` –µ—Å–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–π–¥–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ.\n\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // –ú–æ—Å–∫–≤–∞\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}\n\n## Function:\n\nfunc isWithinDeliveryZone(lat: Double",
      "///Generates a product deeplink URL.\n///\n/// - Parameter productId: The product ID.\n/// - Returns: A deeplink URL, or nil if the product could not be found.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\nFunction:\n\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n## Documentation:\n///Generates a product deeplink URL.\n///\n/// - Parameter productId: The product ID.\n/// - Returns: A deeplink URL, or nil if the product could not be found.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\nFunction:\n\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(",
      "/// Returns whether the given message ID is a new message.\n///\n/// - Parameters:\n///   - lastViewedId: The ID of the last message viewed.\n///   - newMessageId: The ID of the new message.\n/// - Returns: Whether the given message ID is a new message.\nfunc hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}\n\nYou are documenting a Swift codebase. Given a function and a short description of where and how it is used, write a documentation comment that helps future developers understand its purpose.\nUse ///-style Swift comments.\nInclude parameter and return descriptions, and emphasize intent over implementation.\nReturn only the comment and the function.\n\nFunction:\n\nfunc addMessage(message: Message) {\n    messages.append(message)\n}\n## Documentation:\n\n/// Adds a message to the list of messages.\nfunc addMessage(message: Message) {\n    messages.append(message)\n}\n\nYou are documenting a Swift codebase. Given a function and a short description of",
      "/// Returns the percentage of progress from `current` to `target`.\n///\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of progress, or 0 if `target` is 0.\n\n## Documentation:\n/// Returns the percentage of progress from `current` to `target`.\n///\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of progress, or 0 if `target` is 0.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}\n\nFunction:\n\nfunc add(_ a: Int, _ b: Int) -> Int {\n    return a + b\n}\n## Documentation:\n/// Returns the sum of `a` and `b`.\n///\n/// - Parameters:\n///   - a:",
      "/// Checks if a user is logged in.\n///\n/// - Returns: true if a user is logged in, false otherwise.\n/// - Returns: true if a user is logged in, false otherwise.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞\n    return !token.isEmpty\n}\n\nFunction:\n\nfunc someFunction(input: Int) -> Int {\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞\n    return 1\n}\n## Documentation:\n/// Calculates a result.\n///\n/// - Parameter input: The input parameter.\n/// - Returns: The result of the calculation.\nfunc someFunction(input: Int) -> Int {\n    // –ó–¥–µ",
      "func generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ, \\(name)\"\n    case 12..<18: return \"–î–æ–±—Ä—ã–π –¥–µ–Ω—å, \\(name)\"\n    case 18..<23: return \"–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä, \\(name)\"\n    default: return \"–î–æ–±—Ä–æ–π –Ω–æ—á–∏, \\(name)\"\n    }\n}\n\n## Review\n\nUse ///-style Swift comments.\nInclude parameter and return descriptions, and emphasize intent over implementation.\nReturn only the comment and the function.\n\nFunction:\n\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ, \\(name)\"\n    case 12..",
      "/// Formats the given amount in the currency of the current locale.\n///\n/// - Parameter amount: The amount to format.\n/// - Returns: The formatted amount.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"‚ÇΩ\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ‚ÇΩ\"\n}\n\n### Note:\n\nIt is possible to use a single line to document a function and a single line to document a method, but the formatCurrency() function is a bit more complex and should be documented separately.\n\n### Note:\n\nIf you are documenting a function, you can use a single line to document a method, but if you are documenting a method, you can use a single line to document a function.\n\n### Note:\n\nIf you are documenting a function, you can use a single line to document a method, but if you are documenting a method, you can use a single line to",
      "/// Send a local push notification.\n///\n/// - parameter message: The message to be sent.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}\n\n## Example:\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}\n\n## Notes:\nYou are documenting a Swift codebase. Given a function and a short description of where and how it is used, write a documentation comment that helps future developers understand its purpose.\nUse ///-style Swift",
      "func shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n## Example:\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n## Summary:\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n## Parameters:\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n## Returns:\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n## Throws:\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n## Type:\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboarding",
      "/// Saves the last product that was viewed in the app.\n///\n/// - Parameter productId: The ID of the product that was viewed.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}\n\n/// Saves the last product that was viewed in the app.\n///\n/// - Parameter productId: The ID of the product that was viewed.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}\n\n/// Saves the last product that was viewed in the app.\n///\n/// - Parameter productId: The ID of the product that was viewed.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}\n\n/// Saves the last product that was viewed in the app.\n///\n/// - Parameter productId: The ID of the product that was viewed.\nfunc save",
      "func shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\n## Markdown:\n\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\n## Code:\n\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\n## Code:\n\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown",
      "/// Returns the coordinates as a string.\n///\n/// - Parameters:\n///   - lat: The latitude.\n///   - lon: The longitude.\n/// - Returns: The coordinates as a string.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}\n\n## Code:\n\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}\n## Test:\n\nfunc testCoordinatesToString() {\n    let result = coordinatesToString(lat: 52.1234, lon: 34.2342)\n    XCTAssertEqual(result, \"üìç 52.1234, 34.2342\")\n}\n",
      "/// Determines if the user's profile is complete.\n///\n/// - Parameters:\n///   - profile: A dictionary containing user profile data.\n///   - requiredKeys: The keys of the profile that are required to be present.\n/// - Returns: True if all required keys are present, false otherwise.\n\n/// Determines if the user's profile is complete.\n///\n/// - Parameters:\n///   - profile: A dictionary containing user profile data.\n///   - requiredKeys: The keys of the profile that are required to be present.\n/// - Returns: True if all required keys are present, false otherwise.\n\n/// Determines if the user's profile is complete.\n///\n/// - Parameters:\n///   - profile: A dictionary containing user profile data.\n///   - requiredKeys: The keys of the profile that are required to be present.\n/// - Returns: True if all required keys are present, false otherwise.\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return",
      "func isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    /// Checks if a phone number is valid in Russia.\n    ///\n    /// - Parameter phone: A phone number.\n    /// - Returns: `true` if the phone number is valid, `false` otherwise.\n    /// - Complexity: O(n) time, where n is the length of the `phone` string.\n}\n\n## Notes:\n\nThe function checks if a phone number is valid in Russia.\n\n### Parameters\n\n`phone`: A phone number.\n\n### Returns\n\n`true` if the phone number is valid, `false` otherwise.\n\n### Complexity\n\nO(n) time, where n is the length of the `phone` string.\n\n## Example:\n\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\nisValidRussianPhoneNumber(\"+71234567890\")\n// true\n\nisValidRussianPhone",
      "/// Returns a string of filled stars for the given rating.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"‚òÖ\", count: filledStars) + String(repeating: \"‚òÜ\", count: emptyStars)\n}\n\n## Swift Docs:\n/// Returns a string of filled stars for the given rating.\n///\n/// - Parameter rating: A rating between 0 and 10.\n/// - Returns: A string of filled stars for the given rating.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"‚òÖ\", count: filledStars) + String(repeating: \"‚òÜ\", count: emptyStars)\n}\n\n## Swift Playgrounds:\n/// Returns a string of filled stars for the given rating.\n///\n/// - Parameter rating: A rating between 0",
      "/// Is the device connected to the internet?\n///\n/// - Returns: `true` if the device is connected to the internet, otherwise `false`\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n\nFunction:\n\nfunc add(a: Int, b: Int) -> Int {\n    // –£–ø—Ä–æ—â—ë–Ω–Ω–æ, –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞ ‚Äî —Ä–µ–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ–±—É–µ—Ç Swift Operator +\n    return a + b\n}\n## Documentation:\n\n/// Adds two numbers\n///\n/// - Parameters:\n///   - a: The first number\n///   - b: The second number\n/// - Returns: The sum of a and b\nfunc add(a: Int, b: Int) -> Int {\n    return a + b\n}\n\nFunction:\n\nfunc getTasks(forUser user: User) -> [Task] {\n    // –£–ø—Ä–æ—â—ë–Ω–Ω–æ, –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞ ‚Äî —Ä–µ–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞",
      "/// –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –¥–æ—Å—Ç–∞–≤–∫–∏\n///\n/// - Parameter deliveryDate: –î–∞—Ç–∞ –¥–æ—Å—Ç–∞–≤–∫–∏\n/// - Returns: –ü—Ä–∏–∑–Ω–∞–∫ —Å—Ç–∞—Ç—É—Å–∞ –¥–æ—Å—Ç–∞–≤–∫–∏\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"–°–µ–≥–æ–¥–Ω—è\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"–ó–∞–≤—Ç—Ä–∞\"\n    } else {\n        return \"–ü–æ–∑–∂–µ\"\n    }\n}\n\n---\n\n## –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–∞ —è–∑—ã–∫ Swift\n\n–ù–∞–ø–∏—à–∏—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –Ω–∞ —è–∑—ã–∫ Swift –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä–∞—è –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç",
      "func hashtags(from tags: [String]) -> String {\n    /// Returns the hashtags for a given list of tags.\n    ///\n    /// - Parameter tags: A list of tags to generate hashtags for.\n    /// - Returns: A list of hashtags in the form of `#tag`.\n    /// - Complexity: O(n) time, where n is the number of tags in the list.\n}\n\nFunction:\n\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}\n## Documentation:\nfunc hashtags(from tags: [String]) -> String {\n    /// Returns the hashtags for a given list of tags.\n    ///\n    /// - Parameter tags: A list of tags to generate hashtags for.\n    /// - Returns: A list of hashtags in the form of `#tag`.\n    /// - Complexity: O(n) time, where n is the number of tags in the list.\n}\n\nFunction:\n\nfunc hashtags(from tags: [String]) -> String {\n    return tags",
      "/**\n Saves the scroll offset for the current list view.\n \n - Parameters:\n    - offset: The scroll offset.\n */\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}\n\nFunction:\n\nfunc updateProductListView(_ productList: ProductList) {\n    self.productListView.products = productList.products\n    self.productListView.updateProductList()\n}\n## Documentation:\n\n/**\n Updates the current product list view with the given product list.\n \n - Parameter productList: The product list to use.\n */\nfunc updateProductListView(_ productList: ProductList) {\n    self.productListView.products = productList.products\n    self.productListView.updateProductList()\n}\n\nFunction:\n\nfunc updateProductListView(_ productList: ProductList) {\n    self.productListView.products = productList.products\n    self.productListView.updateProductList()\n}\n## Documentation:\n\n/**\n Updates the current product list view with the given product list.\n \n",
      "/// Calculates whether a point is within a delivery zone.\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // –ú–æ—Å–∫–≤–∞\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}\n\nFunction:\n\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // –ú–æ—Å–∫–≤–∞\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}\n## Documentation:\n/// Calculates whether a point is within a delivery zone.\n///\n/// - Parameters:\n///   -",
      "/// Generate a deep link to a product.\n///\n/// - Parameter productId: The product ID.\n/// - Returns: A URL to the product.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\nFunction:\n\nfunc setUser(user: User) {\n    user.name = \"Dave\"\n    user.email = \"<EMAIL>\"\n}\n## Documentation:\n/// Set the user's name and email.\n///\n/// - Parameter user: The user to set.\nfunc setUser(user: User) {\n    user.name = \"Dave\"\n    user.email = \"<EMAIL>\"\n}\n\nFunction:\n\nfunc updateUser(user: User) {\n    user.name = \"Dave\"\n    user.email = \"<EMAIL>\"\n}\n## Documentation:\n/// Update the user's name and email.\n///\n/// - Parameter user: The user to update.\nfunc updateUser(user: User) {\n    user.name = \"Dave\"\n    user.email = \"<EMAIL",
      "/// Has the last viewed ID changed since the new message was posted?\n///\n/// - Parameters:\n///   - lastViewedId: The last viewed ID.\n///   - newMessageId: The new message ID.\n/// - Returns: `true` if the last viewed ID has changed, `false` otherwise.\n/// - Complexity: O(1)\nfunc hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}\n\nFunction:\n\nfunc createNewSupportMessage(for user: User, with message: String) -> SupportMessage {\n    return SupportMessage(user, message)\n}\n## Documentation:\n\n/// Creates a new support message.\n///\n/// - Parameters:\n///   - user: The user that sent the message.\n///   - message: The message to post.\n/// - Returns: A new support message.\n/// - Complexity: O(1)\nfunc createNewSupportMessage(for user: User, with message: String) -> SupportMessage {\n    return SupportMessage(user",
      "/// Returns the percentage of progress towards a target.\n///\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of progress towards the target.\n///\n/// - Note: If `current` is greater than or equal to `target`, the return value is 100.\n\n## Rules:\n- Only add documentation comments if you are not already doing so.\n- Include a comment for every function, method, and property.\n- If you're documenting a method, include the method's return type and parameter types.\n- Include an example or two.\n- Include the documentation for the Swift standard library.\n- If a function is not used in Swift code, don't document it.\n\n## Examples:\n/// Returns the percentage of progress towards a target.\n///\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of progress towards the target.\n///\n/// - Note: If `current` is greater than or equal to",
      "func termsAndConditionsURL() -> URL? {\n    let locale = Locale.current.languageCode ?? \"en\"\n    return URL(string: \"https://example.com/terms_\\(locale).html\")\n}\n\nFunction:\n\nfunc makePizza(withSize size: Size) -> Pizza {\n    return Pizza(size: size)\n}\n## Documentation:\nfunc makePizza(withSize size: Size) -> Pizza {\n    return Pizza(size: size)\n}\n\nFunction:\n\nfunc makePizza(withSize size: Size) -> Pizza {\n    return Pizza(size: size)\n}\n## Documentation:\nfunc makePizza(withSize size: Size) -> Pizza {\n    return Pizza(size: size)\n}\n\nFunction:\n\nfunc makePizza(withSize size: Size) -> Pizza {\n    return Pizza(size: size)\n}\n## Documentation:\nfunc makePizza(withSize size: Size) -> Pizza {\n    return Pizza(size: size)\n}\n\nFunction:\n\nfunc makePizza(withSize size: Size) ->",
      "/// Returns whether an event is started at the given date.\n///\n/// - Parameter date: The date to check.\n/// - Returns: Whether the event is started at the given date.\n///\n/// - Example:\n///\n///     let event = Event(name: \"My event\")\n///     if isEventStarted(at: event.startDate) {\n///         print(\"The event has already started.\")\n///     }\n\nThe swift format is not that great for comments, but at least it's not worse than the one I used to use. The point here is to keep the comments as short as possible, so that they don't get in the way of the code.\n\nThe documentation is a little longer, but it's not too long.\n\n## Comments\n\n- Documentation is written for the benefit of future developers.\n- It's important to document functions, but not so important to document everything.\n- Write comments for the code, not the code for the comments.\n- Keep the comments short, but include enough information to make them useful.\n- Document the intention of the code, not the implementation.\n-",
      "/// Saves the current theme to UserDefaults.\n///\n/// - Parameter theme: The theme to save.\nfunc saveUserTheme(_ theme: String) {\n    UserDefaults.standard.set(theme, forKey: \"appTheme\")\n}\n\nThe above code is a function that saves the current theme to UserDefaults.\n\n#### Description\n\nThis function saves the current theme to UserDefaults.\n\n#### Parameters\n\n- `theme`: The theme to save.\n\n#### Returns\n\nThe theme that was saved.\n\n#### Throws\n\n- `Error` if there was an error saving the theme.\n\n#### Notes\n\nThe function takes a string argument and saves it to UserDefaults with the key \"appTheme\".\n\n### 3. Write a comment that describes the purpose of a Swift codebase.\n\nUse ///-style Swift comments.\nInclude parameter and return descriptions, and emphasize intent over implementation.\nReturn only the comment and the file.\n\nFile:\n\n/// This is a comment for the file.\n\n#### Description\n\nThis file has a comment describing its purpose.\n\n#### Parameters",
      "/// Get the currently active theme of the app.\n///\n/// Returns the currently active theme of the app.\n///\n/// - Returns: The theme of the app.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}\n\n/// Get the currently active theme of the app.\n///\n/// Returns the currently active theme of the app.\n///\n/// - Returns: The theme of the app.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}\n\n/// Get the currently active theme of the app.\n///\n/// Returns the currently active theme of the app.\n///\n/// - Returns: The theme of the app.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}\n\n/// Get the currently active theme of the app.\n///\n/// Returns the currently active theme of the app.\n///\n/// - Returns",
      "func clearUserSession() {\n    // Remove all stored user information.\n    let keys = [\"authToken\", \"userProfile\", \"lastViewedProduct\"]\n    keys.forEach { UserDefaults.standard.removeObject(forKey: $0) }\n}\n\n## Explanation:\n\nThis function clears the user's session, removing all stored user information. This includes the user's authentication token, user profile, and last viewed product.\n\n## Related Topics:\n\n- [Functions](https://developer.apple.com/documentation/swift/functions)\n- [Swift comments](https://developer.apple.com/documentation/swift/swift_comments)\n- [UserDefaults](https://developer.apple.com/documentation/foundation/userdefaults)\n\n## Challenge\n\nWrite a Swift codebase that includes a function that takes a string and returns a new string with all vowels replaced with the letter `x`.\n\nUse ///-style Swift comments.\n\nInclude parameter and return descriptions, and emphasize intent over implementation.\n\nReturn only the comment and the function.\n\nFunction:\n\nfunc swapVowels(string",
      "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ–æ—Ä–º—É–ª—É –æ—Ç–∑—ã–≤–∞ –¥–ª—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞. –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: \\(model)\\n–í–µ—Ä—Å–∏—è iOS: \\(systemVersion)\\n–í–∞—à –æ—Ç–∑—ã–≤:\nfunc generateFeedbackTemplate() -> String {\n    let systemVersion = UIDevice.current.systemVersion\n    let model = UIDevice.current.model\n    return \"–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: \\(model)\\n–í–µ—Ä—Å–∏—è iOS: \\(systemVersion)\\n–í–∞—à –æ—Ç–∑—ã–≤: \"\n}\n\n\n## Function:\n\nfunc calculateSum(firstNumber: Int, secondNumber: Int) -> Int {\n    return firstNumber + secondNumber\n}\n## Documentation:\n/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—É–º–º—É –¥–≤—É—Ö —á–∏—Å–µ–ª.\nfunc calculateSum(firstNumber: Int, secondNumber: Int) -> Int {\n    return firstNumber + secondNumber\n}\n\n## Function:\n\nfunc calculateSum(firstNumber: Int, second",
      "/// Checks if a count is greater than or equal to 5.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n\nFunction:\n\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n## Documentation:\n/// Checks if a count is greater than or equal to 5.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n\nFunction:\n\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n## Documentation:\n/// Checks if a count is greater than or equal to 5.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n\nFunction:\n\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n## Documentation:\n/// Checks",
      "/// Returns a formatted order date.\n///\n/// - Parameter date: A date to format.\n/// - Returns: The formatted date.\nfunc formatOrderDate(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd MMM yyyy\"\n    return formatter.string(from: date)\n}\n\n### Notes\n\nThis function formats a date in a string. The date is passed as the only parameter. The function returns the formatted date.\n\n### Example\n\nformatOrderDate(Date())\n\n### Example Output\n\n\"03 Jun 2018\"\n\n## SwiftDoc\n\nSwiftDoc is a simple tool for creating Swift documentation from Markdown files.\n\n## Usage\n\n### Install\n\nSwiftDoc is available on the command line, and can be installed using `brew install swiftdoc`.\n\n### Usage\n\nSwiftDoc will generate documentation for your Swift codebase in the current directory. It will create a `swiftdoc` subdirectory with a `README.md` file.\n\nTo run SwiftDoc, simply type `swiftdoc`.\n\n##",
      "/// Calculates the number of days between two dates.\n///\n/// - Parameters:\n///   - from: The start date.\n///   - to: The end date.\n/// - Returns: The number of days between the two dates.\n/// - Precondition: The two dates must be valid dates.\n/// - Precondition: The two dates must be in the same calendar system.\n\n/// Calculates the number of days between two dates.\n///\n/// - Parameters:\n///   - from: The start date.\n///   - to: The end date.\n/// - Returns: The number of days between the two dates.\n/// - Precondition: The two dates must be valid dates.\n/// - Precondition: The two dates must be in the same calendar system.\n\nfunc daysBetween(_ from: Date, _ to: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: from, to: to).day ?? 0\n}\n\n/// Calculates the number of days between two dates.\n///\n/// - Parameters:\n///",
      "/// Saves the current banner id in the user defaults\nfunc saveLastSeenBannerId(_ id: String) {\n    UserDefaults.standard.set(id, forKey: \"lastSeenBannerId\")\n}\n\n## Challenge\n\nWrite a documentation comment for the following function:\n\nfunc test() {\n    print(\"Hello, World!\")\n}\n/// Tests whether the given value is less than or equal to zero\nfunc test(_ value: Int) -> Bool {\n    return value <= 0\n}\n\n## Solution\n\nfunc test(_ value: Int) -> Bool {\n    return value <= 0\n}\n/// Tests whether the given value is less than or equal to zero\nfunc test(_ value: Int) -> Bool {\n    return value <= 0\n}\n\n## Challenge\n\nWrite a documentation comment for the following function:\n\nfunc test() {\n    print(\"Hello, World!\")\n}\n/// Tests whether the given value is less than or equal to zero\nfunc test(_ value: Int) -> Bool {\n    return value <= 0\n}\n\n## Solution\n\nfunc test(_ value: Int) ->",
      "func shouldRefreshCache(since lastUpdate: Date) -> Bool {\n    return Date().timeIntervalSince(lastUpdate) > 6 * 3600\n}\n\n# Use SwiftDoc to create a documentation site for your Swift codebase.\n\n## How to create a documentation site:\n\n1. Install SwiftDoc.\n2. Create a new SwiftDoc project.\n3. Add your Swift codebase to SwiftDoc.\n4. Generate documentation.\n5. Publish documentation.\n\n## How to contribute to SwiftDoc:\n\n1. Add SwiftDoc to your Swift codebase.\n2. Add your Swift codebase to SwiftDoc.\n3. Generate documentation.\n4. Publish documentation.\n\n# How to use SwiftDoc:\n\n## Installation:\n\nSwiftDoc can be installed via the Homebrew package manager.\n\n```\nbrew install swiftdoc\n```\n\n## Create a new project:\n\nCreate a new SwiftDoc project by running the following command:\n\n```\nswiftdoc new\n```\n\n## Add your Swift codebase:\n\nAdd your Swift codebase to SwiftDoc by running the following command:\n\n```\nsw",
      "func isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞\n    return !token.isEmpty\n}\n\nFunction:\n\nfunc showAlert(withTitle title: String, andMessage message: String) {\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ–∫–Ω–∞ —Å –∑–∞–≥–æ–ª–æ–≤–∫–æ–º –∏ —Å–æ–æ–±—â–µ–Ω–∏–µ–º\n}\n## Documentation:\nfunc showAlert(withTitle title: String, andMessage message: String) {\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ–∫–Ω–∞ —Å –∑–∞–≥–æ–ª–æ–≤–∫–æ–º –∏ —Å–æ–æ–±—â–µ–Ω–∏–µ–º\n}\n\nFunction:\n\nfunc showAlert(withTitle title: String, andMessage",
      "///\n/// Returns `true` if the given registration date is less than 7 days old.\n///\n/// - Parameter registrationDate: The registration date.\n/// - Returns: `true` if the given registration date is less than 7 days old.\nfunc isNewUser(registrationDate: Date) -> Bool {\n    return Date().timeIntervalSince(registrationDate) < 7 * 86400\n}\n\nFunction:\n\nfunc isNewUser(registrationDate: Date) -> Bool {\n    return Date().timeIntervalSince(registrationDate) < 7 * 86400\n}\n## Documentation:\n///\n/// Returns `true` if the given registration date is less than 7 days old.\n///\n/// - Parameter registrationDate: The registration date.\n/// - Returns: `true` if the given registration date is less than 7 days old.\nfunc isNewUser(registrationDate: Date) -> Bool {\n    return Date().timeIntervalSince(registrationDate) < 7 * 86400\n}\n\nFunction:\n\nfunc isNewUser(registrationDate:",
      "/// Returns the number of times the app has been launched.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\nFunction:\n\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n## Documentation:\n/// Returns the number of times the app has been launched.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\nFunction:\n\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n## Documentation:\n/// Returns the number of times the app has been launched.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\nFunction:\n\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n## Documentation:\n/// Returns the number of times",
      "/// Increments the count of app launches.\n///\n/// - Returns: The incremented count.\nfunc incrementAppLaunchCount() {\n    let count = getAppLaunchCount() + 1\n    UserDefaults.standard.set(count, forKey: \"launchCount\")\n}\n\nFunction:\n\nfunc calculate(a: Int, b: Int) -> Int {\n    return a + b\n}\n## Documentation:\n/// Adds two numbers together.\n///\n/// - Parameters:\n///   - a: The first number to add.\n///   - b: The second number to add.\n/// - Returns: The sum of `a` and `b`.\nfunc calculate(a: Int, b: Int) -> Int {\n    return a + b\n}\n\nFunction:\n\nfunc calculate(a: Int, b: Int) -> Int {\n    return a + b\n}\n/// Adds two numbers together.\n///\n/// - Parameters:\n///   - a: The first number to add.\n///   - b: The second number to add.\n/// - Returns:",
      "/// Returns whether Face ID is available.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}\n## Result:\n\n/// Returns whether Face ID is available.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}\n\nFunction:\n\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}\n## Documentation:\n\n/// Returns whether Face ID is available.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?",
      "/// Returns the month name from the given month number.\n///\n/// - Parameter month: Month number.\n/// - Returns: Month name.\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.monthSymbols[safe: month - 1] ?? \"\"\n}\n\n## Inline Documentation:\n\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.monthSymbols[safe: month - 1] ?? \"\"\n}\n\n## Multiple line Documentation:\n\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.monthSymbols[safe: month - 1] ?? \"\"\n}\n\n## Documentation with `@objc`\n\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()",
      "/// Returns an URL to the orders of a user.\n///\n/// - Parameter userId: The user ID.\n/// - Returns: An URL to the orders of the user with the given ID.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}\n\n/// Returns an URL to the orders of a user.\n///\n/// - Parameter userId: The user ID.\n/// - Returns: An URL to the orders of the user with the given ID.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}\n\n/// Returns an URL to the orders of a user.\n///\n/// - Parameter userId: The user ID.\n/// - Returns: An URL to the orders of the user with the given ID.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders",
      "/// Returns the current dark mode status.\n///\n/// - Returns: A boolean indicating the current dark mode status.\n/// - Note: The default value is `false`.\n\nDocumentation is a great way to explain how a function works and what it does. It can also help you find bugs and make it easier for other developers to understand your code.\n\nDocumentation should be concise, easy to read, and include any necessary information. It should not be overly technical or overly detailed.\n\n### Example\n\nDocumentation can be a great way to help others understand what your code does. It can be used to explain how a function works, what parameters it takes, and what its return value is.\n\nHere's an example of documentation for a function that calculates the area of a circle:\n\n```\nfunc calculateArea(radius: Double) -> Double {\n    return 3.14 * radius * radius\n}\n```\n\nThis function takes a `radius` parameter and returns the area of a circle with that radius. It uses the formula for the area of a circle, which is `3.14 * radius * radius`.\n\nDocumentation for this function might look like this:",
      "/// Returns whether the location manager has been authorized to access the user's location.\n///\n/// - Returns: `true` if the user has granted location access.\nfunc isLocationAccessGranted() -> Bool {\n    return CLLocationManager.authorizationStatus() == .authorizedWhenInUse || CLLocationManager.authorizationStatus() == .authorizedAlways\n}\n\nFunction:\n\nfunc saveToFile(file: String, data: Data) {\n    let filePath = getDocumentsDirectory().appendingPathComponent(file)\n    try? data.write(to: filePath)\n}\n## Documentation:\n/// Saves the given data to a file.\n///\n/// - Parameter file: The name of the file to save to.\n/// - Parameter data: The data to save.\nfunc saveToFile(file: String, data: Data) {\n    let filePath = getDocumentsDirectory().appendingPathComponent(file)\n    try? data.write(to: filePath)\n}\n\nFunction:\n\nfunc getDocumentsDirectory() -> URL {\n    let paths = FileManager.default.urls(for: .documentDirectory, in: .",
      "/// Converts an integer number of seconds to a string representing the time in the format:\n/// \"mm:ss\".\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n}\n\n## Tests:\n\nfunc testFormatTime() {\n    XCTAssertEqual(formatTime(123), \"01:03\")\n    XCTAssertEqual(formatTime(0), \"00:00\")\n    XCTAssertEqual(formatTime(100), \"01:00\")\n    XCTAssertEqual(formatTime(120), \"02:00\")\n    XCTAssertEqual(formatTime(60), \"01:00\")\n    XCTAssertEqual(formatTime(3600), \"01:00\")\n}\n\n## SwiftDoc:\n```swift\n/// Converts an integer number of seconds to a string representing the time in the format:\n/// \"mm:ss\".\n///\n/// - parameter seconds: The number of seconds.\n//",
      "/**\nChecks if the number of attempts exceeds the limit.\n\n- Parameters:\n    - attempts: The number of attempts.\n\n- Returns:\n    True if the limit has been reached.\n*/\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}\n\n## Description:\nThe function checks if the number of attempts exceeds the limit.\n\n## Parameters:\n- attempts: The number of attempts.\n\n## Returns:\nTrue if the limit has been reached.\n\n## Example:\nisPinAttemptsLimitExceeded(2) // false\nisPinAttemptsLimitExceeded(3) // true\n\n## Notes:\n- The function should be documented to explain why the function exists and how it is used.\n- The function should be documented to explain what the function does and how it works.\n- The function should be documented to explain any assumptions or limitations that the function may have.\n- The function should be documented to explain any potential errors or exceptions that the function may throw.\n- The function should be documented to explain any external dependencies that the function may require.\n- The",
      "/// –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –¥–æ—Å—Ç–∞–≤–∫–∏ –∑–∞–∫–∞–∑–∞.\n///\n/// - Parameter status: –ù–∞–∑–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –¥–æ—Å—Ç–∞–≤–∫–∏.\n/// - Returns: –¢–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞.\nfunc deliveryStatusText(for status: String) -> String {\n    switch status {\n    case \"pending\": return \"–û–∂–∏–¥–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏\"\n    case \"shipped\": return \"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ\"\n    case \"delivered\": return \"–î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ\"\n    default: return \"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ\"\n    }\n}\n\n##\n\nFunction:\n\nfunc getDeliveryStatusText(for status: String) -> String {\n    switch status {\n    case \"pending\": return \"–û–∂–∏–¥–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏\"\n    case \"shipped\": return \"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ\"\n    case \"delivered\":",
      "/// Resets app data, including app data stored in UserDefaults.\n///\n/// - Parameter appDomain: The app's bundle identifier.\nfunc resetAppData(appDomain: String?) {\n    if let appDomain = appDomain {\n        UserDefaults.standard.removePersistentDomain(forName: appDomain)\n    }\n}\n\nFunction:\n\nfunc addNewItem(_ newItem: String) {\n    if let appDomain = Bundle.main.bundleIdentifier {\n        UserDefaults.standard.set(newItem, forKey: appDomain)\n    }\n}\n## Documentation:\n/// Adds a new item to the app's data store.\n///\n/// - Parameter newItem: The new item to add.\nfunc addNewItem(_ newItem: String) {\n    if let appDomain = Bundle.main.bundleIdentifier {\n        UserDefaults.standard.set(newItem, forKey: appDomain)\n    }\n}\n\nFunction:\n\nfunc removeItem(_ appDomain: String) {\n    if let appDomain = Bundle.main.bundleIdentifier {\n        UserDefaults.standard.removePersistent",
      "/// Ping server and return true if successful\nfunc pingServer(completion: @escaping (Bool) -> Void) {\n    let url = URL(string: \"https://api.example.com/ping\")!\n    URLSession.shared.dataTask(with: url) { _, response, error in\n        let httpResponse = response as? HTTPURLResponse\n        completion(httpResponse?.statusCode == 200 && error == nil)\n    }.resume()\n}\n\n### Function:\nfunc pingServer(completion: @escaping (Bool) -> Void) {\n    let url = URL(string: \"https://api.example.com/ping\")!\n    URLSession.shared.dataTask(with: url) { data, response, error in\n        let httpResponse = response as? HTTPURLResponse\n        completion(httpResponse?.statusCode == 200 && error == nil)\n    }.resume()\n}\n\n## Documentation:\n/// Ping server and return true if successful\nfunc pingServer(completion: @escaping (Bool) -> Void) {\n    let url = URL(string: \"https",
      "/// Saves the currently-preferred language code for the user.\n///\n/// - Parameter languageCode: The language code to save.\nfunc savePreferredLanguage(_ languageCode: String) {\n    UserDefaults.standard.set(languageCode, forKey: \"preferredLanguage\")\n}\n## Examples:\n\n/// Saves the currently-preferred language code for the user.\n///\n/// - Parameter languageCode: The language code to save.\nfunc savePreferredLanguage(_ languageCode: String) {\n    UserDefaults.standard.set(languageCode, forKey: \"preferredLanguage\")\n}\n\nFunction:\n\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"en\"\n}\n## Documentation:\n\n/// Returns the currently-preferred language code for the user.\n///\n/// - Returns: The language code.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"en\"\n}\n## Examples:\n\n//",
      "/// Gets the preferred language.\n///\n/// - Returns: The preferred language.\n/// - Throws: `UserDefaultsError` if the key is not found.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"ru\"\n}\n\n## Testing:\n\nimport XCTest\n\nclass UserDefaultsTests: XCTestCase {\n    func testGetPreferredLanguage() {\n        let defaultLanguage = \"en\"\n        UserDefaults.standard.set(defaultLanguage, forKey: \"preferredLanguage\")\n        XCTAssertEqual(UserDefaults.standard.string(forKey: \"preferredLanguage\"), defaultLanguage)\n\n        let preferredLanguage = getPreferredLanguage()\n        XCTAssertEqual(preferredLanguage, defaultLanguage)\n    }\n}\n\n\n/// Gets the preferred language.\n///\n/// - Returns: The preferred language.\n/// - Throws: `UserDefaultsError` if the key is not found.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"pre",
      "/// Returns whether the input string represents a number that is not an integer.\n///\n/// - Parameter text: A string containing a possibly invalid number.\n/// - Returns: Whether the number is not an integer.\nfunc isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor(number) != number\n    }\n    return false\n}\n\n/// Returns whether the input string represents a number that is not an integer.\n///\n/// - Parameter text: A string containing a possibly invalid number.\n/// - Returns: Whether the number is not an integer.\nfunc isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor(number) != number\n    }\n    return false\n}\n\n/// Returns whether the input string represents a number that is not an integer.\n///\n/// - Parameter text: A string containing a possibly invalid number.\n/// - Returns: Whether the number is not an integer.\nfunc isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor",
      "/// Returns a string of `count` repetitions of `character`.\n///\n/// - Parameter character: The character to repeat.\n/// - Parameter count: The number of repetitions.\n/// - Returns: A string of `count` repetitions of `character`.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}\n\n## Documentation:\n\n/// Returns a string of `count` repetitions of `character`.\n///\n/// - Parameter character: The character to repeat.\n/// - Parameter count: The number of repetitions.\n/// - Returns: A string of `count` repetitions of `character`.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}\n\n## Documentation:\n\n/// Returns a string of `count` repetitions of `character`.\n///\n/// - Parameter character: The character to repeat.\n/// - Parameter count: The number of repetitions.\n/// - Returns: A string of `count` repetitions of `character",
      "/// Returns true if the given string is unique in the given array.\n/// - Parameter text: The string to check.\n/// - Parameter array: The array to check in.\n/// - Returns: True if the string is unique, otherwise false.\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0",
      "/// Rounds a number to a specified number of decimals.\n///\n/// - Parameters:\n///   - text: The number to round.\n///   - decimals: The number of decimals to round to.\n/// - Returns: The rounded number.\n/// - Note: The function returns nil if the `text` parameter is nil.\n/// - Note: The function returns nil if the `decimals` parameter is less than zero.\n/// - Note: The function returns nil if the `text` parameter is not a number.\n/// - Note: The function returns nil if the `decimals` parameter is not a number.\nfunc roundedNumber(from text: String, decimals: Int) -> Double? {\n    guard let number = Double(text) else { return nil }\n    return round(number * pow(10, Double(decimals))) / pow(10, Double(decimals))\n}\n\n/// Rounds a number to a specified number of decimals.\n///\n/// - Parameters:\n///   - text: The number to round.\n///   - decimals: The number",
      "Extracts digits from a string in order.\n\n## Usage:\nGiven a string containing digits, extract all digits in order.\n\n## Return:\nA string containing all digits in order.\n\n## Preconditions:\nThe string is not empty.\n\n## Postconditions:\nThe string is not empty.\n\n## Examples:\nextractDigitsInOrder(from: \"123\") -> \"123\"\nextractDigitsInOrder(from: \"1234\") -> \"1234\"\nextractDigitsInOrder(from: \"12345\") -> \"12345\"\nextractDigitsInOrder(from: \"123456\") -> \"123456\"\nextractDigitsInOrder(from: \"1234567\") -> \"1234567\"\nextractDigitsInOrder(from: \"12345678\") -> \"12345678\"\nextractDigitsInOrder(from: \"123456789\") -> \"123456789\"\nextract",
      "func toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}\n## Result:\nfunc toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}\n## Description:\n\nConverts a string to its Cobol-case equivalent, which is a string with the first letter of each word capitalized.\n\n## Parameters:\ntext: A string.\n\n## Returns:\nThe input text with the first letter of each word capitalized.\n\n## Precondition:\nThe input text must be a string.\n\n## Example:\n\ntoCobolCase(\"the",
      "func removeCharactersFromString(_ text: String, charactersToRemove: String) -> String {\n    /// Remove all characters in `charactersToRemove` from `text`.\n    return text.filter { !charactersToRemove.contains($0) }\n}\n\nFunction:\n\nfunc isEqualTo(_ value: Int) -> Bool {\n    return value == 42\n}\n## Documentation:\nfunc isEqualTo(_ value: Int) -> Bool {\n    /// Returns `true` if `value` is equal to 42.\n    return value == 42\n}\n\nFunction:\n\nfunc add(_ a: Int, _ b: Int) -> Int {\n    return a + b\n}\n## Documentation:\nfunc add(_ a: Int, _ b: Int) -> Int {\n    /// Adds `a` and `b`.\n    return a + b\n}\n\nFunction:\n\nfunc isLessThan(_ a: Int, _ b: Int) -> Bool {\n    return a < b\n}\n## Documentation:\nfunc isLessThan(_ a: Int, _ b: Int) -> Bool {\n    ///",
      "/// Returns `true` if the input `text` is a whole number.\n///\n/// - Parameter text: A string to check if it is a whole number.\n/// - Returns: `true` if the input `text` is a whole number.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}\n\nFunction:\n\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}\n## Documentation:\n/// Returns `true` if the input `text` is a whole number.\n///\n/// - Parameter text: A string to check if it is a whole number.\n/// - Returns: `true` if the input `text` is a whole number.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}\n\nFunction:\n\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}\n## Documentation:\n/// Returns `true` if the input `text` is a whole number.\n///",
      "/// Returns `true` if the given text contains the given substring.\nfunc containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n}\n\n## Example:\n/// Returns `true` if the given text contains the given substring.\n///\n/// - Parameter substring: The substring to check.\n/// - Parameter text: The text to check.\n/// - Returns: `true` if the given text contains the given substring.\nfunc containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n}\n\n## Tests:\nimport XCTest\n\nclass ContainsSubstringTests: XCTestCase {\n    func testContainsSubstring() {\n        XCTAssertEqual(containsSubstring(\"hello\", in: \"hello world\"), true)\n        XCTAssertEqual(containsSubstring(\"hello\", in: \"world\"), false)\n        XCTAssertEqual(containsSubstring(\"hello\", in: \"hello world\"), true)\n        XCTAssertEqual(containsSubstring(\"hello\", in: \"world\"), false",
      "/// Converts a string to a list of capitalized words.\nfunc stringToCapitalizedWords(_ text: String) -> [String] {\n    return text.split(separator: \" \").map { $0.capitalized }\n}\n\nThe documentation should be a single line that includes the following:\n\n* The function's name\n* A description of its purpose\n* The return type\n* A brief description of the parameters\n* A brief description of the return value\n\nThe documentation should not include the following:\n\n* The function's type\n* The function's implementation\n\n## Notes\n\n* The documentation should be formatted as a single line\n* The documentation should not include the function's type\n* The documentation should not include the function's implementation\n* The documentation should not include a trailing newline\n* The documentation should not include a trailing comment character\n* The documentation should not include a trailing comma\n* The documentation should not include a trailing block comment\n\n## Examples\n\n### A function that converts a string to a list of capitalized words\n\n/// Converts a string to a list of capitalized words.\nfunc stringToCapitalizedWords(_ text: String)",
      "func alternatingCase(_ text: String) -> String {\n    /// Returns a string with alternating case.\n    ///\n    /// - Parameter text: The string to be altered.\n    /// - Returns: The altered string.\n    /// - Precondition: The string is not empty.\n    /// - Complexity: O(n), where n is the length of the string.\n    return String(text.enumerated().map { (index, character) in\n        index % 2 == 0 ? character.lowercased() : character.uppercased()\n    })\n}\n\nFunction:\n\nfunc max(_ a: Int, _ b: Int) -> Int {\n    return a > b ? a : b\n}\n## Documentation:\nfunc max(_ a: Int, _ b: Int) -> Int {\n    /// Returns the largest of two integers.\n    ///\n    /// - Parameters:\n    ///   - a: The first integer.\n    ///   - b: The second integer.\n    /// - Returns: The larger of the two integers.\n    /// - Precondition: Neither integer is negative.\n    /// - Complexity: O(1).\n    return a > b ?",
      "func indexOfSubstring(_ substring: String, in text: String) -> Int? {\n    /// Returns the index of the first occurrence of a substring in a string.\n    ///\n    /// - Parameter substring: The string to search for.\n    /// - Parameter text: The string to search in.\n    /// - Returns: The index of the first occurrence of the substring, or nil if the substring is not found.\n    /// - Complexity: O(n), where n is the length of `text`.\n}\n\n## Notes:\n\n* This function returns the index of the first occurrence of a substring in a string.\n* The `indexOfSubstring` function takes two arguments: a `String` and a `String`.\n* The `indexOfSubstring` function returns the index of the first occurrence of a substring in a string.\n* The `indexOfSubstring` function is O(n), where n is the length of `text`.\n\n### Parameters\n\n* `substring`: A `String` representing the substring to search for.\n* `text`: A `String` representing the string to search in.\n\n",
      "/// Checks if a string is a palindrome by only considering letters.\n///\n/// - Parameter text: The string to check.\n/// - Returns: A boolean indicating if the string is a palindrome.\n/// - Complexity: O(n)\nfunc isAlphaOnlyPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}\n\nThe function isAlphaOnlyPalindrome checks if a string is a palindrome by only considering letters.\n\nThe function isAlphaOnlyPalindrome takes in a string.\n\nThe function returns a boolean indicating if the string is a palindrome.\n\nThe function isAlphaOnlyPalindrome runs in O(n) time, where n is the number of characters in the string.\n\n## Testing:\nfunc testIsAlphaOnlyPalindrome() {\n    XCTAssertEqual(true, isAlphaOnlyPalindrome(\"A man, a plan, a canal: Panama\"))\n    XCTAssertEqual(false, isAlphaOnlyPalindrome(\"race a car\"))\n    X",
      "/// Returns the uppercase letters in `text`.\n///\n/// - Parameter text: The text to extract uppercase letters from.\n/// - Returns: The uppercase letters in `text`.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}\n\n\n## Example:\n\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}\n\nextractUppercaseLetters(\"hello world\")\nextractUppercaseLetters(\"Hello world\")\n\n## Description:\n\nReturns the uppercase letters in `text`.\n\n- Parameter text: The text to extract uppercase letters from.\n\n- Returns: The uppercase letters in `text`.\n\n- Note: This function does not return an error.\n\n\n## Discussion:\n\nSwift does not have a built-in way to document functions. It is possible to use the comment syntax, but it is often better to use a Swift library like DocGen that can generate a full documentation file.\n",
      "/// Returns `true` if the given string is a binary number.\n///\n/// - Parameter text: The string to test.\n/// - Returns: `true` if the string is a binary number, `false` otherwise.\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}\n\nFunction:\n\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}\n## Documentation:\n/// Returns `true` if the given string is a binary number.\n///\n/// - Parameter text: The string to test.\n/// - Returns: `true` if the string is a binary number, `false` otherwise.\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}\n\nFunction:\n\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allS",
      "func capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}\n\n/// Capitalizes the first letter of a string.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}\n\n/// Capitalizes the first letter of a string.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}\n\n/// Capitalizes the first letter of a string.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}\n\n/// Capitalizes the first letter of a string.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text",
      "/// Convert a string to an array of characters.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}\n\n/// Convert a string to an array of characters.\n///\n/// - Parameter text: The string to convert.\n/// - Returns: The characters in the string.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}\n\n/// Convert a string to an array of characters.\n///\n/// - Parameter text: The string to convert.\n/// - Returns: The characters in the string.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}\n\n/// Convert a string to an array of characters.\n///\n/// - Parameter text: The string to convert.\n/// - Returns: The characters in the string.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}\n\n/// Convert a string to an array of characters.\n///\n/// - Parameter text: The string to convert.",
      "/// Returns a string repeated a number of times.\nfunc repeatString(_ text: String, count: Int) -> String {\n    return String(repeating: text, count: count)\n}\n## Description:\n\n/// Returns a string repeated a number of times.\nfunc repeatString(_ text: String, count: Int) -> String {\n    return String(repeating: text, count: count)\n}\n## Example:\n\n/// Example usage:\nrepeatString(\"Hello\", count: 5)\n/// Output:\n/// HelloHelloHelloHelloHello\n\n## Follow-up:\n\nThe documentation for repeatString(_:count:) should also include a reference to the function‚Äôs signature.\n\n## Hints:\n\n- Use /// to start the comment.\n- Use /// to end the comment.\n- Use /// to format the comment.\n- Use /// to add a description.\n- Use /// to add a parameter description.\n- Use /// to add an optional description.\n- Use /// to add a return description.\n- Use /// to add an optional return description.\n- Use ///",
      "/// Returns `true` if the given time string is valid.\n///\n/// - Parameter text: The time string to test.\n/// - Returns: `true` if the given time string is valid.\nfunc isValidTime(_ text: String) -> Bool {\n    let pattern = \"^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$\"\n    return matchesRegex(text, pattern: pattern)\n}\n\n## Examples:\n/// Returns `true` if the given time string is valid.\n///\n/// - Parameter text: The time string to test.\n/// - Returns: `true` if the given time string is valid.\nfunc isValidTime(_ text: String) -> Bool {\n    let pattern = \"^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$\"\n    return matchesRegex(text, pattern: pattern)\n}\n\n## Tests:\nimport XCTest\n\nclass IsValidTimeTests: XCTestCase {\n    func testIsValid",
      "/// Extracts digits and dashes from a string.\n///\n/// - Parameter text: The string to extract digits and dashes from.\n/// - Returns: A string containing only digits and dashes.\nfunc extractDigitsAndDashes(from text: String) -> String {\n    return text.filter { $0.isNumber || $0 == \"-\" }\n}\n\nThe function extractDigitsAndDashes() returns a string containing only digits and dashes.\n\n### Examples\n\n```swift\nprint(extractDigitsAndDashes(\"123-456-7890\"))\n// \"1234567890\"\n```\n\n### Required Implementations\n\n- The function must be named extractDigitsAndDashes().\n- The function must return a string containing only digits and dashes.\n- The function must be in the public API.\n- The function must be in the public API.\n- The function must have an inline comment.\n- The function must have a parameter named text.\n- The function must have a return value.\n- The function must have a return value.\n- The function",
      "/// Returns the lowercase letters from a given string without numbers.\nfunc lowercaseLettersWithoutNumbers(from text: String) -> String {\n    return text.filter { $0.isLetter }.lowercased()\n}\n\nFunction:\n\nfunc removeFromString(string: String, index: Int) -> String {\n    let startIndex = string.index(string.startIndex, offsetBy: index)\n    return String(string[startIndex...])\n}\n## Documentation:\n\n/// Removes a given index from a string.\nfunc removeFromString(string: String, index: Int) -> String {\n    let startIndex = string.index(string.startIndex, offsetBy: index)\n    return String(string[startIndex...])\n}\n\nFunction:\n\nfunc convertToString(number: Double) -> String {\n    return String(number)\n}\n## Documentation:\n\n/// Converts a given number to a string.\nfunc convertToString(number: Double) -> String {\n    return String(number)\n}\n\nFunction:\n\nfunc addTwoNumbers(first number: Int, second number: Int) -> Int {\n   ",
      "func allStringsHaveEqualLength(_ array: [String]) -> Bool {\n    guard let firstLength = array.first?.count else { return true }\n    return array.allSatisfy { $0.count == firstLength }\n}\n## Description:\n\nReturns `true` if all strings in the given array have the same length.\n\n## Parameters:\n- array: An array of strings.\n\n## Return Value:\n\n`Bool`\n\n## Example:\n```\nlet strings = [\"Hello\", \"Goodbye\", \"Ohai\"]\nassert(allStringsHaveEqualLength(strings))\n```\n\n## Notes:\n\nThe first element in the array is used to find the length of the shortest string. If the array is empty, the function returns `true`.\n\n## References:\n- [allSatisfy](https://developer.apple.com/documentation/swift/allsatisfy)\n- [first](https://developer.apple.com/documentation/swift/first)\n- [count](https://developer.apple.com/documentation/swift/count)\n- [return](https://",
      "/// Splits a string by a character.\n///\n/// - Parameter text: The string to split.\n/// - Parameter separator: The character to split on.\n/// - Returns: The split strings.\nfunc splitStringByCharacter(_ text: String, separator: Character) -> [String] {\n    return text.split(separator: separator).map { String($0) }\n}\n\n## Discussion:\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by",
      "func isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}\n\nFunction:\n\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}\n## Documentation:\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}\n\nFunction:\n\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}\n## Documentation:\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+",
      "/// Converts a string to a date.\n///\n/// - Parameter text: The text to convert.\n/// - Returns: A date, or nil if the text is invalid.\nfunc stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    return formatter.date(from: text)\n}\n\nFunction:\n\nfunc add(a: Int, to b: Int) -> Int {\n    return a + b\n}\n## Documentation:\n/// Adds two integers.\n///\n/// - Parameters:\n///   - a: The first integer.\n///   - b: The second integer.\n/// - Returns: The sum of the two integers.\nfunc add(a: Int, to b: Int) -> Int {\n    return a + b\n}\n\nFunction:\n\nfunc print(text: String) {\n    print(text)\n}\n## Documentation:\n/// Prints text.\n///\n/// - Parameter text: The text to print.\nfunc print",
      "/// Removes whitespace and newlines from a string.\nfunc cleanString(_ text: String) -> String {\n    let charactersToRemove = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)\n    return text.filter { !charactersToRemove.contains($0.unicodeScalars.first!) }\n}\n\n## How to write a comment in Swift\n\nSwift code comments are written using ///-style comments.\n\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///",
      "/// Converts a string to an integer with a given base.\n///\n/// - Parameter text: The string to convert.\n/// - Parameter base: The base to convert the string to.\n/// - Returns: The integer value of the string, or `nil` if the conversion fails.\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}\n\nFunction:\n\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}\n## Documentation:\n/// Converts a string to an integer with a given base.\n///\n/// - Parameter text: The string to convert.\n/// - Parameter base: The base to convert the string to.\n/// - Returns: The integer value of the string, or `nil` if the conversion fails.\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}\n\nFunction:\n\nfunc stringToNumberWithBase(_",
      "/// Returns the number of unique characters in the provided string.\nfunc countUniqueCharacters(in text: String) -> Int {\n    return Set(text).count\n}\n\nFunction:\n\nfunc generateRandomString(with length: Int) -> String {\n    var randomString = \"\"\n    for _ in 0..<length {\n        let randomCharacter = \"\\(randomCharacters[random.nextInt(in: 0..<26)])\"\n        randomString.append(randomCharacter)\n    }\n    return randomString\n}\n## Documentation:\n/// Returns a random string of a given length.\nfunc generateRandomString(with length: Int) -> String {\n    var randomString = \"\"\n    for _ in 0..<length {\n        let randomCharacter = \"\\(randomCharacters[random.nextInt(in: 0..<26)])\"\n        randomString.append(randomCharacter)\n    }\n    return randomString\n}\n\nFunction:\n\nfunc getUserName(at index: Int) -> String {\n    return users[index].userName\n}\n## Documentation:\n/// Returns the username of the user at the given index.\nfunc getUserName",
      "/**\nReturns the characters in `text` that appear only once.\n\n- parameter text: The string to filter.\n- returns: The filtered string.\n*/\nfunc uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text.reduce(into: [:]) { counts, char in counts[char, default: 0] += 1 }\n    return String(text.filter { characterCount[$0] == 1 })\n}\n\n## Test:\n\nimport XCTest\n\nclass UniqueCharactersOnlyTests: XCTestCase {\n    func testExample() {\n        XCTAssertEqual(uniqueCharactersOnly(in: \"abc\"), \"abc\")\n        XCTAssertEqual(uniqueCharactersOnly(in: \"abbccc\"), \"bccc\")\n        XCTAssertEqual(uniqueCharactersOnly(in: \"aabbccddeeef\"), \"eeeff\")\n    }\n\n    static var allTests = [\n        (\"testExample\", testExample),\n    ]\n}\n\n## Solution:\n\n/**\nReturns the characters in `text` that appear only once.\n\n- parameter text: The string",
      "func isValidEmail(_ text: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"\n    return matchesRegex(text, pattern: emailRegex)\n}\n## Description:\nChecks to see if an email address is valid.\n\n## Parameters:\ntext: String - The string to check for validity.\n\n## Returns:\nBool - True if the string is a valid email, false otherwise.\n\n## Notes:\nThis function uses a regular expression to check for valid email addresses.\n\n## Example:\nisValidEmail(\"john@example.com\") // true\nisValidEmail(\"john@example\") // false\nisValidEmail(\"john@example.com.\") // false\nisValidEmail(\"john@example.com@\") // true\nisValidEmail(\"john@example.com@gmail.com\") // true\nisValidEmail(\"john@example.com@gmail.com@\") // false\nisValidEmail(\"john",
      "/// Extracts numbers from a string.\n///\n/// - Parameter text: The string to extract numbers from.\n/// - Returns: The string with numbers removed.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n\nFunction:\n\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n## Documentation:\n/// Extracts numbers from a string.\n///\n/// - Parameter text: The string to extract numbers from.\n/// - Returns: The string with numbers removed.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n\nFunction:\n\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n## Documentation:\n/// Extracts numbers from a string.\n///\n/// - Parameter text: The string to extract numbers from.\n/// - Returns: The string with numbers removed.\nfunc extractNumbersFromString(_ text: String",
      "/// Converts a text string to a percentage string.\n///\n/// - Parameter text: A string to convert to a percentage string.\n/// - Parameter precision: The number of decimal places to include in the returned string.\n/// - Returns: The percentage string.\n/// - Complexity: O(1)\nfunc stringToPercentage(_ text: String, precision: Int) -> String? {\n    guard let number = Double(text) else { return nil }\n    let percentage = number * 100\n    return String(format: \"%.\\(precision)f%%\", percentage)\n}\n\n## Review\n\n- Use the SwiftDoc framework to write documentation comments.\n- Write documentation comments that help future developers understand the function's purpose.\n- Write documentation comments that include parameter and return descriptions, and emphasize intent over implementation.\n\n### Write documentation comments that help future developers understand the function's purpose.\n- Write a short description of where and how the function is used.\n- Write a short description of the function's purpose.\n- Write a short description of the function's intent.\n- Write a short description of the function's implementation.\n- Write a short description",
      "/**\n Converts a string to alternating upper and lower case characters.\n \n - Parameters:\n    - text: The string to convert.\n \n - Returns:\n    - The string with alternating upper and lower case characters.\n */\nfunc alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}\n\n## Use-Case:\n\n/// Converts a string to alternating upper and lower case characters.\n///\n/// - Parameters:\n///   - text: The string to convert.\n/// - Returns:\n///   - The string with alternating upper and lower case characters.\nfunc alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}\n\n## Summary:\n\nConverts a string to alternating upper and lower case characters.\n\n- Parameters:\n   ",
      "///Returns `true` if the given string is a number.\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}\n\nFunction:\n\nfunc isValidEmail(_ email: String) -> Bool {\n    return email.contains(\"@\")\n}\n## Documentation:\n///Returns `true` if the given string is a valid email address.\nfunc isValidEmail(_ email: String) -> Bool {\n    return email.contains(\"@\")\n}\n\nFunction:\n\nfunc isValidPassword(_ password: String) -> Bool {\n    return password.count >= 8\n}\n## Documentation:\n///Returns `true` if the given string is a valid password.\nfunc isValidPassword(_ password: String) -> Bool {\n    return password.count >= 8\n}\n\nFunction:\n\nfunc isValidURL(_ url: String) -> Bool {\n    return URL(string: url) != nil\n}\n## Documentation:\n///Returns `true` if the given string is a valid URL.\nfunc isValidURL(_ url: String) -> Bool {\n    return URL(",
      "/// Reverses an array in place.\n///\n/// - Parameter array: The array to reverse.\n/// - Returns: The reversed array.\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}\n\n## Why:\n\nThis function is used to reverse an array in place. The return type is inferred as `[T]` because `reverseArray` has no side effects and the return value is not modified.\n\n## How:\n\nThe comment describes the purpose of the function and its return type. The description of the parameters is provided in the function body.\n\n## Example:\n\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}\n/// Reverses an array in place.\n///\n/// - Parameter array: The array to reverse.\n/// - Returns: The reversed array.\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}\n\n## Notes:\n\nThe comment does not include the function's type. The function type",
      "/// Returns a random element from a dictionary.\n///\n/// - Parameter dictionary: The dictionary to randomly select an element from.\n/// - Returns: The element, or `nil` if the dictionary is empty.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}\n\n## Notes\n\n* This function returns a random element from a dictionary.\n* The `dictionary` parameter is a dictionary of key-value pairs.\n* The `dictionary` is randomly selected, and the return value is the key and value of the randomly selected element.\n* If the `dictionary` is empty, `nil` is returned.\n\n## Examples\n\n```swift\nlet dictionary = [\"apple\": \"red\", \"banana\": \"yellow\"]\nlet randomElement = randomElementFromDictionary(dictionary)\nif let randomElement = randomElement {\n    print(\"The random element is \\(randomElement.0) \\(randomElement.1)\")\n}\n```\n\n## Discussion\n\nThis function returns a random element from a dictionary. The `dictionary`",
      "```swift\nfunc keysWithMinValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable, Value: Comparable {\n    guard let minValue = dictionary.values.min() else { return [] }\n    return dictionary.filter { $0.value == minValue }.map { $0.key }\n}\n```\n\n## Description:\n\nReturns a dictionary of keys with values less than or equal to the minimum value in the dictionary.\n\n## Parameters:\n\n- dictionary: A dictionary of `Key` to `Value` pairs.\n\n## Returns:\n\nA dictionary of keys with values less than or equal to the minimum value in the dictionary.\n\n## Notes:\n\n- This function is optimized for dictionaries containing comparable values, such as `Int` and `Double`.\n- The function returns an empty array if the dictionary contains no values that are less than or equal to the minimum value.\n- The function returns an empty array if the dictionary is empty.\n- If the dictionary does not contain a value that is less than or equal to the minimum value, the function does not return any keys.\n- The function uses `filter",
      "/// Returns `true` if the given date is in the future, `false` otherwise.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n\nFunction:\n\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n## Documentation:\n/// Returns `true` if the given date is in the future, `false` otherwise.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n\nFunction:\n\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n## Documentation:\n/// Returns `true` if the given date is in the future, `false` otherwise.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n\nFunction:\n\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n## Documentation:\n/// Returns `true` if the given date is in the future, `false` otherwise.\nfunc isFutureDate(_ date: Date) -> Bool {",
      "func stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    /// Transforms a string into an alphabetic character array.\n    ///\n    /// - Parameter str: The string to transform.\n    /// - Returns: The alphabetic character array.\n    ///\n    /// - Complexity: O(n) where n is the length of the string.\n}\n\n## Example:\n\nfunc stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    /// Transforms a string into an alphabetic character array.\n    ///\n    /// - Parameter str: The string to transform.\n    /// - Returns: The alphabetic character array.\n    ///\n    /// - Complexity: O(n) where n is the length of the string.\n    return str.filter { $0.isLetter }\n}\n\n## Notes:\n\nThis function takes a string and returns an alphabetic character array. It filters out all non-alphabetic characters, then returns the result.\n\n## Tests:\n\nimport XCTest\nimport SwiftDoc\n\nfinal class StringToAlphabeticCharArrayTests: XCTestCase {\n    func",
      "/// Calculates the number of days between two dates.\n///\n/// - Parameters:\n///   - startDate: A date to start with.\n///   - endDate: A date to end at.\n/// - Returns: The number of days between startDate and endDate.\n///\n/// - Complexity: O(1).\nfunc daysBetweenDates(_ startDate: Date, _ endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}\n\nFunction:\n\nfunc daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}\n## Documentation:\n\n/// Calculates the number of days between two dates.\n///\n/// - Parameters:\n///   - startDate: A date to start with.\n///   - endDate: A date to end at.\n/// - Returns: The number of days between startDate and end",
      "func sumOfNumbersInString(_ str: String) -> Int {\n    /// Returns the sum of all numbers in a given string.\n    /// - Parameter str: A string containing numbers.\n    /// - Returns: The sum of all numbers in the string.\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.reduce(0, +)\n}\n\nFunction:\n\nfunc isValidPassword(_ password: String) -> Bool {\n    let passwordChars = Array(password)\n    let passwordLength = passwordChars.count\n    let passwordRegex = \"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[$@$!%*?&])([a-zA-Z\\\\d$@$!%*?&]{8,})$\"\n    let passwordRegex = \"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[$@$!%*?&])([a-zA-Z\\\\d$@"
    ],
    "REFERENCES": [
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–æ–∫–µ–Ω–∞ –≤ UserDefaults.\n/// - Returns: true, –µ—Å–ª–∏ —Ç–æ–∫–µ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –Ω–µ –∏—Å—Ç—ë–∫.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞\n    return !token.isEmpty\n}"
      ],
      [
        "/// –§–æ—Ä–º–∏—Ä—É–µ—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ —Å—É—Ç–æ–∫.\n/// - Parameter name: –ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Returns: –ü–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ.\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ, \\(name)\"\n    case 12..<18: return \"–î–æ–±—Ä—ã–π –¥–µ–Ω—å, \\(name)\"\n    case 18..<23: return \"–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä, \\(name)\"\n    default: return \"–î–æ–±—Ä–æ–π –Ω–æ—á–∏, \\(name)\"\n    }\n}"
      ],
      [
        "/// –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å—É–º–º—É –≤ —Ä—É–±–ª—è—Ö –≤ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É —Å –≤–∞–ª—é—Ç–æ–π.\n/// - Parameter amount: –°—É–º–º–∞ –≤ —Ä—É–±–ª—è—Ö.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —Å–∏–º–≤–æ–ª–æ–º —Ä—É–±–ª—è.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"‚ÇΩ\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ‚ÇΩ\"\n}"
      ],
      [
        "/// –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å –∑–∞–¥–∞–Ω–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º.\n/// - Parameter message: –¢–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}"
      ],
      [
        "/// –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å onboarding –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–ª–∞–≥–∞ –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ.\n/// - Returns: true, –µ—Å–ª–∏ onboarding –µ—â—ë –Ω–µ –ø—Ä–æ–π–¥–µ–Ω.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}"
      ],
      [
        "/// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞.\n/// - Parameter productId: ID —Ç–æ–≤–∞—Ä–∞.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}"
      ],
      [
        "/// –û—Ü–µ–Ω–∏–≤–∞–µ—Ç, —Å–ª–µ–¥—É–µ—Ç –ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –≤—Å–ø–ª—ã–≤–∞—é—â–µ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.\n/// - Returns: true, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤–∏–¥–µ–ª –±–∞–Ω–Ω–µ—Ä –±–æ–ª–µ–µ —Å—É—Ç–æ–∫.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ —Å—Ç—Ä–æ–∫—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ UI.\n/// - Parameters:\n///   - lat: –®–∏—Ä–æ—Ç–∞.\n///   - lon: –î–æ–ª–≥–æ—Ç–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∑–∞–ø–æ–ª–Ω–µ–Ω—ã –ª–∏ –≤—Å–µ –ø–æ–ª—è –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Parameter profile: –°–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏ –ø—Ä–æ—Ñ–∏–ª—è.\n/// - Returns: true, –µ—Å–ª–∏ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –Ω–µ –ø—É—Å—Ç—ã–µ.\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}"
      ],
      [
        "/// –í–∞–ª–∏–¥–∏—Ä—É–µ—Ç –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ä–æ—Å—Å–∏–π—Å–∫–æ–º—É —Ñ–æ—Ä–º–∞—Ç—É.\n/// - Parameter phone: –°—Ç—Ä–æ–∫–∞ –Ω–æ–º–µ—Ä–∞.\n/// - Returns: true, –µ—Å–ª–∏ –Ω–æ–º–µ—Ä –≤–∞–ª–∏–¥–µ–Ω.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Ä–µ–π—Ç–∏–Ω–≥ (–æ—Ç 0 –¥–æ 5) –≤ —Å—Ç—Ä–æ–∫—É —Å —ç–º–æ–¥–∑–∏-–∑–≤–µ–∑–¥–∞–º–∏.\n/// - Parameter rating: –ó–Ω–∞—á–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ –∏–∑ –∑–≤—ë–∑–¥.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"‚òÖ\", count: filledStars) + String(repeating: \"‚òÜ\", count: emptyStars)\n}"
      ],
      [
        "/// –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –µ—Å—Ç—å –ª–∏ –∞–∫—Ç–∏–≤–Ω–∞—è –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–µ—Å—Å–∏—è.\n/// - Returns: true, –µ—Å–ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω.\nfunc isInternetAvailable() -> Bool {\n    // –£–ø—Ä–æ—â—ë–Ω–Ω–æ, –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞ ‚Äî —Ä–µ–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ–±—É–µ—Ç Reachability\n    return true\n}"
      ],
      [
        "/// –°—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç –¥–∞—Ç—É –¥–æ—Å—Ç–∞–≤–∫–∏ —Å —Ç–µ–∫—É—â–µ–π –¥–∞—Ç–æ–π –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å.\n/// - Parameter deliveryDate: –î–∞—Ç–∞ –¥–æ—Å—Ç–∞–≤–∫–∏.\n/// - Returns: –°—Ç–∞—Ç—É—Å —Å—Ç—Ä–æ–∫–∏: \"–°–µ–≥–æ–¥–Ω—è\", \"–ó–∞–≤—Ç—Ä–∞\", \"–ü–æ–∑–∂–µ\".\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"–°–µ–≥–æ–¥–Ω—è\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"–ó–∞–≤—Ç—Ä–∞\"\n    } else {\n        return \"–ü–æ–∑–∂–µ\"\n    }\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å–ø–∏—Å–æ–∫ —Ç–µ–≥–æ–≤ –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É —Å —Ö–µ—à—Ç–µ–≥–∞–º–∏.\n/// - Parameter tags: –°–ø–∏—Å–æ–∫ —Ç–µ–≥–æ–≤.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —Ö–µ—à—Ç–µ–≥–∞–º–∏.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}"
      ],
      [
        "/// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é —Å–∫—Ä–æ–ª–ª–∞ –≤ —Å–ø–∏—Å–∫–µ —Ç–æ–≤–∞—Ä–æ–≤.\n/// - Parameter offset: –ó–Ω–∞—á–µ–Ω–∏–µ —Å–º–µ—â–µ–Ω–∏—è.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –∑–æ–Ω–µ –¥–æ—Å—Ç–∞–≤–∫–∏ (–ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º).\n/// - Parameters:\n///   - lat: –®–∏—Ä–æ—Ç–∞.\n///   - lon: –î–æ–ª–≥–æ—Ç–∞.\n/// - Returns: true, –µ—Å–ª–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤—Ö–æ–¥—è—Ç –≤ —Ä–∞–¥–∏—É—Å.\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // –ú–æ—Å–∫–≤–∞\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}"
      ],
      [
        "/// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç URL –¥–ª—è deeplink —Å –∑–∞–¥–∞–Ω–Ω—ã–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º —Ç–æ–≤–∞—Ä–∞.\n/// - Parameter productId: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä.\n/// - Returns: URL –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–ª –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏.\n/// - Parameter lastViewedId: –ü–æ—Å–ª–µ–¥–Ω–∏–π –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω—ã–π ID.\n/// - Parameter newMessageId: ID –Ω–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è.\n/// - Returns: true, –µ—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.\nfunc hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}"
      ],
      [
        "/// –í—ã—á–∏—Å–ª—è–µ—Ç –ø—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ —Ü–µ–ª–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–π).\n/// - Parameters:\n///   - current: –¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.\n///   - target: –¶–µ–ª–µ–≤–∞—è —Å—É–º–º–∞.\n/// - Returns: –ü—Ä–æ—Ü–µ–Ω—Ç –æ—Ç 0 –¥–æ 100.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–æ–∫–µ–Ω–∞ –≤ UserDefaults.\n/// - Returns: true, –µ—Å–ª–∏ —Ç–æ–∫–µ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –Ω–µ –∏—Å—Ç—ë–∫.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞\n    return !token.isEmpty\n}"
      ],
      [
        "/// –§–æ—Ä–º–∏—Ä—É–µ—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ —Å—É—Ç–æ–∫.\n/// - Parameter name: –ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Returns: –ü–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ.\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ, \\(name)\"\n    case 12..<18: return \"–î–æ–±—Ä—ã–π –¥–µ–Ω—å, \\(name)\"\n    case 18..<23: return \"–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä, \\(name)\"\n    default: return \"–î–æ–±—Ä–æ–π –Ω–æ—á–∏, \\(name)\"\n    }\n}"
      ],
      [
        "/// –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å—É–º–º—É –≤ —Ä—É–±–ª—è—Ö –≤ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É —Å –≤–∞–ª—é—Ç–æ–π.\n/// - Parameter amount: –°—É–º–º–∞ –≤ —Ä—É–±–ª—è—Ö.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —Å–∏–º–≤–æ–ª–æ–º —Ä—É–±–ª—è.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"‚ÇΩ\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ‚ÇΩ\"\n}"
      ],
      [
        "/// –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å –∑–∞–¥–∞–Ω–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º.\n/// - Parameter message: –¢–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}"
      ],
      [
        "/// –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å onboarding –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–ª–∞–≥–∞ –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ.\n/// - Returns: true, –µ—Å–ª–∏ onboarding –µ—â—ë –Ω–µ –ø—Ä–æ–π–¥–µ–Ω.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}"
      ],
      [
        "/// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞.\n/// - Parameter productId: ID —Ç–æ–≤–∞—Ä–∞.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}"
      ],
      [
        "/// –û—Ü–µ–Ω–∏–≤–∞–µ—Ç, —Å–ª–µ–¥—É–µ—Ç –ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –≤—Å–ø–ª—ã–≤–∞—é—â–µ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.\n/// - Returns: true, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤–∏–¥–µ–ª –±–∞–Ω–Ω–µ—Ä –±–æ–ª–µ–µ —Å—É—Ç–æ–∫.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ —Å—Ç—Ä–æ–∫—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ UI.\n/// - Parameters:\n///   - lat: –®–∏—Ä–æ—Ç–∞.\n///   - lon: –î–æ–ª–≥–æ—Ç–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∑–∞–ø–æ–ª–Ω–µ–Ω—ã –ª–∏ –≤—Å–µ –ø–æ–ª—è –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Parameter profile: –°–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏ –ø—Ä–æ—Ñ–∏–ª—è.\n/// - Returns: true, –µ—Å–ª–∏ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –Ω–µ –ø—É—Å—Ç—ã–µ.\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}"
      ],
      [
        "/// –í–∞–ª–∏–¥–∏—Ä—É–µ—Ç –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ä–æ—Å—Å–∏–π—Å–∫–æ–º—É —Ñ–æ—Ä–º–∞—Ç—É.\n/// - Parameter phone: –°—Ç—Ä–æ–∫–∞ –Ω–æ–º–µ—Ä–∞.\n/// - Returns: true, –µ—Å–ª–∏ –Ω–æ–º–µ—Ä –≤–∞–ª–∏–¥–µ–Ω.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Ä–µ–π—Ç–∏–Ω–≥ (–æ—Ç 0 –¥–æ 5) –≤ —Å—Ç—Ä–æ–∫—É —Å —ç–º–æ–¥–∑–∏-–∑–≤–µ–∑–¥–∞–º–∏.\n/// - Parameter rating: –ó–Ω–∞—á–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ –∏–∑ –∑–≤—ë–∑–¥.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"‚òÖ\", count: filledStars) + String(repeating: \"‚òÜ\", count: emptyStars)\n}"
      ],
      [
        "/// –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –µ—Å—Ç—å –ª–∏ –∞–∫—Ç–∏–≤–Ω–∞—è –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–µ—Å—Å–∏—è.\n/// - Returns: true, –µ—Å–ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω.\nfunc isInternetAvailable() -> Bool {\n    // –£–ø—Ä–æ—â—ë–Ω–Ω–æ, –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞ ‚Äî —Ä–µ–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ–±—É–µ—Ç Reachability\n    return true\n}"
      ],
      [
        "/// –°—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç –¥–∞—Ç—É –¥–æ—Å—Ç–∞–≤–∫–∏ —Å —Ç–µ–∫—É—â–µ–π –¥–∞—Ç–æ–π –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å.\n/// - Parameter deliveryDate: –î–∞—Ç–∞ –¥–æ—Å—Ç–∞–≤–∫–∏.\n/// - Returns: –°—Ç–∞—Ç—É—Å —Å—Ç—Ä–æ–∫–∏: \"–°–µ–≥–æ–¥–Ω—è\", \"–ó–∞–≤—Ç—Ä–∞\", \"–ü–æ–∑–∂–µ\".\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"–°–µ–≥–æ–¥–Ω—è\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"–ó–∞–≤—Ç—Ä–∞\"\n    } else {\n        return \"–ü–æ–∑–∂–µ\"\n    }\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å–ø–∏—Å–æ–∫ —Ç–µ–≥–æ–≤ –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É —Å —Ö–µ—à—Ç–µ–≥–∞–º–∏.\n/// - Parameter tags: –°–ø–∏—Å–æ–∫ —Ç–µ–≥–æ–≤.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —Ö–µ—à—Ç–µ–≥–∞–º–∏.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}"
      ],
      [
        "/// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é —Å–∫—Ä–æ–ª–ª–∞ –≤ —Å–ø–∏—Å–∫–µ —Ç–æ–≤–∞—Ä–æ–≤.\n/// - Parameter offset: –ó–Ω–∞—á–µ–Ω–∏–µ —Å–º–µ—â–µ–Ω–∏—è.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –∑–æ–Ω–µ –¥–æ—Å—Ç–∞–≤–∫–∏ (–ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º).\n/// - Parameters:\n///   - lat: –®–∏—Ä–æ—Ç–∞.\n///   - lon: –î–æ–ª–≥–æ—Ç–∞.\n/// - Returns: true, –µ—Å–ª–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤—Ö–æ–¥—è—Ç –≤ —Ä–∞–¥–∏—É—Å.\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // –ú–æ—Å–∫–≤–∞\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}"
      ],
      [
        "/// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç URL –¥–ª—è deeplink —Å –∑–∞–¥–∞–Ω–Ω—ã–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º —Ç–æ–≤–∞—Ä–∞.\n/// - Parameter productId: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä.\n/// - Returns: URL –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–ª –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏.\n/// - Parameter lastViewedId: –ü–æ—Å–ª–µ–¥–Ω–∏–π –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω—ã–π ID.\n/// - Parameter newMessageId: ID –Ω–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è.\n/// - Returns: true, –µ—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.\nfunc hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}"
      ],
      [
        "/// –í—ã—á–∏—Å–ª—è–µ—Ç –ø—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ —Ü–µ–ª–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–π).\n/// - Parameters:\n///   - current: –¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.\n///   - target: –¶–µ–ª–µ–≤–∞—è —Å—É–º–º–∞.\n/// - Returns: –ü—Ä–æ—Ü–µ–Ω—Ç –æ—Ç 0 –¥–æ 100.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ Terms & Conditions –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ª–æ–∫–∞–ª–∏.\n/// - Returns: URL —Å—Ç—Ä–∞–Ω–∏—Ü—ã —É—Å–ª–æ–≤–∏–π –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è.\nfunc termsAndConditionsURL() -> URL? {\n    let locale = Locale.current.languageCode ?? \"en\"\n    return URL(string: \"https://example.com/terms_\\(locale).html\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–∞—Å—Ç—É–ø–∏–ª–æ –ª–∏ –≤—Ä–µ–º—è –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Å–æ–±—ã—Ç–∏—è.\n/// - Parameter date: –î–∞—Ç–∞ —Å–æ–±—ã—Ç–∏—è.\n/// - Returns: true, –µ—Å–ª–∏ —Å–æ–±—ã—Ç–∏–µ —É–∂–µ –Ω–∞—á–∞–ª–æ—Å—å.\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}"
      ],
      [
        "/// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—É—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º —Ç–µ–º—É –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è.\n/// - Parameter theme: –ù–∞–∑–≤–∞–Ω–∏–µ —Ç–µ–º—ã.\nfunc saveUserTheme(_ theme: String) {\n    UserDefaults.standard.set(theme, forKey: \"appTheme\")\n}"
      ],
      [
        "/// –ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—É—â—É—é —Ç–µ–º—É –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è.\n/// - Returns: –ù–∞–∑–≤–∞–Ω–∏–µ —Ç–µ–º—ã –∏–ª–∏ nil.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}"
      ],
      [
        "/// –û—á–∏—â–∞–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞.\nfunc clearUserSession() {\n    let keys = [\"authToken\", \"userProfile\", \"lastViewedProduct\"]\n    keys.forEach { UserDefaults.standard.removeObject(forKey: $0) }\n}"
      ],
      [
        "/// –§–æ—Ä–º–∏—Ä—É–µ—Ç —Å—Ç—Ä–æ–∫—É –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.\n/// - Returns: –¢–µ–∫—Å—Ç –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏.\nfunc generateFeedbackTemplate() -> String {\n    let systemVersion = UIDevice.current.systemVersion\n    let model = UIDevice.current.model\n    return \"–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: \\(model)\\n–í–µ—Ä—Å–∏—è iOS: \\(systemVersion)\\n–í–∞—à –æ—Ç–∑—ã–≤: \"\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –¥–æ—Å—Ç–∏–≥ –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ª–∏–º–∏—Ç–∞ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π.\n/// - Parameter count: –¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ–π—Å—Ç–≤–∏–π.\n/// - Returns: true, –µ—Å–ª–∏ –ª–∏–º–∏—Ç –¥–æ—Å—Ç–∏–≥–Ω—É—Ç.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}"
      ],
      [
        "/// –§–æ—Ä–º–∏—Ä—É–µ—Ç —Å—Ç—Ä–æ–∫—É –¥–∞—Ç—ã –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏ –∑–∞–∫–∞–∑–æ–≤.\n/// - Parameter date: –î–∞—Ç–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ \"dd MMM yyyy\".\nfunc formatOrderDate(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd MMM yyyy\"\n    return formatter.string(from: date)\n}"
      ],
      [
        "/// –í—ã—á–∏—Å–ª—è–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –º–µ–∂–¥—É –¥–≤—É–º—è –¥–∞—Ç–∞–º–∏.\n/// - Parameters:\n///   - from: –ù–∞—á–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞.\n///   - to: –ö–æ–Ω–µ—á–Ω–∞—è –¥–∞—Ç–∞.\n/// - Returns: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π.\nfunc daysBetween(_ from: Date, _ to: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: from, to: to).day ?? 0\n}"
      ],
      [
        "/// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω–æ–≥–æ –±–∞–Ω–Ω–µ—Ä–∞.\n/// - Parameter id: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –±–∞–Ω–Ω–µ—Ä–∞.\nfunc saveLastSeenBannerId(_ id: String) {\n    UserDefaults.standard.set(id, forKey: \"lastSeenBannerId\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å–ª–µ–¥—É–µ—Ç –ª–∏ –æ–±–Ω–æ–≤–∏—Ç—å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.\n/// - Parameter lastUpdate: –î–∞—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.\n/// - Returns: true, –µ—Å–ª–∏ –ø—Ä–æ—à–ª–æ –±–æ–ª—å—à–µ 6 —á–∞—Å–æ–≤.\nfunc shouldRefreshCache(since lastUpdate: Date) -> Bool {\n    return Date().timeIntervalSince(lastUpdate) > 6 * 3600\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–æ–∫–µ–Ω–∞ –≤ UserDefaults.\n/// - Returns: true, –µ—Å–ª–∏ —Ç–æ–∫–µ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –Ω–µ –∏—Å—Ç—ë–∫.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞\n    return !token.isEmpty\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–æ–≤—ã–º (–Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞—Ç—ã —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏).\n/// - Parameter registrationDate: –î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Returns: true, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –º–µ–Ω–µ–µ 7 –¥–Ω–µ–π –Ω–∞–∑–∞–¥.\nfunc isNewUser(registrationDate: Date) -> Bool {\n    return Date().timeIntervalSince(registrationDate) < 7 * 86400\n}"
      ],
      [
        "/// –ü–æ–ª—É—á–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—É—Å–∫–æ–≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.\n/// - Returns: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—É—Å–∫–æ–≤.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}"
      ],
      [
        "/// –£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Å—á—ë—Ç—á–∏–∫ –∑–∞–ø—É—Å–∫–æ–≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.\nfunc incrementAppLaunchCount() {\n    let count = getAppLaunchCount() + 1\n    UserDefaults.standard.set(count, forKey: \"launchCount\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –¥–æ—Å—Ç—É–ø–µ–Ω –ª–∏ Face ID –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.\n/// - Returns: true, –µ—Å–ª–∏ Face ID –¥–æ—Å—Ç—É–ø–µ–Ω.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}"
      ],
      [
        "/// –ü–æ–ª—É—á–∞–µ—Ç –∏–º—è –º–µ—Å—è—Ü–∞ –Ω–∞ —Ä—É—Å—Å–∫–æ–º –ø–æ –Ω–æ–º–µ—Ä—É.\n/// - Parameter month: –ù–æ–º–µ—Ä –º–µ—Å—è—Ü–∞ –æ—Ç 1 –¥–æ 12.\n/// - Returns: –ù–∞–∑–≤–∞–Ω–∏–µ –º–µ—Å—è—Ü–∞.\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.monthSymbols[safe: month - 1] ?? \"\"\n}"
      ],
      [
        "/// –§–æ—Ä–º–∏—Ä—É–µ—Ç URL –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ –∏—Å—Ç–æ—Ä–∏–∏ –∑–∞–∫–∞–∑–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Parameter userId: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Returns: URL —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º userId.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}"
      ],
      [
        "/// –ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ \"darkMode\".\n/// - Returns: true, –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–∞ —Ç—ë–º–Ω–∞—è —Ç–µ–º–∞.\nfunc isDarkModeEnabled() -> Bool {\n    return UserDefaults.standard.bool(forKey: \"darkMode\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –µ—Å—Ç—å –ª–∏ –¥–æ—Å—Ç—É–ø –∫ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏.\n/// - Returns: true, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø —Ä–∞–∑—Ä–µ—à—ë–Ω.\nfunc isLocationAccessGranted() -> Bool {\n    return CLLocationManager.authorizationStatus() == .authorizedWhenInUse || CLLocationManager.authorizationStatus() == .authorizedAlways\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å–µ–∫—É–Ω–¥—ã –≤ —Å—Ç—Ä–æ–∫—É —Ñ–æ—Ä–º–∞—Ç–∞ \"–º–º:—Å—Å\".\n/// - Parameter seconds: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–∫—É–Ω–¥.\n/// - Returns: –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–æ –ª–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –≤–≤–æ–¥–∞ PIN-–∫–æ–¥–∞.\n/// - Parameter attempts: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫.\n/// - Returns: true, –µ—Å–ª–∏ –ª–∏–º–∏—Ç –ø—Ä–µ–≤—ã—à–µ–Ω.\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}"
      ],
      [
        "/// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å—Ç—Ä–æ–∫—É —Å—Ç–∞—Ç—É—Å–∞ –¥–æ—Å—Ç–∞–≤–∫–∏ –ø–æ —Ç–µ–∫—É—â–µ–º—É —ç—Ç–∞–ø—É.\n/// - Parameter status: –¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å.\n/// - Returns: –°—Ç—Ä–æ–∫–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ.\nfunc deliveryStatusText(for status: String) -> String {\n    switch status {\n    case \"pending\": return \"–û–∂–∏–¥–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏\"\n    case \"shipped\": return \"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ\"\n    case \"delivered\": return \"–î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ\"\n    default: return \"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ\"\n    }\n}"
      ],
      [
        "/// –£–¥–∞–ª—è–µ—Ç –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã UserDefaults –¥–ª—è —Å–±—Ä–æ—Å–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.\nfunc resetAppData() {\n    if let appDomain = Bundle.main.bundleIdentifier {\n        UserDefaults.standard.removePersistentDomain(forName: appDomain)\n    }\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Ä–∞–±–æ—Ç–∞–µ—Ç –ª–∏ —Å–µ—Ä–≤–µ—Ä API.\n/// - Parameter completion: –ó–∞–º—ã–∫–∞–Ω–∏–µ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏.\nfunc pingServer(completion: @escaping (Bool) -> Void) {\n    let url = URL(string: \"https://api.example.com/ping\")!\n    URLSession.shared.dataTask(with: url) { _, response, error in\n        let httpResponse = response as? HTTPURLResponse\n        completion(httpResponse?.statusCode == 200 && error == nil)\n    }.resume()\n}"
      ],
      [
        "/// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º—ã–π —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Parameter languageCode: –ö–æ–¥ —è–∑—ã–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, \"ru\", \"en\").\nfunc savePreferredLanguage(_ languageCode: String) {\n    UserDefaults.standard.set(languageCode, forKey: \"preferredLanguage\")\n}"
      ],
      [
        "/// –ü–æ–ª—É—á–∞–µ—Ç –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º—ã–π —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Returns: –ö–æ–¥ —è–∑—ã–∫–∞ –∏–ª–∏ \"ru\" –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"ru\"\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ —á–∏—Å–ª–æ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º, –∫–æ—Ç–æ—Ä–æ–µ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Ü–µ–ª—ã–º —á–∏—Å–ª–æ–º.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —á–∏—Å–ª–æ —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π, false ‚Äî —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –∏–ª–∏ –Ω–µ —á–∏—Å–ª–æ.\nfunc isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor(number) != number\n    }\n    return false\n}"
      ],
      [
        "/// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å—Ç—Ä–æ–∫—É, —Å–æ–¥–µ—Ä–∂–∞—â—É—é –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–π—Å—è —Å–∏–º–≤–æ–ª –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞–∑.\n/// - Parameters:\n///   - character: –°–∏–º–≤–æ–ª –¥–ª—è –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è.\n///   - count: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–º–∏—Å—è —Å–∏–º–≤–æ–ª–∞–º–∏.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ–π –≤ –º–∞—Å—Å–∏–≤–µ —Å—Ç—Ä–æ–∫.\n/// - Parameters:\n///   - text: –°—Ç—Ä–æ–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏.\n///   - array: –ú–∞—Å—Å–∏–≤ —Å—Ç—Ä–æ–∫.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è –≤ –º–∞—Å—Å–∏–≤–µ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑.\nfunc isUniqueString(_ text: String, in array: [String]) -> Bool {\n    return array.filter { $0 == text }.count == 1\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ —á–∏—Å–ª–æ —Å –∑–∞–¥–∞–Ω–Ω—ã–º –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ–º –¥–æ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ —á–∏—Å–ª–∞ –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π.\n/// - Parameters:\n///   - text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n///   - decimals: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π.\n/// - Returns: –û–∫—Ä—É–≥–ª—ë–Ω–Ω–æ–µ —á–∏—Å–ª–æ.\nfunc roundedNumber(from text: String, decimals: Int) -> Double? {\n    guard let number = Double(text) else { return nil }\n    return round(number * pow(10, Double(decimals))) / pow(10, Double(decimals))\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, —Å–æ–¥–µ—Ä–∂–∞—â—É—é –≤—Å–µ —Ü–∏—Ñ—Ä—ã –∏–∑ —Å—Ç—Ä–æ–∫–∏ –≤ –ø–æ—Ä—è–¥–∫–µ –∏—Ö –ø–æ—è–≤–ª–µ–Ω–∏—è.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞, —Å–æ–¥–µ—Ä–∂–∞—â–∞—è —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã.\nfunc extractDigitsInOrder(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}"
      ],
      [
        "/// –ü–µ—Ä–µ–≤–æ–¥–∏—Ç —Å—Ç—Ä–æ–∫—É –≤ \"–∫–æ–±–æ–ª—å–¥—Å–∫–∏–π\" —Ä–µ–≥–∏—Å—Ç—Ä (–∫–∞–∂–¥–æ–µ —Å–ª–æ–≤–æ —Å –º–∞–ª–µ–Ω—å–∫–æ–π –±—É–∫–≤—ã, –∫—Ä–æ–º–µ –ø–µ—Ä–≤–æ–≥–æ).\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ –≤ \"–∫–æ–±–æ–ª—å–¥—Å–∫–æ–º\" —Ä–µ–≥–∏—Å—Ç—Ä–µ.\nfunc toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É —Å —É–¥–∞–ª–µ–Ω–∏–µ–º –≤—Å–µ—Ö —Å–∏–º–≤–æ–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è –≤ –¥—Ä—É–≥–æ–π —Å—Ç—Ä–æ–∫–µ.\n/// - Parameters:\n///   - text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n///   - charactersToRemove: –°—Ç—Ä–æ–∫–∞ —Å —Å–∏–º–≤–æ–ª–∞–º–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ –±–µ–∑ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤.\nfunc removeCharactersFromString(_ text: String, charactersToRemove: String) -> String {\n    return text.filter { !charactersToRemove.contains($0) }\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø–æ–ª–Ω—ã–º —á–∏—Å–ª–æ–º –±–µ–∑ –¥–µ—Å—è—Ç–∏—á–Ω–æ–π —Ç–æ—á–∫–∏.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø–æ–¥—Å—Ç—Ä–æ–∫–æ–π –¥—Ä—É–≥–æ–π —Å—Ç—Ä–æ–∫–∏.\n/// - Parameters:\n///   - substring: –ü–æ–¥—Å—Ç—Ä–æ–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏.\n///   - text: –ò—Å—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ –ø–æ–¥—Å—Ç—Ä–æ–∫–∞ –Ω–∞–π–¥–µ–Ω–∞ –≤ —Å—Ç—Ä–æ–∫–µ.\nfunc containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤ —Å —É—á—ë—Ç–æ–º –∑–∞–≥–ª–∞–≤–Ω—ã—Ö –±—É–∫–≤ (–∫–∞–∂–¥–æ–µ –Ω–æ–≤–æ–µ —Å–ª–æ–≤–æ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –∑–∞–≥–ª–∞–≤–Ω–æ–π –±—É–∫–≤—ã).\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –ú–∞—Å—Å–∏–≤ —Å–ª–æ–≤ —Å —É—á—ë—Ç–æ–º –∑–∞–≥–ª–∞–≤–Ω—ã—Ö –±—É–∫–≤.\nfunc stringToCapitalizedWords(_ text: String) -> [String] {\n    return text.split(separator: \" \").map { $0.capitalized }\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ —Å—Ç—Ä–æ–∫—É —Å —á–µ—Ä–µ–¥—É—é—â–∏–º–∏—Å—è –±—É–∫–≤–∞–º–∏ –≤ –≤–µ—Ä—Ö–Ω–µ–º –∏ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ö.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —á–µ—Ä–µ–¥—É—é—â–∏–º–∏—Å—è –∑–∞–≥–ª–∞–≤–Ω—ã–º–∏ –∏ —Å—Ç—Ä–æ—á–Ω—ã–º–∏ –±—É–∫–≤–∞–º–∏.\nfunc alternatingCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, character) in\n        index % 2 == 0 ? character.lowercased() : character.uppercased()\n    })\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–Ω–¥–µ–∫—Å –ø–µ—Ä–≤–æ–≥–æ –≤—Ö–æ–∂–¥–µ–Ω–∏—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ –≤ —Å—Ç—Ä–æ–∫—É.\n/// - Parameters:\n///   - substring: –ü–æ–¥—Å—Ç—Ä–æ–∫–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞.\n///   - text: –ò—Å—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –ò–Ω–¥–µ–∫—Å –ø–µ—Ä–≤–æ–≥–æ –≤—Ö–æ–∂–¥–µ–Ω–∏—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ –∏–ª–∏ nil, –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.\nfunc indexOfSubstring(_ substring: String, in text: String) -> Int? {\n    return text.range(of: substring)?.lowerBound.utf16Offset(in: text)\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–æ–º, —É—á–∏—Ç—ã–≤–∞—è —Ç–æ–ª—å–∫–æ –∞–ª—Ñ–∞–≤–∏—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –∏ –∏–≥–Ω–æ—Ä–∏—Ä—É—è —Ä–µ–≥–∏—Å—Ç—Ä.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —è–≤–ª—è–µ—Ç—Å—è –ø–∞–ª–∏–Ω–¥—Ä–æ–º–æ–º.\nfunc isAlphaOnlyPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, —Å–æ–¥–µ—Ä–∂–∞—â—É—é —Ç–æ–ª—å–∫–æ –∑–∞–≥–ª–∞–≤–Ω—ã–µ –±—É–∫–≤—ã –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞, —Å–æ–¥–µ—Ä–∂–∞—â–∞—è —Ç–æ–ª—å–∫–æ –∑–∞–≥–ª–∞–≤–Ω—ã–µ –±—É–∫–≤—ã.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —è–≤–ª—è–µ—Ç—Å—è —á–∏—Å–ª–æ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º –≤ –¥–≤–æ–∏—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —è–≤–ª—è–µ—Ç—Å—è –¥–≤–æ–∏—á–Ω—ã–º —á–∏—Å–ª–æ–º.\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É —Å –ø–µ—Ä–≤—ã–º —Å–∏–º–≤–æ–ª–æ–º, –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–Ω—ã–º –≤ –∑–∞–≥–ª–∞–≤–Ω—É—é –±—É–∫–≤—É.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å –ø–µ—Ä–≤—ã–º —Å–∏–º–≤–æ–ª–æ–º –≤ –≤–µ—Ä—Ö–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ –º–∞—Å—Å–∏–≤, —Ä–∞–∑–±–∏–≤–∞—è –ø–æ –∫–∞–∂–¥–æ–º—É —Å–∏–º–≤–æ–ª—É.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –ú–∞—Å—Å–∏–≤ —Å–∏–º–≤–æ–ª–æ–≤.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, –∫–æ—Ç–æ—Ä–∞—è —è–≤–ª—è–µ—Ç—Å—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è —Å—Ç—Ä–æ–∫–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑.\n/// - Parameters:\n///   - text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n///   - count: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π.\n/// - Returns: –ü–æ–≤—Ç–æ—Ä—ë–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\nfunc repeatString(_ text: String, count: Int) -> String {\n    return String(repeating: text, count: count)\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ–º –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ \"HH:mm\".\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —è–≤–ª—è–µ—Ç—Å—è –≤—Ä–µ–º–µ–Ω–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç–µ \"HH:mm\".\nfunc isValidTime(_ text: String) -> Bool {\n    let pattern = \"^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$\"\n    return matchesRegex(text, pattern: pattern)\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, —Å–æ—Å—Ç–æ—è—â—É—é —Ç–æ–ª—å–∫–æ –∏–∑ —Ü–∏—Ñ—Ä –∏ —Å–∏–º–≤–æ–ª–æ–≤ —Ç–∏—Ä–µ, –µ—Å–ª–∏ –æ–Ω–∏ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç –≤ —Å—Ç—Ä–æ–∫–µ.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —Ü–∏—Ñ—Ä–∞–º–∏ –∏ —Ç–∏—Ä–µ.\nfunc extractDigitsAndDashes(from text: String) -> String {\n    return text.filter { $0.isNumber || $0 == \"-\" }\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ —Å–∏–º–≤–æ–ª—ã —Å—Ç—Ä–æ–∫–∏ –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ, –∫—Ä–æ–º–µ —á–∏—Å–µ–ª.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å –±—É–∫–≤–∞–º–∏ –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ.\nfunc lowercaseLettersWithoutNumbers(from text: String) -> String {\n    return text.filter { $0.isLetter }.lowercased()\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –≤—Å–µ –ª–∏ —Å—Ç—Ä–æ–∫–∏ –≤ –º–∞—Å—Å–∏–≤–µ –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—É—é –¥–ª–∏–Ω—É.\n/// - Parameter array: –ú–∞—Å—Å–∏–≤ —Å—Ç—Ä–æ–∫.\n/// - Returns: true, –µ—Å–ª–∏ –≤—Å–µ —Å—Ç—Ä–æ–∫–∏ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π –¥–ª–∏–Ω—ã.\nfunc allStringsHaveEqualLength(_ array: [String]) -> Bool {\n    guard let firstLength = array.first?.count else { return true }\n    return array.allSatisfy { $0.count == firstLength }\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–æ–∫, —Ä–∞–∑–¥–µ–ª—ë–Ω–Ω—ã—Ö –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–º —Å–∏–º–≤–æ–ª–æ–º.\n/// - Parameters:\n///   - text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n///   - separator: –°–∏–º–≤–æ–ª –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è.\n/// - Returns: –ú–∞—Å—Å–∏–≤ —Å—Ç—Ä–æ–∫.\nfunc splitStringByCharacter(_ text: String, separator: Character) -> [String] {\n    return text.split(separator: separator).map { String($0) }\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ —á–∏—Å–ª–æ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º –≤ —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —è–≤–ª—è–µ—Ç—Å—è —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–º —á–∏—Å–ª–æ–º.\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ –¥–∞—Ç—É —Å —É—á—ë—Ç–æ–º –≤—Ä–µ–º–µ–Ω–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ \"yyyy-MM-dd HH:mm:ss\".\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –î–∞—Ç–∞, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç—É.\nfunc stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    return formatter.date(from: text)\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ —Å—Ç—Ä–æ–∫—É —Å —É–¥–∞–ª—ë–Ω–Ω—ã–º–∏ –ø—Ä–æ–±–µ–ª–∞–º–∏, –∑–Ω–∞–∫–∞–º–∏ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è –∏ —Å–∏–º–≤–æ–ª–∞–º–∏ –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ –±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤ –∏ –∑–Ω–∞–∫–æ–≤ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è.\nfunc cleanString(_ text: String) -> String {\n    let charactersToRemove = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)\n    return text.filter { !charactersToRemove.contains($0.unicodeScalars.first!) }\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ —á–∏—Å–ª–æ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∑–∞–¥–∞–Ω–Ω–æ–π –±–∞–∑—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, 2 –¥–ª—è –¥–≤–æ–∏—á–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã).\n/// - Parameters:\n///   - text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n///   - base: –ë–∞–∑–∞ —á–∏—Å–ª–∞.\n/// - Returns: –ß–∏—Å–ª–æ –≤ –∑–∞–¥–∞–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ —Å—á–∏—Å–ª–µ–Ω–∏—è.\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ –º–∞—Å—Å–∏–≤ —Å–∏–º–≤–æ–ª–æ–≤ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤.\nfunc countUniqueCharacters(in text: String) -> Int {\n    return Set(text).count\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, —Å–æ—Å—Ç–æ—è—â—É—é –∏–∑ —Å–∏–º–≤–æ–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è –≤ —Å—Ç—Ä–æ–∫–µ –Ω–µ –±–æ–ª–µ–µ –æ–¥–Ω–æ–≥–æ —Ä–∞–∑–∞.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ —Å–∏–º–≤–æ–ª–∞–º–∏.\nfunc uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text.reduce(into: [:]) { counts, char in counts[char, default: 0] += 1 }\n    return String(text.filter { characterCount[$0] == 1 })\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ —Å—Ç—Ä–æ–∫–æ–π, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–µ–π –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π email-–∞–¥—Ä–µ—Å.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ ‚Äî –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π email.\nfunc isValidEmail(_ text: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"\n    return matchesRegex(text, pattern: emailRegex)\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, –∫–æ—Ç–æ—Ä–∞—è —è–≤–ª—è–µ—Ç—Å—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º —Å–∫–ª–µ–∏–≤–∞–Ω–∏—è –≤—Å–µ—Ö —á–∏—Å–µ–ª –∏–∑ —Å—Ç—Ä–æ–∫–∏.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞, —Å–æ–¥–µ—Ä–∂–∞—â–∞—è —Ç–æ–ª—å–∫–æ —á–∏—Å–ª–∞ –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É —Å —á–∏—Å–ª–æ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º –≤ –ø—Ä–æ—Ü–µ–Ω—Ç—ã.\n/// - Parameters:\n///   - text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n///   - precision: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å –ø—Ä–æ—Ü–µ–Ω—Ç–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º.\nfunc stringToPercentage(_ text: String, precision: Int) -> String? {\n    guard let number = Double(text) else { return nil }\n    let percentage = number * 100\n    return String(format: \"%.\\(precision)f%%\", percentage)\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, –≥–¥–µ —Å–∏–º–≤–æ–ª—ã —á–µ—Ä–µ–¥—É—é—Ç—Å—è –º–µ–∂–¥—É –≤–µ—Ä—Ö–Ω–∏–º –∏ –Ω–∏–∂–Ω–∏–º —Ä–µ–≥–∏—Å—Ç—Ä–æ–º.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —á–µ—Ä–µ–¥—É—é—â–∏–º–∏—Å—è –±—É–∫–≤–∞–º–∏.\nfunc alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ —á–∏—Å–ª–æ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º, –≤–∫–ª—é—á–∞—è –¥–µ—Å—è—Ç–∏—á–Ω—É—é —Ç–æ—á–∫—É.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —è–≤–ª—è–µ—Ç—Å—è —á–∏—Å–ª–æ–º.\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–ª–µ–º–µ–Ω—Ç—ã –º–∞—Å—Å–∏–≤–∞ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ.\n/// - Parameter array: –ú–∞—Å—Å–∏–≤.\n/// - Returns: –ú–∞—Å—Å–∏–≤ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ.\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}"
      ],
      [
        "/// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ —Å–ª–æ–≤–∞—Ä—è –ø–æ –µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è–º.\n/// - Parameter dictionary: –°–ª–æ–≤–∞—Ä—å.\n/// - Returns: –°–ª—É—á–∞–π–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç —Å–ª–æ–≤–∞—Ä—è.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–ª—é—á–∏ –∏–∑ —Å–ª–æ–≤–∞—Ä—è, –∫–æ—Ç–æ—Ä—ã–µ —Å–≤—è–∑–∞–Ω—ã —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏.\n/// - Parameter dictionary: –°–ª–æ–≤–∞—Ä—å.\n/// - Returns: –ö–ª—é—á–∏ —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏.\nfunc keysWithMinValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable, Value: Comparable {\n    guard let minValue = dictionary.values.min() else { return [] }\n    return dictionary.filter { $0.value == minValue }.map { $0.key }\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–µ—Ä–µ–¥–∞–Ω–Ω–∞—è –¥–∞—Ç–∞ –≤ –±—É–¥—É—â–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ç–µ–∫—É—â–µ–π.\n/// - Parameter date: –î–∞—Ç–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏.\n/// - Returns: `true`, –µ—Å–ª–∏ –¥–∞—Ç–∞ –≤ –±—É–¥—É—â–µ–º.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ –º–∞—Å—Å–∏–≤ —Å–∏–º–≤–æ–ª–æ–≤, —Ñ–∏–ª—å—Ç—Ä—É—è —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã.\n/// - Parameter str: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –ú–∞—Å—Å–∏–≤ —Å–∏–º–≤–æ–ª–æ–≤, —Å–æ–¥–µ—Ä–∂–∞—â–∏—Ö —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã.\nfunc stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}"
      ],
      [
        "/// –ù–∞—Ö–æ–¥–∏—Ç —Ä–∞–∑–Ω–∏—Ü—É –º–µ–∂–¥—É –¥–≤—É–º—è –¥–∞—Ç–∞–º–∏ –≤ –¥–Ω—è—Ö.\n/// - Parameters:\n///   - startDate: –ù–∞—á–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞.\n///   - endDate: –ö–æ–Ω–µ—á–Ω–∞—è –¥–∞—Ç–∞.\n/// - Returns: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –º–µ–∂–¥—É –¥–∞—Ç–∞–º–∏.\nfunc daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ –º–∞—Å—Å–∏–≤ —á–∏—Å–µ–ª, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö –ø—Ä–æ–±–µ–ª–∞–º–∏, –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—É–º–º—É.\n/// - Parameter str: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—É–º–º–∞ —á–∏—Å–µ–ª –≤ —Å—Ç—Ä–æ–∫–µ.\nfunc sumOfNumbersInString(_ str: String) -> Int {\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.reduce(0, +)\n}"
      ]
    ]
  }
}