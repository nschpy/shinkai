{
  "title": "HuggingFaceTB/SmolLM2-1.7B",
  "description": "Эксперимент с инференсом модели HuggingFaceTB/SmolLM2-1.7B и оценкой BLEU/ROUGE.",
  "metrics": {
    "BLEU": 0.2247464899181763,
    "ROUGE-L": 0.30425497935595347,
    "PREDICTIONS": [
      "func isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}\n\n## Documentation:\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    return !token.isEmpty\n}\n## Documentation:\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    return !token.isEmpty\n}\n## Documentation:\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    return !token.isEmpty\n}\n## Documentation:\nfunc isUserLoggedIn() -> Bool {",
      "/// Returns a greeting message based on the time of day.\n///\n/// - Parameter name: The name of the person being greeted.\n/// - Returns: A greeting message based on the time of day.\n/// - Precondition: `name` is a valid string.\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро, \\(name)\"\n    case 12..<18: return \"Добрый день, \\(name)\"\n    case 18..<23: return \"Добрый вечер, \\(name)\"\n    default: return \"Доброй ночи, \\(name)\"\n    }\n}\n\n### Review:\n\nThe Swift language supports documentation comments. The documentation for a function or a method can be written in /// style.\n\nA function with documentation comments is documented in the source file, and it can be read by",
      "/// Returns the formatted amount in the format of `₽`.\n/// - Parameter amount: The amount to format.\n/// - Returns: The formatted amount.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"₽\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ₽\"\n}\n\nFunction:\n\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"₽\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ₽\"\n}\n\nFunction:\n\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"₽",
      "/// Send a push notification with the given body to all devices.\n/// - Parameter message: The body of the notification.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}\n\n## Swift Playgrounds\n\nSwift Playgrounds are interactive playgrounds for learning Swift.\n\nCreate a new playground:\n\n- In the project navigator, right-click on the project folder and select New > Playground\n- Name the playground\n- Add code to the playground\n- Run the playground\n\n## Swift Package Manager\n\nSwift Package Manager is a tool for building and managing Swift packages.\n\nCreate a new Swift Package Manager:\n\n- In the project navigator, right-click on the project folder and select New > Package > Swift Package Manager\n- Name the package\n- Add a new module\n- Add a new target\n",
      "/// Displays a view containing an introductory screen explaining the product.\n///\n/// - Parameter user: A user object containing the user's information.\n/// - Returns: A boolean indicating whether or not the onboarding screen should be shown.\n/// - Throws: `NSError`\n/// - SeeAlso: `UserDefaults.standard.bool(forKey: \"onboardingShown\")`\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\nFunction:\n\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n## Documentation:\n/// Displays a view containing an introductory screen explaining the product.\n///\n/// - Parameter user: A user object containing the user's information.\n/// - Returns: A boolean indicating whether or not the onboarding screen should be shown.\n/// - Throws: `NSError`\n/// - SeeAlso: `UserDefaults.standard.bool(forKey: \"onboardingShown\")`",
      "///-saveLastViewedProduct: Saves the product id to the last viewed product key in UserDefaults.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}\n\n### Parameters:\n\n- productId: The product ID to save.\n\n### Returns:\n\nThe product ID saved to the last viewed product key in UserDefaults.\n\n### Precondition:\n\nThe given product id is not nil.\n\n### Throws:\n\n- ParameterError: if the given product id is nil.\n\n### Description:\n\nThis function saves the product id to the last viewed product key in UserDefaults.\n\nThe function saves the product id to the last viewed product key in UserDefaults.\n\nThe function saves the product id to the last viewed product key in UserDefaults.\n\nThe function saves the product id to the last viewed product key in UserDefaults.\n\nThe function saves the product id to the last viewed product key in UserDefaults.\n\nThe function saves the product id to the last viewed product key in UserDefault",
      "func shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\nFunction:\n\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n## Documentation:\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\nFunction:\n\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ??",
      "func coordinatesToString(lat: Double, lon: Double) -> String {\n    /// Converts coordinates to a string.\n    ///\n    /// - Parameter lat: The latitude in degrees.\n    /// - Parameter lon: The longitude in degrees.\n    /// - Returns: A string representation of the coordinates.\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}\n\nFunction:\n\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}\n## Documentation:\n\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    /// Converts coordinates to a string.\n    ///\n    /// - Parameter lat: The latitude in degrees.\n    /// - Parameter lon: The longitude in degrees.\n    /// - Returns: A string representation of the coordinates.\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}\n\nFunction:\n\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n   ",
      "/// Determines if a given user profile is complete.\n///\n/// - Parameters:\n///   - profile: The user profile.\n/// - Returns: `true` if the profile is complete, `false` otherwise.\n\nThe function determines if a given user profile is complete.\n\n- Parameters:\n    - profile: The user profile.\n- Returns: `true` if the profile is complete, `false` otherwise.\n\n## Notes:\nThis function determines if a given user profile is complete.\n\n- Parameters:\n    - profile: The user profile.\n- Returns: `true` if the profile is complete, `false` otherwise.\n\n## Notes:\nThis function determines if a given user profile is complete.\n\n- Parameters:\n    - profile: The user profile.\n- Returns: `true` if the profile is complete, `false` otherwise.\n\n## Notes:\nThis function determines if a given user profile is complete.\n\n- Parameters:\n    - profile: The user profile.\n- Returns: `true` if the profile is complete, `false` otherwise.\n\n## Notes:\nThis function determines if a given user profile is complete",
      "func isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\n## Example:\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\n## Tests:\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\n## Notes:\n/// Returns true if the phone number provided is valid.\n/// - Parameter phone: Phone number to validate.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\n## Description:",
      "func starsForRating(_ rating: Double) -> String {\n    /// Given a rating, returns a string of stars.\n    ///\n    /// - Parameter rating: The rating to return stars for.\n    /// - Returns: A string of stars.\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}\n\nFunction:\n\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}\n## Documentation:\nfunc starsForRating(_ rating: Double) -> String {\n    /// Given a rating, returns a string of stars.\n    ///\n    /// - Parameter rating: The rating to return stars for.\n    /// - Returns: A string of stars.\n    let",
      "/// Returns true if the current device has an active internet connection\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n## Возможно, вы можете проверить, что все эти документации выглядят похожими.\n\n## Подсказки\n\n- Документация об управлении данными\n- Документация об общей схеме работы\n- Документация об использовании пользовательского интерфейса\n\n## Документация о типах\n- Документация о типах данных\n- Д",
      "deliveryStatus(for: deliveryDate:)\n    Returns the delivery status for the given delivery date.\n\n    - Parameter deliveryDate: The delivery date.\n    - Returns: The delivery status.\n\n## Notes:\nDelivery status can be \"Сегодня\", \"Завтра\" or \"Позже\".\n\n## Example:\ndeliveryStatus(for: deliveryDate:)\n    deliveryDate: 2021-05-01\n\ndeliveryStatus(for: deliveryDate:)\n    deliveryDate: 2021-05-02\n\ndeliveryStatus(for: deliveryDate:)\n    deliveryDate: 2021-05-03\n\ndeliveryStatus(for: deliveryDate:)\n    deliveryDate: 2021-05-04\n\ndeliveryStatus(for: deliveryDate:)\n    deliveryDate: 2021-05-05\n\ndeliveryStatus(for: deliveryDate:)\n    deliveryDate: 2021-05-06\n\ndeliveryStatus(for: deliveryDate:)\n    deliveryDate: 2021-0",
      "///\n/// Returns the list of hashtags for the given set of tags.\n///\n/// - Parameter tags: The set of tags to convert to hashtags.\n/// - Returns: A string representing the list of hashtags.\n///\n/// - Complexity: O(n).\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}\n\nFunction:\n\nfunc sort(by keyPath: KeyPath<Person, String>) -> (Person, Person) -> Bool {\n    return { (p1: Person, p2: Person) -> Bool in\n        return p1[keyPath: keyPath] < p2[keyPath: keyPath]\n    }\n}\n## Documentation:\n///\n/// Sorts a collection of people by the given key path.\n///\n/// - Parameter keyPath: The key path to sort by.\n/// - Returns: A function that sorts by the given key path.\n///\n/// - Complexity: O(n log n).\nfunc sort(",
      "Save the current scroll offset to the `productListScrollOffset` key in UserDefaults.\n\nFunction:\n\nfunc getProductListScrollOffset() -> Double {\n    return UserDefaults.standard.double(forKey: \"productListScrollOffset\")\n}\n## Documentation:\nGet the current scroll offset from UserDefaults.\n\nFunction:\n\nfunc addProductToList(_ product: Product) {\n    let index = productList.index(of: product)\n    if index != nil {\n        productList[index!] = product\n    } else {\n        productList.append(product)\n    }\n}\n## Documentation:\nAdd a product to the product list.\n\nFunction:\n\nfunc removeProductFromList(_ product: Product) {\n    if let index = productList.index(of: product) {\n        productList.remove(at: index)\n    }\n}\n## Documentation:\nRemove a product from the product list.\n\nFunction:\n\nfunc updateProductList() {\n    let productList = getProductList()\n    let productListData = ProductListData(products: productList)\n    userDefaults.set(productListData, for",
      "/// Используется для проверки страницы на возможность доставки.\n///\n/// - Parameters:\n///   - lat: Широта страницы.\n///   - lon: Долгота страницы.\n/// - Returns: Возвращает `true` если проверка пройдена успешно.\n\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // Москва\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}\n\n## Function:\n\nfunc isWithinDeliveryZone(lat: Double",
      "///Generates a product deeplink URL.\n///\n/// - Parameter productId: The product ID.\n/// - Returns: A deeplink URL, or nil if the product could not be found.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\nFunction:\n\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n## Documentation:\n///Generates a product deeplink URL.\n///\n/// - Parameter productId: The product ID.\n/// - Returns: A deeplink URL, or nil if the product could not be found.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\nFunction:\n\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(",
      "/// Returns whether the given message ID is a new message.\n///\n/// - Parameters:\n///   - lastViewedId: The ID of the last message viewed.\n///   - newMessageId: The ID of the new message.\n/// - Returns: Whether the given message ID is a new message.\nfunc hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}\n\nYou are documenting a Swift codebase. Given a function and a short description of where and how it is used, write a documentation comment that helps future developers understand its purpose.\nUse ///-style Swift comments.\nInclude parameter and return descriptions, and emphasize intent over implementation.\nReturn only the comment and the function.\n\nFunction:\n\nfunc addMessage(message: Message) {\n    messages.append(message)\n}\n## Documentation:\n\n/// Adds a message to the list of messages.\nfunc addMessage(message: Message) {\n    messages.append(message)\n}\n\nYou are documenting a Swift codebase. Given a function and a short description of",
      "/// Returns the percentage of progress from `current` to `target`.\n///\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of progress, or 0 if `target` is 0.\n\n## Documentation:\n/// Returns the percentage of progress from `current` to `target`.\n///\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of progress, or 0 if `target` is 0.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}\n\nFunction:\n\nfunc add(_ a: Int, _ b: Int) -> Int {\n    return a + b\n}\n## Documentation:\n/// Returns the sum of `a` and `b`.\n///\n/// - Parameters:\n///   - a:",
      "/// Checks if a user is logged in.\n///\n/// - Returns: true if a user is logged in, false otherwise.\n/// - Returns: true if a user is logged in, false otherwise.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}\n\nFunction:\n\nfunc someFunction(input: Int) -> Int {\n    // Здесь могла бы быть логика вычисления результата\n    return 1\n}\n## Documentation:\n/// Calculates a result.\n///\n/// - Parameter input: The input parameter.\n/// - Returns: The result of the calculation.\nfunc someFunction(input: Int) -> Int {\n    // Зде",
      "func generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро, \\(name)\"\n    case 12..<18: return \"Добрый день, \\(name)\"\n    case 18..<23: return \"Добрый вечер, \\(name)\"\n    default: return \"Доброй ночи, \\(name)\"\n    }\n}\n\n## Review\n\nUse ///-style Swift comments.\nInclude parameter and return descriptions, and emphasize intent over implementation.\nReturn only the comment and the function.\n\nFunction:\n\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро, \\(name)\"\n    case 12..",
      "/// Formats the given amount in the currency of the current locale.\n///\n/// - Parameter amount: The amount to format.\n/// - Returns: The formatted amount.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"₽\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ₽\"\n}\n\n### Note:\n\nIt is possible to use a single line to document a function and a single line to document a method, but the formatCurrency() function is a bit more complex and should be documented separately.\n\n### Note:\n\nIf you are documenting a function, you can use a single line to document a method, but if you are documenting a method, you can use a single line to document a function.\n\n### Note:\n\nIf you are documenting a function, you can use a single line to document a method, but if you are documenting a method, you can use a single line to",
      "/// Send a local push notification.\n///\n/// - parameter message: The message to be sent.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}\n\n## Example:\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}\n\n## Notes:\nYou are documenting a Swift codebase. Given a function and a short description of where and how it is used, write a documentation comment that helps future developers understand its purpose.\nUse ///-style Swift",
      "func shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n## Example:\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n## Summary:\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n## Parameters:\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n## Returns:\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n## Throws:\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n## Type:\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboarding",
      "/// Saves the last product that was viewed in the app.\n///\n/// - Parameter productId: The ID of the product that was viewed.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}\n\n/// Saves the last product that was viewed in the app.\n///\n/// - Parameter productId: The ID of the product that was viewed.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}\n\n/// Saves the last product that was viewed in the app.\n///\n/// - Parameter productId: The ID of the product that was viewed.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}\n\n/// Saves the last product that was viewed in the app.\n///\n/// - Parameter productId: The ID of the product that was viewed.\nfunc save",
      "func shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\n## Markdown:\n\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\n## Code:\n\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\n## Code:\n\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown",
      "/// Returns the coordinates as a string.\n///\n/// - Parameters:\n///   - lat: The latitude.\n///   - lon: The longitude.\n/// - Returns: The coordinates as a string.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}\n\n## Code:\n\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}\n## Test:\n\nfunc testCoordinatesToString() {\n    let result = coordinatesToString(lat: 52.1234, lon: 34.2342)\n    XCTAssertEqual(result, \"📍 52.1234, 34.2342\")\n}\n",
      "/// Determines if the user's profile is complete.\n///\n/// - Parameters:\n///   - profile: A dictionary containing user profile data.\n///   - requiredKeys: The keys of the profile that are required to be present.\n/// - Returns: True if all required keys are present, false otherwise.\n\n/// Determines if the user's profile is complete.\n///\n/// - Parameters:\n///   - profile: A dictionary containing user profile data.\n///   - requiredKeys: The keys of the profile that are required to be present.\n/// - Returns: True if all required keys are present, false otherwise.\n\n/// Determines if the user's profile is complete.\n///\n/// - Parameters:\n///   - profile: A dictionary containing user profile data.\n///   - requiredKeys: The keys of the profile that are required to be present.\n/// - Returns: True if all required keys are present, false otherwise.\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return",
      "func isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    /// Checks if a phone number is valid in Russia.\n    ///\n    /// - Parameter phone: A phone number.\n    /// - Returns: `true` if the phone number is valid, `false` otherwise.\n    /// - Complexity: O(n) time, where n is the length of the `phone` string.\n}\n\n## Notes:\n\nThe function checks if a phone number is valid in Russia.\n\n### Parameters\n\n`phone`: A phone number.\n\n### Returns\n\n`true` if the phone number is valid, `false` otherwise.\n\n### Complexity\n\nO(n) time, where n is the length of the `phone` string.\n\n## Example:\n\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\nisValidRussianPhoneNumber(\"+71234567890\")\n// true\n\nisValidRussianPhone",
      "/// Returns a string of filled stars for the given rating.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}\n\n## Swift Docs:\n/// Returns a string of filled stars for the given rating.\n///\n/// - Parameter rating: A rating between 0 and 10.\n/// - Returns: A string of filled stars for the given rating.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}\n\n## Swift Playgrounds:\n/// Returns a string of filled stars for the given rating.\n///\n/// - Parameter rating: A rating between 0",
      "/// Is the device connected to the internet?\n///\n/// - Returns: `true` if the device is connected to the internet, otherwise `false`\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n\nFunction:\n\nfunc add(a: Int, b: Int) -> Int {\n    // Упрощённо, для примера — реальная реализация требует Swift Operator +\n    return a + b\n}\n## Documentation:\n\n/// Adds two numbers\n///\n/// - Parameters:\n///   - a: The first number\n///   - b: The second number\n/// - Returns: The sum of a and b\nfunc add(a: Int, b: Int) -> Int {\n    return a + b\n}\n\nFunction:\n\nfunc getTasks(forUser user: User) -> [Task] {\n    // Упрощённо, для примера — реальная реализа",
      "/// Комментарий к функции для определения статуса доставки\n///\n/// - Parameter deliveryDate: Дата доставки\n/// - Returns: Признак статуса доставки\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"Сегодня\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"Завтра\"\n    } else {\n        return \"Позже\"\n    }\n}\n\n---\n\n## Документация на язык Swift\n\nНапишите документацию на язык Swift для функции, которая определяет",
      "func hashtags(from tags: [String]) -> String {\n    /// Returns the hashtags for a given list of tags.\n    ///\n    /// - Parameter tags: A list of tags to generate hashtags for.\n    /// - Returns: A list of hashtags in the form of `#tag`.\n    /// - Complexity: O(n) time, where n is the number of tags in the list.\n}\n\nFunction:\n\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}\n## Documentation:\nfunc hashtags(from tags: [String]) -> String {\n    /// Returns the hashtags for a given list of tags.\n    ///\n    /// - Parameter tags: A list of tags to generate hashtags for.\n    /// - Returns: A list of hashtags in the form of `#tag`.\n    /// - Complexity: O(n) time, where n is the number of tags in the list.\n}\n\nFunction:\n\nfunc hashtags(from tags: [String]) -> String {\n    return tags",
      "/**\n Saves the scroll offset for the current list view.\n \n - Parameters:\n    - offset: The scroll offset.\n */\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}\n\nFunction:\n\nfunc updateProductListView(_ productList: ProductList) {\n    self.productListView.products = productList.products\n    self.productListView.updateProductList()\n}\n## Documentation:\n\n/**\n Updates the current product list view with the given product list.\n \n - Parameter productList: The product list to use.\n */\nfunc updateProductListView(_ productList: ProductList) {\n    self.productListView.products = productList.products\n    self.productListView.updateProductList()\n}\n\nFunction:\n\nfunc updateProductListView(_ productList: ProductList) {\n    self.productListView.products = productList.products\n    self.productListView.updateProductList()\n}\n## Documentation:\n\n/**\n Updates the current product list view with the given product list.\n \n",
      "/// Calculates whether a point is within a delivery zone.\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // Москва\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}\n\nFunction:\n\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // Москва\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}\n## Documentation:\n/// Calculates whether a point is within a delivery zone.\n///\n/// - Parameters:\n///   -",
      "/// Generate a deep link to a product.\n///\n/// - Parameter productId: The product ID.\n/// - Returns: A URL to the product.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\nFunction:\n\nfunc setUser(user: User) {\n    user.name = \"Dave\"\n    user.email = \"<EMAIL>\"\n}\n## Documentation:\n/// Set the user's name and email.\n///\n/// - Parameter user: The user to set.\nfunc setUser(user: User) {\n    user.name = \"Dave\"\n    user.email = \"<EMAIL>\"\n}\n\nFunction:\n\nfunc updateUser(user: User) {\n    user.name = \"Dave\"\n    user.email = \"<EMAIL>\"\n}\n## Documentation:\n/// Update the user's name and email.\n///\n/// - Parameter user: The user to update.\nfunc updateUser(user: User) {\n    user.name = \"Dave\"\n    user.email = \"<EMAIL",
      "/// Has the last viewed ID changed since the new message was posted?\n///\n/// - Parameters:\n///   - lastViewedId: The last viewed ID.\n///   - newMessageId: The new message ID.\n/// - Returns: `true` if the last viewed ID has changed, `false` otherwise.\n/// - Complexity: O(1)\nfunc hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}\n\nFunction:\n\nfunc createNewSupportMessage(for user: User, with message: String) -> SupportMessage {\n    return SupportMessage(user, message)\n}\n## Documentation:\n\n/// Creates a new support message.\n///\n/// - Parameters:\n///   - user: The user that sent the message.\n///   - message: The message to post.\n/// - Returns: A new support message.\n/// - Complexity: O(1)\nfunc createNewSupportMessage(for user: User, with message: String) -> SupportMessage {\n    return SupportMessage(user",
      "/// Returns the percentage of progress towards a target.\n///\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of progress towards the target.\n///\n/// - Note: If `current` is greater than or equal to `target`, the return value is 100.\n\n## Rules:\n- Only add documentation comments if you are not already doing so.\n- Include a comment for every function, method, and property.\n- If you're documenting a method, include the method's return type and parameter types.\n- Include an example or two.\n- Include the documentation for the Swift standard library.\n- If a function is not used in Swift code, don't document it.\n\n## Examples:\n/// Returns the percentage of progress towards a target.\n///\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of progress towards the target.\n///\n/// - Note: If `current` is greater than or equal to",
      "func termsAndConditionsURL() -> URL? {\n    let locale = Locale.current.languageCode ?? \"en\"\n    return URL(string: \"https://example.com/terms_\\(locale).html\")\n}\n\nFunction:\n\nfunc makePizza(withSize size: Size) -> Pizza {\n    return Pizza(size: size)\n}\n## Documentation:\nfunc makePizza(withSize size: Size) -> Pizza {\n    return Pizza(size: size)\n}\n\nFunction:\n\nfunc makePizza(withSize size: Size) -> Pizza {\n    return Pizza(size: size)\n}\n## Documentation:\nfunc makePizza(withSize size: Size) -> Pizza {\n    return Pizza(size: size)\n}\n\nFunction:\n\nfunc makePizza(withSize size: Size) -> Pizza {\n    return Pizza(size: size)\n}\n## Documentation:\nfunc makePizza(withSize size: Size) -> Pizza {\n    return Pizza(size: size)\n}\n\nFunction:\n\nfunc makePizza(withSize size: Size) ->",
      "/// Returns whether an event is started at the given date.\n///\n/// - Parameter date: The date to check.\n/// - Returns: Whether the event is started at the given date.\n///\n/// - Example:\n///\n///     let event = Event(name: \"My event\")\n///     if isEventStarted(at: event.startDate) {\n///         print(\"The event has already started.\")\n///     }\n\nThe swift format is not that great for comments, but at least it's not worse than the one I used to use. The point here is to keep the comments as short as possible, so that they don't get in the way of the code.\n\nThe documentation is a little longer, but it's not too long.\n\n## Comments\n\n- Documentation is written for the benefit of future developers.\n- It's important to document functions, but not so important to document everything.\n- Write comments for the code, not the code for the comments.\n- Keep the comments short, but include enough information to make them useful.\n- Document the intention of the code, not the implementation.\n-",
      "/// Saves the current theme to UserDefaults.\n///\n/// - Parameter theme: The theme to save.\nfunc saveUserTheme(_ theme: String) {\n    UserDefaults.standard.set(theme, forKey: \"appTheme\")\n}\n\nThe above code is a function that saves the current theme to UserDefaults.\n\n#### Description\n\nThis function saves the current theme to UserDefaults.\n\n#### Parameters\n\n- `theme`: The theme to save.\n\n#### Returns\n\nThe theme that was saved.\n\n#### Throws\n\n- `Error` if there was an error saving the theme.\n\n#### Notes\n\nThe function takes a string argument and saves it to UserDefaults with the key \"appTheme\".\n\n### 3. Write a comment that describes the purpose of a Swift codebase.\n\nUse ///-style Swift comments.\nInclude parameter and return descriptions, and emphasize intent over implementation.\nReturn only the comment and the file.\n\nFile:\n\n/// This is a comment for the file.\n\n#### Description\n\nThis file has a comment describing its purpose.\n\n#### Parameters",
      "/// Get the currently active theme of the app.\n///\n/// Returns the currently active theme of the app.\n///\n/// - Returns: The theme of the app.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}\n\n/// Get the currently active theme of the app.\n///\n/// Returns the currently active theme of the app.\n///\n/// - Returns: The theme of the app.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}\n\n/// Get the currently active theme of the app.\n///\n/// Returns the currently active theme of the app.\n///\n/// - Returns: The theme of the app.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}\n\n/// Get the currently active theme of the app.\n///\n/// Returns the currently active theme of the app.\n///\n/// - Returns",
      "func clearUserSession() {\n    // Remove all stored user information.\n    let keys = [\"authToken\", \"userProfile\", \"lastViewedProduct\"]\n    keys.forEach { UserDefaults.standard.removeObject(forKey: $0) }\n}\n\n## Explanation:\n\nThis function clears the user's session, removing all stored user information. This includes the user's authentication token, user profile, and last viewed product.\n\n## Related Topics:\n\n- [Functions](https://developer.apple.com/documentation/swift/functions)\n- [Swift comments](https://developer.apple.com/documentation/swift/swift_comments)\n- [UserDefaults](https://developer.apple.com/documentation/foundation/userdefaults)\n\n## Challenge\n\nWrite a Swift codebase that includes a function that takes a string and returns a new string with all vowels replaced with the letter `x`.\n\nUse ///-style Swift comments.\n\nInclude parameter and return descriptions, and emphasize intent over implementation.\n\nReturn only the comment and the function.\n\nFunction:\n\nfunc swapVowels(string",
      "/// Возвращает формулу отзыва для устройства. Устройство: \\(model)\\nВерсия iOS: \\(systemVersion)\\nВаш отзыв:\nfunc generateFeedbackTemplate() -> String {\n    let systemVersion = UIDevice.current.systemVersion\n    let model = UIDevice.current.model\n    return \"Устройство: \\(model)\\nВерсия iOS: \\(systemVersion)\\nВаш отзыв: \"\n}\n\n\n## Function:\n\nfunc calculateSum(firstNumber: Int, secondNumber: Int) -> Int {\n    return firstNumber + secondNumber\n}\n## Documentation:\n/// Возвращает сумму двух чисел.\nfunc calculateSum(firstNumber: Int, secondNumber: Int) -> Int {\n    return firstNumber + secondNumber\n}\n\n## Function:\n\nfunc calculateSum(firstNumber: Int, second",
      "/// Checks if a count is greater than or equal to 5.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n\nFunction:\n\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n## Documentation:\n/// Checks if a count is greater than or equal to 5.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n\nFunction:\n\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n## Documentation:\n/// Checks if a count is greater than or equal to 5.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n\nFunction:\n\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n## Documentation:\n/// Checks",
      "/// Returns a formatted order date.\n///\n/// - Parameter date: A date to format.\n/// - Returns: The formatted date.\nfunc formatOrderDate(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd MMM yyyy\"\n    return formatter.string(from: date)\n}\n\n### Notes\n\nThis function formats a date in a string. The date is passed as the only parameter. The function returns the formatted date.\n\n### Example\n\nformatOrderDate(Date())\n\n### Example Output\n\n\"03 Jun 2018\"\n\n## SwiftDoc\n\nSwiftDoc is a simple tool for creating Swift documentation from Markdown files.\n\n## Usage\n\n### Install\n\nSwiftDoc is available on the command line, and can be installed using `brew install swiftdoc`.\n\n### Usage\n\nSwiftDoc will generate documentation for your Swift codebase in the current directory. It will create a `swiftdoc` subdirectory with a `README.md` file.\n\nTo run SwiftDoc, simply type `swiftdoc`.\n\n##",
      "/// Calculates the number of days between two dates.\n///\n/// - Parameters:\n///   - from: The start date.\n///   - to: The end date.\n/// - Returns: The number of days between the two dates.\n/// - Precondition: The two dates must be valid dates.\n/// - Precondition: The two dates must be in the same calendar system.\n\n/// Calculates the number of days between two dates.\n///\n/// - Parameters:\n///   - from: The start date.\n///   - to: The end date.\n/// - Returns: The number of days between the two dates.\n/// - Precondition: The two dates must be valid dates.\n/// - Precondition: The two dates must be in the same calendar system.\n\nfunc daysBetween(_ from: Date, _ to: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: from, to: to).day ?? 0\n}\n\n/// Calculates the number of days between two dates.\n///\n/// - Parameters:\n///",
      "/// Saves the current banner id in the user defaults\nfunc saveLastSeenBannerId(_ id: String) {\n    UserDefaults.standard.set(id, forKey: \"lastSeenBannerId\")\n}\n\n## Challenge\n\nWrite a documentation comment for the following function:\n\nfunc test() {\n    print(\"Hello, World!\")\n}\n/// Tests whether the given value is less than or equal to zero\nfunc test(_ value: Int) -> Bool {\n    return value <= 0\n}\n\n## Solution\n\nfunc test(_ value: Int) -> Bool {\n    return value <= 0\n}\n/// Tests whether the given value is less than or equal to zero\nfunc test(_ value: Int) -> Bool {\n    return value <= 0\n}\n\n## Challenge\n\nWrite a documentation comment for the following function:\n\nfunc test() {\n    print(\"Hello, World!\")\n}\n/// Tests whether the given value is less than or equal to zero\nfunc test(_ value: Int) -> Bool {\n    return value <= 0\n}\n\n## Solution\n\nfunc test(_ value: Int) ->",
      "func shouldRefreshCache(since lastUpdate: Date) -> Bool {\n    return Date().timeIntervalSince(lastUpdate) > 6 * 3600\n}\n\n# Use SwiftDoc to create a documentation site for your Swift codebase.\n\n## How to create a documentation site:\n\n1. Install SwiftDoc.\n2. Create a new SwiftDoc project.\n3. Add your Swift codebase to SwiftDoc.\n4. Generate documentation.\n5. Publish documentation.\n\n## How to contribute to SwiftDoc:\n\n1. Add SwiftDoc to your Swift codebase.\n2. Add your Swift codebase to SwiftDoc.\n3. Generate documentation.\n4. Publish documentation.\n\n# How to use SwiftDoc:\n\n## Installation:\n\nSwiftDoc can be installed via the Homebrew package manager.\n\n```\nbrew install swiftdoc\n```\n\n## Create a new project:\n\nCreate a new SwiftDoc project by running the following command:\n\n```\nswiftdoc new\n```\n\n## Add your Swift codebase:\n\nAdd your Swift codebase to SwiftDoc by running the following command:\n\n```\nsw",
      "func isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}\n\nFunction:\n\nfunc showAlert(withTitle title: String, andMessage message: String) {\n    // Здесь могла бы быть логика отображения окна с заголовком и сообщением\n}\n## Documentation:\nfunc showAlert(withTitle title: String, andMessage message: String) {\n    // Здесь могла бы быть логика отображения окна с заголовком и сообщением\n}\n\nFunction:\n\nfunc showAlert(withTitle title: String, andMessage",
      "///\n/// Returns `true` if the given registration date is less than 7 days old.\n///\n/// - Parameter registrationDate: The registration date.\n/// - Returns: `true` if the given registration date is less than 7 days old.\nfunc isNewUser(registrationDate: Date) -> Bool {\n    return Date().timeIntervalSince(registrationDate) < 7 * 86400\n}\n\nFunction:\n\nfunc isNewUser(registrationDate: Date) -> Bool {\n    return Date().timeIntervalSince(registrationDate) < 7 * 86400\n}\n## Documentation:\n///\n/// Returns `true` if the given registration date is less than 7 days old.\n///\n/// - Parameter registrationDate: The registration date.\n/// - Returns: `true` if the given registration date is less than 7 days old.\nfunc isNewUser(registrationDate: Date) -> Bool {\n    return Date().timeIntervalSince(registrationDate) < 7 * 86400\n}\n\nFunction:\n\nfunc isNewUser(registrationDate:",
      "/// Returns the number of times the app has been launched.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\nFunction:\n\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n## Documentation:\n/// Returns the number of times the app has been launched.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\nFunction:\n\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n## Documentation:\n/// Returns the number of times the app has been launched.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\nFunction:\n\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n## Documentation:\n/// Returns the number of times",
      "/// Increments the count of app launches.\n///\n/// - Returns: The incremented count.\nfunc incrementAppLaunchCount() {\n    let count = getAppLaunchCount() + 1\n    UserDefaults.standard.set(count, forKey: \"launchCount\")\n}\n\nFunction:\n\nfunc calculate(a: Int, b: Int) -> Int {\n    return a + b\n}\n## Documentation:\n/// Adds two numbers together.\n///\n/// - Parameters:\n///   - a: The first number to add.\n///   - b: The second number to add.\n/// - Returns: The sum of `a` and `b`.\nfunc calculate(a: Int, b: Int) -> Int {\n    return a + b\n}\n\nFunction:\n\nfunc calculate(a: Int, b: Int) -> Int {\n    return a + b\n}\n/// Adds two numbers together.\n///\n/// - Parameters:\n///   - a: The first number to add.\n///   - b: The second number to add.\n/// - Returns:",
      "/// Returns whether Face ID is available.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}\n## Result:\n\n/// Returns whether Face ID is available.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}\n\nFunction:\n\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}\n## Documentation:\n\n/// Returns whether Face ID is available.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?",
      "/// Returns the month name from the given month number.\n///\n/// - Parameter month: Month number.\n/// - Returns: Month name.\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.monthSymbols[safe: month - 1] ?? \"\"\n}\n\n## Inline Documentation:\n\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.monthSymbols[safe: month - 1] ?? \"\"\n}\n\n## Multiple line Documentation:\n\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.monthSymbols[safe: month - 1] ?? \"\"\n}\n\n## Documentation with `@objc`\n\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()",
      "/// Returns an URL to the orders of a user.\n///\n/// - Parameter userId: The user ID.\n/// - Returns: An URL to the orders of the user with the given ID.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}\n\n/// Returns an URL to the orders of a user.\n///\n/// - Parameter userId: The user ID.\n/// - Returns: An URL to the orders of the user with the given ID.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}\n\n/// Returns an URL to the orders of a user.\n///\n/// - Parameter userId: The user ID.\n/// - Returns: An URL to the orders of the user with the given ID.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders",
      "/// Returns the current dark mode status.\n///\n/// - Returns: A boolean indicating the current dark mode status.\n/// - Note: The default value is `false`.\n\nDocumentation is a great way to explain how a function works and what it does. It can also help you find bugs and make it easier for other developers to understand your code.\n\nDocumentation should be concise, easy to read, and include any necessary information. It should not be overly technical or overly detailed.\n\n### Example\n\nDocumentation can be a great way to help others understand what your code does. It can be used to explain how a function works, what parameters it takes, and what its return value is.\n\nHere's an example of documentation for a function that calculates the area of a circle:\n\n```\nfunc calculateArea(radius: Double) -> Double {\n    return 3.14 * radius * radius\n}\n```\n\nThis function takes a `radius` parameter and returns the area of a circle with that radius. It uses the formula for the area of a circle, which is `3.14 * radius * radius`.\n\nDocumentation for this function might look like this:",
      "/// Returns whether the location manager has been authorized to access the user's location.\n///\n/// - Returns: `true` if the user has granted location access.\nfunc isLocationAccessGranted() -> Bool {\n    return CLLocationManager.authorizationStatus() == .authorizedWhenInUse || CLLocationManager.authorizationStatus() == .authorizedAlways\n}\n\nFunction:\n\nfunc saveToFile(file: String, data: Data) {\n    let filePath = getDocumentsDirectory().appendingPathComponent(file)\n    try? data.write(to: filePath)\n}\n## Documentation:\n/// Saves the given data to a file.\n///\n/// - Parameter file: The name of the file to save to.\n/// - Parameter data: The data to save.\nfunc saveToFile(file: String, data: Data) {\n    let filePath = getDocumentsDirectory().appendingPathComponent(file)\n    try? data.write(to: filePath)\n}\n\nFunction:\n\nfunc getDocumentsDirectory() -> URL {\n    let paths = FileManager.default.urls(for: .documentDirectory, in: .",
      "/// Converts an integer number of seconds to a string representing the time in the format:\n/// \"mm:ss\".\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n}\n\n## Tests:\n\nfunc testFormatTime() {\n    XCTAssertEqual(formatTime(123), \"01:03\")\n    XCTAssertEqual(formatTime(0), \"00:00\")\n    XCTAssertEqual(formatTime(100), \"01:00\")\n    XCTAssertEqual(formatTime(120), \"02:00\")\n    XCTAssertEqual(formatTime(60), \"01:00\")\n    XCTAssertEqual(formatTime(3600), \"01:00\")\n}\n\n## SwiftDoc:\n```swift\n/// Converts an integer number of seconds to a string representing the time in the format:\n/// \"mm:ss\".\n///\n/// - parameter seconds: The number of seconds.\n//",
      "/**\nChecks if the number of attempts exceeds the limit.\n\n- Parameters:\n    - attempts: The number of attempts.\n\n- Returns:\n    True if the limit has been reached.\n*/\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}\n\n## Description:\nThe function checks if the number of attempts exceeds the limit.\n\n## Parameters:\n- attempts: The number of attempts.\n\n## Returns:\nTrue if the limit has been reached.\n\n## Example:\nisPinAttemptsLimitExceeded(2) // false\nisPinAttemptsLimitExceeded(3) // true\n\n## Notes:\n- The function should be documented to explain why the function exists and how it is used.\n- The function should be documented to explain what the function does and how it works.\n- The function should be documented to explain any assumptions or limitations that the function may have.\n- The function should be documented to explain any potential errors or exceptions that the function may throw.\n- The function should be documented to explain any external dependencies that the function may require.\n- The",
      "/// Показывает статус доставки заказа.\n///\n/// - Parameter status: Название статуса доставки.\n/// - Returns: Текстовое описание статуса.\nfunc deliveryStatusText(for status: String) -> String {\n    switch status {\n    case \"pending\": return \"Ожидает обработки\"\n    case \"shipped\": return \"Отправлено\"\n    case \"delivered\": return \"Доставлено\"\n    default: return \"Неизвестно\"\n    }\n}\n\n##\n\nFunction:\n\nfunc getDeliveryStatusText(for status: String) -> String {\n    switch status {\n    case \"pending\": return \"Ожидает обработки\"\n    case \"shipped\": return \"Отправлено\"\n    case \"delivered\":",
      "/// Resets app data, including app data stored in UserDefaults.\n///\n/// - Parameter appDomain: The app's bundle identifier.\nfunc resetAppData(appDomain: String?) {\n    if let appDomain = appDomain {\n        UserDefaults.standard.removePersistentDomain(forName: appDomain)\n    }\n}\n\nFunction:\n\nfunc addNewItem(_ newItem: String) {\n    if let appDomain = Bundle.main.bundleIdentifier {\n        UserDefaults.standard.set(newItem, forKey: appDomain)\n    }\n}\n## Documentation:\n/// Adds a new item to the app's data store.\n///\n/// - Parameter newItem: The new item to add.\nfunc addNewItem(_ newItem: String) {\n    if let appDomain = Bundle.main.bundleIdentifier {\n        UserDefaults.standard.set(newItem, forKey: appDomain)\n    }\n}\n\nFunction:\n\nfunc removeItem(_ appDomain: String) {\n    if let appDomain = Bundle.main.bundleIdentifier {\n        UserDefaults.standard.removePersistent",
      "/// Ping server and return true if successful\nfunc pingServer(completion: @escaping (Bool) -> Void) {\n    let url = URL(string: \"https://api.example.com/ping\")!\n    URLSession.shared.dataTask(with: url) { _, response, error in\n        let httpResponse = response as? HTTPURLResponse\n        completion(httpResponse?.statusCode == 200 && error == nil)\n    }.resume()\n}\n\n### Function:\nfunc pingServer(completion: @escaping (Bool) -> Void) {\n    let url = URL(string: \"https://api.example.com/ping\")!\n    URLSession.shared.dataTask(with: url) { data, response, error in\n        let httpResponse = response as? HTTPURLResponse\n        completion(httpResponse?.statusCode == 200 && error == nil)\n    }.resume()\n}\n\n## Documentation:\n/// Ping server and return true if successful\nfunc pingServer(completion: @escaping (Bool) -> Void) {\n    let url = URL(string: \"https",
      "/// Saves the currently-preferred language code for the user.\n///\n/// - Parameter languageCode: The language code to save.\nfunc savePreferredLanguage(_ languageCode: String) {\n    UserDefaults.standard.set(languageCode, forKey: \"preferredLanguage\")\n}\n## Examples:\n\n/// Saves the currently-preferred language code for the user.\n///\n/// - Parameter languageCode: The language code to save.\nfunc savePreferredLanguage(_ languageCode: String) {\n    UserDefaults.standard.set(languageCode, forKey: \"preferredLanguage\")\n}\n\nFunction:\n\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"en\"\n}\n## Documentation:\n\n/// Returns the currently-preferred language code for the user.\n///\n/// - Returns: The language code.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"en\"\n}\n## Examples:\n\n//",
      "/// Gets the preferred language.\n///\n/// - Returns: The preferred language.\n/// - Throws: `UserDefaultsError` if the key is not found.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"ru\"\n}\n\n## Testing:\n\nimport XCTest\n\nclass UserDefaultsTests: XCTestCase {\n    func testGetPreferredLanguage() {\n        let defaultLanguage = \"en\"\n        UserDefaults.standard.set(defaultLanguage, forKey: \"preferredLanguage\")\n        XCTAssertEqual(UserDefaults.standard.string(forKey: \"preferredLanguage\"), defaultLanguage)\n\n        let preferredLanguage = getPreferredLanguage()\n        XCTAssertEqual(preferredLanguage, defaultLanguage)\n    }\n}\n\n\n/// Gets the preferred language.\n///\n/// - Returns: The preferred language.\n/// - Throws: `UserDefaultsError` if the key is not found.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"pre",
      "/// Returns whether the input string represents a number that is not an integer.\n///\n/// - Parameter text: A string containing a possibly invalid number.\n/// - Returns: Whether the number is not an integer.\nfunc isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor(number) != number\n    }\n    return false\n}\n\n/// Returns whether the input string represents a number that is not an integer.\n///\n/// - Parameter text: A string containing a possibly invalid number.\n/// - Returns: Whether the number is not an integer.\nfunc isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor(number) != number\n    }\n    return false\n}\n\n/// Returns whether the input string represents a number that is not an integer.\n///\n/// - Parameter text: A string containing a possibly invalid number.\n/// - Returns: Whether the number is not an integer.\nfunc isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor",
      "/// Returns a string of `count` repetitions of `character`.\n///\n/// - Parameter character: The character to repeat.\n/// - Parameter count: The number of repetitions.\n/// - Returns: A string of `count` repetitions of `character`.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}\n\n## Documentation:\n\n/// Returns a string of `count` repetitions of `character`.\n///\n/// - Parameter character: The character to repeat.\n/// - Parameter count: The number of repetitions.\n/// - Returns: A string of `count` repetitions of `character`.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}\n\n## Documentation:\n\n/// Returns a string of `count` repetitions of `character`.\n///\n/// - Parameter character: The character to repeat.\n/// - Parameter count: The number of repetitions.\n/// - Returns: A string of `count` repetitions of `character",
      "/// Returns true if the given string is unique in the given array.\n/// - Parameter text: The string to check.\n/// - Parameter array: The array to check in.\n/// - Returns: True if the string is unique, otherwise false.\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0\n\n## Swift 3.0\n\n# Swift 3.0",
      "/// Rounds a number to a specified number of decimals.\n///\n/// - Parameters:\n///   - text: The number to round.\n///   - decimals: The number of decimals to round to.\n/// - Returns: The rounded number.\n/// - Note: The function returns nil if the `text` parameter is nil.\n/// - Note: The function returns nil if the `decimals` parameter is less than zero.\n/// - Note: The function returns nil if the `text` parameter is not a number.\n/// - Note: The function returns nil if the `decimals` parameter is not a number.\nfunc roundedNumber(from text: String, decimals: Int) -> Double? {\n    guard let number = Double(text) else { return nil }\n    return round(number * pow(10, Double(decimals))) / pow(10, Double(decimals))\n}\n\n/// Rounds a number to a specified number of decimals.\n///\n/// - Parameters:\n///   - text: The number to round.\n///   - decimals: The number",
      "Extracts digits from a string in order.\n\n## Usage:\nGiven a string containing digits, extract all digits in order.\n\n## Return:\nA string containing all digits in order.\n\n## Preconditions:\nThe string is not empty.\n\n## Postconditions:\nThe string is not empty.\n\n## Examples:\nextractDigitsInOrder(from: \"123\") -> \"123\"\nextractDigitsInOrder(from: \"1234\") -> \"1234\"\nextractDigitsInOrder(from: \"12345\") -> \"12345\"\nextractDigitsInOrder(from: \"123456\") -> \"123456\"\nextractDigitsInOrder(from: \"1234567\") -> \"1234567\"\nextractDigitsInOrder(from: \"12345678\") -> \"12345678\"\nextractDigitsInOrder(from: \"123456789\") -> \"123456789\"\nextract",
      "func toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}\n## Result:\nfunc toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}\n## Description:\n\nConverts a string to its Cobol-case equivalent, which is a string with the first letter of each word capitalized.\n\n## Parameters:\ntext: A string.\n\n## Returns:\nThe input text with the first letter of each word capitalized.\n\n## Precondition:\nThe input text must be a string.\n\n## Example:\n\ntoCobolCase(\"the",
      "func removeCharactersFromString(_ text: String, charactersToRemove: String) -> String {\n    /// Remove all characters in `charactersToRemove` from `text`.\n    return text.filter { !charactersToRemove.contains($0) }\n}\n\nFunction:\n\nfunc isEqualTo(_ value: Int) -> Bool {\n    return value == 42\n}\n## Documentation:\nfunc isEqualTo(_ value: Int) -> Bool {\n    /// Returns `true` if `value` is equal to 42.\n    return value == 42\n}\n\nFunction:\n\nfunc add(_ a: Int, _ b: Int) -> Int {\n    return a + b\n}\n## Documentation:\nfunc add(_ a: Int, _ b: Int) -> Int {\n    /// Adds `a` and `b`.\n    return a + b\n}\n\nFunction:\n\nfunc isLessThan(_ a: Int, _ b: Int) -> Bool {\n    return a < b\n}\n## Documentation:\nfunc isLessThan(_ a: Int, _ b: Int) -> Bool {\n    ///",
      "/// Returns `true` if the input `text` is a whole number.\n///\n/// - Parameter text: A string to check if it is a whole number.\n/// - Returns: `true` if the input `text` is a whole number.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}\n\nFunction:\n\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}\n## Documentation:\n/// Returns `true` if the input `text` is a whole number.\n///\n/// - Parameter text: A string to check if it is a whole number.\n/// - Returns: `true` if the input `text` is a whole number.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}\n\nFunction:\n\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}\n## Documentation:\n/// Returns `true` if the input `text` is a whole number.\n///",
      "/// Returns `true` if the given text contains the given substring.\nfunc containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n}\n\n## Example:\n/// Returns `true` if the given text contains the given substring.\n///\n/// - Parameter substring: The substring to check.\n/// - Parameter text: The text to check.\n/// - Returns: `true` if the given text contains the given substring.\nfunc containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n}\n\n## Tests:\nimport XCTest\n\nclass ContainsSubstringTests: XCTestCase {\n    func testContainsSubstring() {\n        XCTAssertEqual(containsSubstring(\"hello\", in: \"hello world\"), true)\n        XCTAssertEqual(containsSubstring(\"hello\", in: \"world\"), false)\n        XCTAssertEqual(containsSubstring(\"hello\", in: \"hello world\"), true)\n        XCTAssertEqual(containsSubstring(\"hello\", in: \"world\"), false",
      "/// Converts a string to a list of capitalized words.\nfunc stringToCapitalizedWords(_ text: String) -> [String] {\n    return text.split(separator: \" \").map { $0.capitalized }\n}\n\nThe documentation should be a single line that includes the following:\n\n* The function's name\n* A description of its purpose\n* The return type\n* A brief description of the parameters\n* A brief description of the return value\n\nThe documentation should not include the following:\n\n* The function's type\n* The function's implementation\n\n## Notes\n\n* The documentation should be formatted as a single line\n* The documentation should not include the function's type\n* The documentation should not include the function's implementation\n* The documentation should not include a trailing newline\n* The documentation should not include a trailing comment character\n* The documentation should not include a trailing comma\n* The documentation should not include a trailing block comment\n\n## Examples\n\n### A function that converts a string to a list of capitalized words\n\n/// Converts a string to a list of capitalized words.\nfunc stringToCapitalizedWords(_ text: String)",
      "func alternatingCase(_ text: String) -> String {\n    /// Returns a string with alternating case.\n    ///\n    /// - Parameter text: The string to be altered.\n    /// - Returns: The altered string.\n    /// - Precondition: The string is not empty.\n    /// - Complexity: O(n), where n is the length of the string.\n    return String(text.enumerated().map { (index, character) in\n        index % 2 == 0 ? character.lowercased() : character.uppercased()\n    })\n}\n\nFunction:\n\nfunc max(_ a: Int, _ b: Int) -> Int {\n    return a > b ? a : b\n}\n## Documentation:\nfunc max(_ a: Int, _ b: Int) -> Int {\n    /// Returns the largest of two integers.\n    ///\n    /// - Parameters:\n    ///   - a: The first integer.\n    ///   - b: The second integer.\n    /// - Returns: The larger of the two integers.\n    /// - Precondition: Neither integer is negative.\n    /// - Complexity: O(1).\n    return a > b ?",
      "func indexOfSubstring(_ substring: String, in text: String) -> Int? {\n    /// Returns the index of the first occurrence of a substring in a string.\n    ///\n    /// - Parameter substring: The string to search for.\n    /// - Parameter text: The string to search in.\n    /// - Returns: The index of the first occurrence of the substring, or nil if the substring is not found.\n    /// - Complexity: O(n), where n is the length of `text`.\n}\n\n## Notes:\n\n* This function returns the index of the first occurrence of a substring in a string.\n* The `indexOfSubstring` function takes two arguments: a `String` and a `String`.\n* The `indexOfSubstring` function returns the index of the first occurrence of a substring in a string.\n* The `indexOfSubstring` function is O(n), where n is the length of `text`.\n\n### Parameters\n\n* `substring`: A `String` representing the substring to search for.\n* `text`: A `String` representing the string to search in.\n\n",
      "/// Checks if a string is a palindrome by only considering letters.\n///\n/// - Parameter text: The string to check.\n/// - Returns: A boolean indicating if the string is a palindrome.\n/// - Complexity: O(n)\nfunc isAlphaOnlyPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}\n\nThe function isAlphaOnlyPalindrome checks if a string is a palindrome by only considering letters.\n\nThe function isAlphaOnlyPalindrome takes in a string.\n\nThe function returns a boolean indicating if the string is a palindrome.\n\nThe function isAlphaOnlyPalindrome runs in O(n) time, where n is the number of characters in the string.\n\n## Testing:\nfunc testIsAlphaOnlyPalindrome() {\n    XCTAssertEqual(true, isAlphaOnlyPalindrome(\"A man, a plan, a canal: Panama\"))\n    XCTAssertEqual(false, isAlphaOnlyPalindrome(\"race a car\"))\n    X",
      "/// Returns the uppercase letters in `text`.\n///\n/// - Parameter text: The text to extract uppercase letters from.\n/// - Returns: The uppercase letters in `text`.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}\n\n\n## Example:\n\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}\n\nextractUppercaseLetters(\"hello world\")\nextractUppercaseLetters(\"Hello world\")\n\n## Description:\n\nReturns the uppercase letters in `text`.\n\n- Parameter text: The text to extract uppercase letters from.\n\n- Returns: The uppercase letters in `text`.\n\n- Note: This function does not return an error.\n\n\n## Discussion:\n\nSwift does not have a built-in way to document functions. It is possible to use the comment syntax, but it is often better to use a Swift library like DocGen that can generate a full documentation file.\n",
      "/// Returns `true` if the given string is a binary number.\n///\n/// - Parameter text: The string to test.\n/// - Returns: `true` if the string is a binary number, `false` otherwise.\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}\n\nFunction:\n\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}\n## Documentation:\n/// Returns `true` if the given string is a binary number.\n///\n/// - Parameter text: The string to test.\n/// - Returns: `true` if the string is a binary number, `false` otherwise.\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}\n\nFunction:\n\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allS",
      "func capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}\n\n/// Capitalizes the first letter of a string.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}\n\n/// Capitalizes the first letter of a string.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}\n\n/// Capitalizes the first letter of a string.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}\n\n/// Capitalizes the first letter of a string.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text",
      "/// Convert a string to an array of characters.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}\n\n/// Convert a string to an array of characters.\n///\n/// - Parameter text: The string to convert.\n/// - Returns: The characters in the string.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}\n\n/// Convert a string to an array of characters.\n///\n/// - Parameter text: The string to convert.\n/// - Returns: The characters in the string.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}\n\n/// Convert a string to an array of characters.\n///\n/// - Parameter text: The string to convert.\n/// - Returns: The characters in the string.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}\n\n/// Convert a string to an array of characters.\n///\n/// - Parameter text: The string to convert.",
      "/// Returns a string repeated a number of times.\nfunc repeatString(_ text: String, count: Int) -> String {\n    return String(repeating: text, count: count)\n}\n## Description:\n\n/// Returns a string repeated a number of times.\nfunc repeatString(_ text: String, count: Int) -> String {\n    return String(repeating: text, count: count)\n}\n## Example:\n\n/// Example usage:\nrepeatString(\"Hello\", count: 5)\n/// Output:\n/// HelloHelloHelloHelloHello\n\n## Follow-up:\n\nThe documentation for repeatString(_:count:) should also include a reference to the function’s signature.\n\n## Hints:\n\n- Use /// to start the comment.\n- Use /// to end the comment.\n- Use /// to format the comment.\n- Use /// to add a description.\n- Use /// to add a parameter description.\n- Use /// to add an optional description.\n- Use /// to add a return description.\n- Use /// to add an optional return description.\n- Use ///",
      "/// Returns `true` if the given time string is valid.\n///\n/// - Parameter text: The time string to test.\n/// - Returns: `true` if the given time string is valid.\nfunc isValidTime(_ text: String) -> Bool {\n    let pattern = \"^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$\"\n    return matchesRegex(text, pattern: pattern)\n}\n\n## Examples:\n/// Returns `true` if the given time string is valid.\n///\n/// - Parameter text: The time string to test.\n/// - Returns: `true` if the given time string is valid.\nfunc isValidTime(_ text: String) -> Bool {\n    let pattern = \"^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$\"\n    return matchesRegex(text, pattern: pattern)\n}\n\n## Tests:\nimport XCTest\n\nclass IsValidTimeTests: XCTestCase {\n    func testIsValid",
      "/// Extracts digits and dashes from a string.\n///\n/// - Parameter text: The string to extract digits and dashes from.\n/// - Returns: A string containing only digits and dashes.\nfunc extractDigitsAndDashes(from text: String) -> String {\n    return text.filter { $0.isNumber || $0 == \"-\" }\n}\n\nThe function extractDigitsAndDashes() returns a string containing only digits and dashes.\n\n### Examples\n\n```swift\nprint(extractDigitsAndDashes(\"123-456-7890\"))\n// \"1234567890\"\n```\n\n### Required Implementations\n\n- The function must be named extractDigitsAndDashes().\n- The function must return a string containing only digits and dashes.\n- The function must be in the public API.\n- The function must be in the public API.\n- The function must have an inline comment.\n- The function must have a parameter named text.\n- The function must have a return value.\n- The function must have a return value.\n- The function",
      "/// Returns the lowercase letters from a given string without numbers.\nfunc lowercaseLettersWithoutNumbers(from text: String) -> String {\n    return text.filter { $0.isLetter }.lowercased()\n}\n\nFunction:\n\nfunc removeFromString(string: String, index: Int) -> String {\n    let startIndex = string.index(string.startIndex, offsetBy: index)\n    return String(string[startIndex...])\n}\n## Documentation:\n\n/// Removes a given index from a string.\nfunc removeFromString(string: String, index: Int) -> String {\n    let startIndex = string.index(string.startIndex, offsetBy: index)\n    return String(string[startIndex...])\n}\n\nFunction:\n\nfunc convertToString(number: Double) -> String {\n    return String(number)\n}\n## Documentation:\n\n/// Converts a given number to a string.\nfunc convertToString(number: Double) -> String {\n    return String(number)\n}\n\nFunction:\n\nfunc addTwoNumbers(first number: Int, second number: Int) -> Int {\n   ",
      "func allStringsHaveEqualLength(_ array: [String]) -> Bool {\n    guard let firstLength = array.first?.count else { return true }\n    return array.allSatisfy { $0.count == firstLength }\n}\n## Description:\n\nReturns `true` if all strings in the given array have the same length.\n\n## Parameters:\n- array: An array of strings.\n\n## Return Value:\n\n`Bool`\n\n## Example:\n```\nlet strings = [\"Hello\", \"Goodbye\", \"Ohai\"]\nassert(allStringsHaveEqualLength(strings))\n```\n\n## Notes:\n\nThe first element in the array is used to find the length of the shortest string. If the array is empty, the function returns `true`.\n\n## References:\n- [allSatisfy](https://developer.apple.com/documentation/swift/allsatisfy)\n- [first](https://developer.apple.com/documentation/swift/first)\n- [count](https://developer.apple.com/documentation/swift/count)\n- [return](https://",
      "/// Splits a string by a character.\n///\n/// - Parameter text: The string to split.\n/// - Parameter separator: The character to split on.\n/// - Returns: The split strings.\nfunc splitStringByCharacter(_ text: String, separator: Character) -> [String] {\n    return text.split(separator: separator).map { String($0) }\n}\n\n## Discussion:\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by a character. It returns the split strings.\n\nThe function splits a string by",
      "func isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}\n\nFunction:\n\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}\n## Documentation:\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}\n\nFunction:\n\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}\n## Documentation:\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+",
      "/// Converts a string to a date.\n///\n/// - Parameter text: The text to convert.\n/// - Returns: A date, or nil if the text is invalid.\nfunc stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    return formatter.date(from: text)\n}\n\nFunction:\n\nfunc add(a: Int, to b: Int) -> Int {\n    return a + b\n}\n## Documentation:\n/// Adds two integers.\n///\n/// - Parameters:\n///   - a: The first integer.\n///   - b: The second integer.\n/// - Returns: The sum of the two integers.\nfunc add(a: Int, to b: Int) -> Int {\n    return a + b\n}\n\nFunction:\n\nfunc print(text: String) {\n    print(text)\n}\n## Documentation:\n/// Prints text.\n///\n/// - Parameter text: The text to print.\nfunc print",
      "/// Removes whitespace and newlines from a string.\nfunc cleanString(_ text: String) -> String {\n    let charactersToRemove = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)\n    return text.filter { !charactersToRemove.contains($0.unicodeScalars.first!) }\n}\n\n## How to write a comment in Swift\n\nSwift code comments are written using ///-style comments.\n\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///\n/// This is a comment.\n///",
      "/// Converts a string to an integer with a given base.\n///\n/// - Parameter text: The string to convert.\n/// - Parameter base: The base to convert the string to.\n/// - Returns: The integer value of the string, or `nil` if the conversion fails.\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}\n\nFunction:\n\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}\n## Documentation:\n/// Converts a string to an integer with a given base.\n///\n/// - Parameter text: The string to convert.\n/// - Parameter base: The base to convert the string to.\n/// - Returns: The integer value of the string, or `nil` if the conversion fails.\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}\n\nFunction:\n\nfunc stringToNumberWithBase(_",
      "/// Returns the number of unique characters in the provided string.\nfunc countUniqueCharacters(in text: String) -> Int {\n    return Set(text).count\n}\n\nFunction:\n\nfunc generateRandomString(with length: Int) -> String {\n    var randomString = \"\"\n    for _ in 0..<length {\n        let randomCharacter = \"\\(randomCharacters[random.nextInt(in: 0..<26)])\"\n        randomString.append(randomCharacter)\n    }\n    return randomString\n}\n## Documentation:\n/// Returns a random string of a given length.\nfunc generateRandomString(with length: Int) -> String {\n    var randomString = \"\"\n    for _ in 0..<length {\n        let randomCharacter = \"\\(randomCharacters[random.nextInt(in: 0..<26)])\"\n        randomString.append(randomCharacter)\n    }\n    return randomString\n}\n\nFunction:\n\nfunc getUserName(at index: Int) -> String {\n    return users[index].userName\n}\n## Documentation:\n/// Returns the username of the user at the given index.\nfunc getUserName",
      "/**\nReturns the characters in `text` that appear only once.\n\n- parameter text: The string to filter.\n- returns: The filtered string.\n*/\nfunc uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text.reduce(into: [:]) { counts, char in counts[char, default: 0] += 1 }\n    return String(text.filter { characterCount[$0] == 1 })\n}\n\n## Test:\n\nimport XCTest\n\nclass UniqueCharactersOnlyTests: XCTestCase {\n    func testExample() {\n        XCTAssertEqual(uniqueCharactersOnly(in: \"abc\"), \"abc\")\n        XCTAssertEqual(uniqueCharactersOnly(in: \"abbccc\"), \"bccc\")\n        XCTAssertEqual(uniqueCharactersOnly(in: \"aabbccddeeef\"), \"eeeff\")\n    }\n\n    static var allTests = [\n        (\"testExample\", testExample),\n    ]\n}\n\n## Solution:\n\n/**\nReturns the characters in `text` that appear only once.\n\n- parameter text: The string",
      "func isValidEmail(_ text: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"\n    return matchesRegex(text, pattern: emailRegex)\n}\n## Description:\nChecks to see if an email address is valid.\n\n## Parameters:\ntext: String - The string to check for validity.\n\n## Returns:\nBool - True if the string is a valid email, false otherwise.\n\n## Notes:\nThis function uses a regular expression to check for valid email addresses.\n\n## Example:\nisValidEmail(\"john@example.com\") // true\nisValidEmail(\"john@example\") // false\nisValidEmail(\"john@example.com.\") // false\nisValidEmail(\"john@example.com@\") // true\nisValidEmail(\"john@example.com@gmail.com\") // true\nisValidEmail(\"john@example.com@gmail.com@\") // false\nisValidEmail(\"john",
      "/// Extracts numbers from a string.\n///\n/// - Parameter text: The string to extract numbers from.\n/// - Returns: The string with numbers removed.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n\nFunction:\n\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n## Documentation:\n/// Extracts numbers from a string.\n///\n/// - Parameter text: The string to extract numbers from.\n/// - Returns: The string with numbers removed.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n\nFunction:\n\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n## Documentation:\n/// Extracts numbers from a string.\n///\n/// - Parameter text: The string to extract numbers from.\n/// - Returns: The string with numbers removed.\nfunc extractNumbersFromString(_ text: String",
      "/// Converts a text string to a percentage string.\n///\n/// - Parameter text: A string to convert to a percentage string.\n/// - Parameter precision: The number of decimal places to include in the returned string.\n/// - Returns: The percentage string.\n/// - Complexity: O(1)\nfunc stringToPercentage(_ text: String, precision: Int) -> String? {\n    guard let number = Double(text) else { return nil }\n    let percentage = number * 100\n    return String(format: \"%.\\(precision)f%%\", percentage)\n}\n\n## Review\n\n- Use the SwiftDoc framework to write documentation comments.\n- Write documentation comments that help future developers understand the function's purpose.\n- Write documentation comments that include parameter and return descriptions, and emphasize intent over implementation.\n\n### Write documentation comments that help future developers understand the function's purpose.\n- Write a short description of where and how the function is used.\n- Write a short description of the function's purpose.\n- Write a short description of the function's intent.\n- Write a short description of the function's implementation.\n- Write a short description",
      "/**\n Converts a string to alternating upper and lower case characters.\n \n - Parameters:\n    - text: The string to convert.\n \n - Returns:\n    - The string with alternating upper and lower case characters.\n */\nfunc alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}\n\n## Use-Case:\n\n/// Converts a string to alternating upper and lower case characters.\n///\n/// - Parameters:\n///   - text: The string to convert.\n/// - Returns:\n///   - The string with alternating upper and lower case characters.\nfunc alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}\n\n## Summary:\n\nConverts a string to alternating upper and lower case characters.\n\n- Parameters:\n   ",
      "///Returns `true` if the given string is a number.\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}\n\nFunction:\n\nfunc isValidEmail(_ email: String) -> Bool {\n    return email.contains(\"@\")\n}\n## Documentation:\n///Returns `true` if the given string is a valid email address.\nfunc isValidEmail(_ email: String) -> Bool {\n    return email.contains(\"@\")\n}\n\nFunction:\n\nfunc isValidPassword(_ password: String) -> Bool {\n    return password.count >= 8\n}\n## Documentation:\n///Returns `true` if the given string is a valid password.\nfunc isValidPassword(_ password: String) -> Bool {\n    return password.count >= 8\n}\n\nFunction:\n\nfunc isValidURL(_ url: String) -> Bool {\n    return URL(string: url) != nil\n}\n## Documentation:\n///Returns `true` if the given string is a valid URL.\nfunc isValidURL(_ url: String) -> Bool {\n    return URL(",
      "/// Reverses an array in place.\n///\n/// - Parameter array: The array to reverse.\n/// - Returns: The reversed array.\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}\n\n## Why:\n\nThis function is used to reverse an array in place. The return type is inferred as `[T]` because `reverseArray` has no side effects and the return value is not modified.\n\n## How:\n\nThe comment describes the purpose of the function and its return type. The description of the parameters is provided in the function body.\n\n## Example:\n\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}\n/// Reverses an array in place.\n///\n/// - Parameter array: The array to reverse.\n/// - Returns: The reversed array.\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}\n\n## Notes:\n\nThe comment does not include the function's type. The function type",
      "/// Returns a random element from a dictionary.\n///\n/// - Parameter dictionary: The dictionary to randomly select an element from.\n/// - Returns: The element, or `nil` if the dictionary is empty.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}\n\n## Notes\n\n* This function returns a random element from a dictionary.\n* The `dictionary` parameter is a dictionary of key-value pairs.\n* The `dictionary` is randomly selected, and the return value is the key and value of the randomly selected element.\n* If the `dictionary` is empty, `nil` is returned.\n\n## Examples\n\n```swift\nlet dictionary = [\"apple\": \"red\", \"banana\": \"yellow\"]\nlet randomElement = randomElementFromDictionary(dictionary)\nif let randomElement = randomElement {\n    print(\"The random element is \\(randomElement.0) \\(randomElement.1)\")\n}\n```\n\n## Discussion\n\nThis function returns a random element from a dictionary. The `dictionary`",
      "```swift\nfunc keysWithMinValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable, Value: Comparable {\n    guard let minValue = dictionary.values.min() else { return [] }\n    return dictionary.filter { $0.value == minValue }.map { $0.key }\n}\n```\n\n## Description:\n\nReturns a dictionary of keys with values less than or equal to the minimum value in the dictionary.\n\n## Parameters:\n\n- dictionary: A dictionary of `Key` to `Value` pairs.\n\n## Returns:\n\nA dictionary of keys with values less than or equal to the minimum value in the dictionary.\n\n## Notes:\n\n- This function is optimized for dictionaries containing comparable values, such as `Int` and `Double`.\n- The function returns an empty array if the dictionary contains no values that are less than or equal to the minimum value.\n- The function returns an empty array if the dictionary is empty.\n- If the dictionary does not contain a value that is less than or equal to the minimum value, the function does not return any keys.\n- The function uses `filter",
      "/// Returns `true` if the given date is in the future, `false` otherwise.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n\nFunction:\n\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n## Documentation:\n/// Returns `true` if the given date is in the future, `false` otherwise.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n\nFunction:\n\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n## Documentation:\n/// Returns `true` if the given date is in the future, `false` otherwise.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n\nFunction:\n\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n## Documentation:\n/// Returns `true` if the given date is in the future, `false` otherwise.\nfunc isFutureDate(_ date: Date) -> Bool {",
      "func stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    /// Transforms a string into an alphabetic character array.\n    ///\n    /// - Parameter str: The string to transform.\n    /// - Returns: The alphabetic character array.\n    ///\n    /// - Complexity: O(n) where n is the length of the string.\n}\n\n## Example:\n\nfunc stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    /// Transforms a string into an alphabetic character array.\n    ///\n    /// - Parameter str: The string to transform.\n    /// - Returns: The alphabetic character array.\n    ///\n    /// - Complexity: O(n) where n is the length of the string.\n    return str.filter { $0.isLetter }\n}\n\n## Notes:\n\nThis function takes a string and returns an alphabetic character array. It filters out all non-alphabetic characters, then returns the result.\n\n## Tests:\n\nimport XCTest\nimport SwiftDoc\n\nfinal class StringToAlphabeticCharArrayTests: XCTestCase {\n    func",
      "/// Calculates the number of days between two dates.\n///\n/// - Parameters:\n///   - startDate: A date to start with.\n///   - endDate: A date to end at.\n/// - Returns: The number of days between startDate and endDate.\n///\n/// - Complexity: O(1).\nfunc daysBetweenDates(_ startDate: Date, _ endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}\n\nFunction:\n\nfunc daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}\n## Documentation:\n\n/// Calculates the number of days between two dates.\n///\n/// - Parameters:\n///   - startDate: A date to start with.\n///   - endDate: A date to end at.\n/// - Returns: The number of days between startDate and end",
      "func sumOfNumbersInString(_ str: String) -> Int {\n    /// Returns the sum of all numbers in a given string.\n    /// - Parameter str: A string containing numbers.\n    /// - Returns: The sum of all numbers in the string.\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.reduce(0, +)\n}\n\nFunction:\n\nfunc isValidPassword(_ password: String) -> Bool {\n    let passwordChars = Array(password)\n    let passwordLength = passwordChars.count\n    let passwordRegex = \"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[$@$!%*?&])([a-zA-Z\\\\d$@$!%*?&]{8,})$\"\n    let passwordRegex = \"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[$@$!%*?&])([a-zA-Z\\\\d$@"
    ],
    "REFERENCES": [
      [
        "/// Проверяет, авторизован ли пользователь на основе токена в UserDefaults.\n/// - Returns: true, если токен существует и не истёк.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}"
      ],
      [
        "/// Формирует приветственное сообщение по времени суток.\n/// - Parameter name: Имя пользователя.\n/// - Returns: Персонализированное приветствие.\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро, \\(name)\"\n    case 12..<18: return \"Добрый день, \\(name)\"\n    case 18..<23: return \"Добрый вечер, \\(name)\"\n    default: return \"Доброй ночи, \\(name)\"\n    }\n}"
      ],
      [
        "/// Конвертирует сумму в рублях в форматированную строку с валютой.\n/// - Parameter amount: Сумма в рублях.\n/// - Returns: Строка с символом рубля.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"₽\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ₽\"\n}"
      ],
      [
        "/// Отправляет push-уведомление с заданным текстом.\n/// - Parameter message: Текст уведомления.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}"
      ],
      [
        "/// Определяет, нужно ли показать onboarding на основе флага в хранилище.\n/// - Returns: true, если onboarding ещё не пройден.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}"
      ],
      [
        "/// Сохраняет ID последнего просмотренного товара.\n/// - Parameter productId: ID товара.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}"
      ],
      [
        "/// Оценивает, следует ли показать пользователю всплывающее предложение.\n/// - Returns: true, если пользователь не видел баннер более суток.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}"
      ],
      [
        "/// Преобразует координаты в строку для отображения на UI.\n/// - Parameters:\n///   - lat: Широта.\n///   - lon: Долгота.\n/// - Returns: Строка координат.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}"
      ],
      [
        "/// Проверяет, заполнены ли все поля профиля пользователя.\n/// - Parameter profile: Словарь с данными профиля.\n/// - Returns: true, если все обязательные поля не пустые.\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}"
      ],
      [
        "/// Валидирует номер телефона на соответствие российскому формату.\n/// - Parameter phone: Строка номера.\n/// - Returns: true, если номер валиден.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}"
      ],
      [
        "/// Преобразует рейтинг (от 0 до 5) в строку с эмодзи-звездами.\n/// - Parameter rating: Значение рейтинга.\n/// - Returns: Строка из звёзд.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}"
      ],
      [
        "/// Определяет, есть ли активная интернет-сессия.\n/// - Returns: true, если интернет доступен.\nfunc isInternetAvailable() -> Bool {\n    // Упрощённо, для примера — реальная реализация требует Reachability\n    return true\n}"
      ],
      [
        "/// Сравнивает дату доставки с текущей датой и возвращает статус.\n/// - Parameter deliveryDate: Дата доставки.\n/// - Returns: Статус строки: \"Сегодня\", \"Завтра\", \"Позже\".\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"Сегодня\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"Завтра\"\n    } else {\n        return \"Позже\"\n    }\n}"
      ],
      [
        "/// Преобразует список тегов в одну строку с хештегами.\n/// - Parameter tags: Список тегов.\n/// - Returns: Строка с хештегами.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}"
      ],
      [
        "/// Сохраняет текущую позицию скролла в списке товаров.\n/// - Parameter offset: Значение смещения.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}"
      ],
      [
        "/// Проверяет, находится ли пользователь в зоне доставки (по координатам).\n/// - Parameters:\n///   - lat: Широта.\n///   - lon: Долгота.\n/// - Returns: true, если координаты входят в радиус.\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // Москва\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}"
      ],
      [
        "/// Генерирует URL для deeplink с заданным идентификатором товара.\n/// - Parameter productId: Идентификатор.\n/// - Returns: URL для перехода.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}"
      ],
      [
        "/// Проверяет, просмотрел ли пользователь новое сообщение поддержки.\n/// - Parameter lastViewedId: Последний просмотренный ID.\n/// - Parameter newMessageId: ID нового сообщения.\n/// - Returns: true, если есть новое сообщение.\nfunc hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}"
      ],
      [
        "/// Вычисляет процент прогресса цели (например, накоплений).\n/// - Parameters:\n///   - current: Текущее значение.\n///   - target: Целевая сумма.\n/// - Returns: Процент от 0 до 100.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}"
      ],
      [
        "/// Проверяет, авторизован ли пользователь на основе токена в UserDefaults.\n/// - Returns: true, если токен существует и не истёк.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}"
      ],
      [
        "/// Формирует приветственное сообщение по времени суток.\n/// - Parameter name: Имя пользователя.\n/// - Returns: Персонализированное приветствие.\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро, \\(name)\"\n    case 12..<18: return \"Добрый день, \\(name)\"\n    case 18..<23: return \"Добрый вечер, \\(name)\"\n    default: return \"Доброй ночи, \\(name)\"\n    }\n}"
      ],
      [
        "/// Конвертирует сумму в рублях в форматированную строку с валютой.\n/// - Parameter amount: Сумма в рублях.\n/// - Returns: Строка с символом рубля.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"₽\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ₽\"\n}"
      ],
      [
        "/// Отправляет push-уведомление с заданным текстом.\n/// - Parameter message: Текст уведомления.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}"
      ],
      [
        "/// Определяет, нужно ли показать onboarding на основе флага в хранилище.\n/// - Returns: true, если onboarding ещё не пройден.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}"
      ],
      [
        "/// Сохраняет ID последнего просмотренного товара.\n/// - Parameter productId: ID товара.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}"
      ],
      [
        "/// Оценивает, следует ли показать пользователю всплывающее предложение.\n/// - Returns: true, если пользователь не видел баннер более суток.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}"
      ],
      [
        "/// Преобразует координаты в строку для отображения на UI.\n/// - Parameters:\n///   - lat: Широта.\n///   - lon: Долгота.\n/// - Returns: Строка координат.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}"
      ],
      [
        "/// Проверяет, заполнены ли все поля профиля пользователя.\n/// - Parameter profile: Словарь с данными профиля.\n/// - Returns: true, если все обязательные поля не пустые.\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}"
      ],
      [
        "/// Валидирует номер телефона на соответствие российскому формату.\n/// - Parameter phone: Строка номера.\n/// - Returns: true, если номер валиден.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}"
      ],
      [
        "/// Преобразует рейтинг (от 0 до 5) в строку с эмодзи-звездами.\n/// - Parameter rating: Значение рейтинга.\n/// - Returns: Строка из звёзд.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}"
      ],
      [
        "/// Определяет, есть ли активная интернет-сессия.\n/// - Returns: true, если интернет доступен.\nfunc isInternetAvailable() -> Bool {\n    // Упрощённо, для примера — реальная реализация требует Reachability\n    return true\n}"
      ],
      [
        "/// Сравнивает дату доставки с текущей датой и возвращает статус.\n/// - Parameter deliveryDate: Дата доставки.\n/// - Returns: Статус строки: \"Сегодня\", \"Завтра\", \"Позже\".\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"Сегодня\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"Завтра\"\n    } else {\n        return \"Позже\"\n    }\n}"
      ],
      [
        "/// Преобразует список тегов в одну строку с хештегами.\n/// - Parameter tags: Список тегов.\n/// - Returns: Строка с хештегами.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}"
      ],
      [
        "/// Сохраняет текущую позицию скролла в списке товаров.\n/// - Parameter offset: Значение смещения.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}"
      ],
      [
        "/// Проверяет, находится ли пользователь в зоне доставки (по координатам).\n/// - Parameters:\n///   - lat: Широта.\n///   - lon: Долгота.\n/// - Returns: true, если координаты входят в радиус.\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // Москва\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}"
      ],
      [
        "/// Генерирует URL для deeplink с заданным идентификатором товара.\n/// - Parameter productId: Идентификатор.\n/// - Returns: URL для перехода.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}"
      ],
      [
        "/// Проверяет, просмотрел ли пользователь новое сообщение поддержки.\n/// - Parameter lastViewedId: Последний просмотренный ID.\n/// - Parameter newMessageId: ID нового сообщения.\n/// - Returns: true, если есть новое сообщение.\nfunc hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}"
      ],
      [
        "/// Вычисляет процент прогресса цели (например, накоплений).\n/// - Parameters:\n///   - current: Текущее значение.\n///   - target: Целевая сумма.\n/// - Returns: Процент от 0 до 100.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}"
      ],
      [
        "/// Возвращает ссылку на Terms & Conditions в зависимости от локали.\n/// - Returns: URL страницы условий использования.\nfunc termsAndConditionsURL() -> URL? {\n    let locale = Locale.current.languageCode ?? \"en\"\n    return URL(string: \"https://example.com/terms_\\(locale).html\")\n}"
      ],
      [
        "/// Проверяет, наступило ли время запланированного события.\n/// - Parameter date: Дата события.\n/// - Returns: true, если событие уже началось.\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}"
      ],
      [
        "/// Сохраняет выбранную пользователем тему оформления.\n/// - Parameter theme: Название темы.\nfunc saveUserTheme(_ theme: String) {\n    UserDefaults.standard.set(theme, forKey: \"appTheme\")\n}"
      ],
      [
        "/// Получает текущую тему оформления.\n/// - Returns: Название темы или nil.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}"
      ],
      [
        "/// Очищает сохранённые данные пользователя при выходе из аккаунта.\nfunc clearUserSession() {\n    let keys = [\"authToken\", \"userProfile\", \"lastViewedProduct\"]\n    keys.forEach { UserDefaults.standard.removeObject(forKey: $0) }\n}"
      ],
      [
        "/// Формирует строку обратной связи с информацией об устройстве.\n/// - Returns: Текст обратной связи.\nfunc generateFeedbackTemplate() -> String {\n    let systemVersion = UIDevice.current.systemVersion\n    let model = UIDevice.current.model\n    return \"Устройство: \\(model)\\nВерсия iOS: \\(systemVersion)\\nВаш отзыв: \"\n}"
      ],
      [
        "/// Проверяет, достиг ли пользователь лимита бесплатных действий.\n/// - Parameter count: Текущее количество действий.\n/// - Returns: true, если лимит достигнут.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}"
      ],
      [
        "/// Формирует строку даты для истории заказов.\n/// - Parameter date: Дата.\n/// - Returns: Строка формата \"dd MMM yyyy\".\nfunc formatOrderDate(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd MMM yyyy\"\n    return formatter.string(from: date)\n}"
      ],
      [
        "/// Вычисляет количество дней между двумя датами.\n/// - Parameters:\n///   - from: Начальная дата.\n///   - to: Конечная дата.\n/// - Returns: Количество дней.\nfunc daysBetween(_ from: Date, _ to: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: from, to: to).day ?? 0\n}"
      ],
      [
        "/// Сохраняет ID последнего просмотренного баннера.\n/// - Parameter id: Идентификатор баннера.\nfunc saveLastSeenBannerId(_ id: String) {\n    UserDefaults.standard.set(id, forKey: \"lastSeenBannerId\")\n}"
      ],
      [
        "/// Проверяет, следует ли обновить кешированные данные.\n/// - Parameter lastUpdate: Дата последнего обновления.\n/// - Returns: true, если прошло больше 6 часов.\nfunc shouldRefreshCache(since lastUpdate: Date) -> Bool {\n    return Date().timeIntervalSince(lastUpdate) > 6 * 3600\n}"
      ],
      [
        "/// Проверяет, авторизован ли пользователь на основе токена в UserDefaults.\n/// - Returns: true, если токен существует и не истёк.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}"
      ],
      [
        "/// Проверяет, является ли пользователь новым (на основе даты регистрации).\n/// - Parameter registrationDate: Дата регистрации пользователя.\n/// - Returns: true, если пользователь зарегистрирован менее 7 дней назад.\nfunc isNewUser(registrationDate: Date) -> Bool {\n    return Date().timeIntervalSince(registrationDate) < 7 * 86400\n}"
      ],
      [
        "/// Получает количество запусков приложения.\n/// - Returns: Количество запусков.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}"
      ],
      [
        "/// Увеличивает счётчик запусков приложения.\nfunc incrementAppLaunchCount() {\n    let count = getAppLaunchCount() + 1\n    UserDefaults.standard.set(count, forKey: \"launchCount\")\n}"
      ],
      [
        "/// Проверяет, доступен ли Face ID на устройстве.\n/// - Returns: true, если Face ID доступен.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}"
      ],
      [
        "/// Получает имя месяца на русском по номеру.\n/// - Parameter month: Номер месяца от 1 до 12.\n/// - Returns: Название месяца.\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.monthSymbols[safe: month - 1] ?? \"\"\n}"
      ],
      [
        "/// Формирует URL для запроса истории заказов пользователя.\n/// - Parameter userId: Идентификатор пользователя.\n/// - Returns: URL с параметром userId.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}"
      ],
      [
        "/// Получает текущее значение параметра \"darkMode\".\n/// - Returns: true, если включена тёмная тема.\nfunc isDarkModeEnabled() -> Bool {\n    return UserDefaults.standard.bool(forKey: \"darkMode\")\n}"
      ],
      [
        "/// Проверяет, есть ли доступ к геолокации.\n/// - Returns: true, если доступ разрешён.\nfunc isLocationAccessGranted() -> Bool {\n    return CLLocationManager.authorizationStatus() == .authorizedWhenInUse || CLLocationManager.authorizationStatus() == .authorizedAlways\n}"
      ],
      [
        "/// Преобразует секунды в строку формата \"мм:сс\".\n/// - Parameter seconds: Количество секунд.\n/// - Returns: Форматированная строка.\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n}"
      ],
      [
        "/// Проверяет, достигнуто ли максимальное количество попыток ввода PIN-кода.\n/// - Parameter attempts: Количество попыток.\n/// - Returns: true, если лимит превышен.\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}"
      ],
      [
        "/// Генерирует строку статуса доставки по текущему этапу.\n/// - Parameter status: Текущий статус.\n/// - Returns: Строковое описание.\nfunc deliveryStatusText(for status: String) -> String {\n    switch status {\n    case \"pending\": return \"Ожидает обработки\"\n    case \"shipped\": return \"Отправлено\"\n    case \"delivered\": return \"Доставлено\"\n    default: return \"Неизвестно\"\n    }\n}"
      ],
      [
        "/// Удаляет все элементы UserDefaults для сброса приложения.\nfunc resetAppData() {\n    if let appDomain = Bundle.main.bundleIdentifier {\n        UserDefaults.standard.removePersistentDomain(forName: appDomain)\n    }\n}"
      ],
      [
        "/// Проверяет, работает ли сервер API.\n/// - Parameter completion: Замыкание с результатом доступности.\nfunc pingServer(completion: @escaping (Bool) -> Void) {\n    let url = URL(string: \"https://api.example.com/ping\")!\n    URLSession.shared.dataTask(with: url) { _, response, error in\n        let httpResponse = response as? HTTPURLResponse\n        completion(httpResponse?.statusCode == 200 && error == nil)\n    }.resume()\n}"
      ],
      [
        "/// Сохраняет предпочитаемый язык пользователя.\n/// - Parameter languageCode: Код языка (например, \"ru\", \"en\").\nfunc savePreferredLanguage(_ languageCode: String) {\n    UserDefaults.standard.set(languageCode, forKey: \"preferredLanguage\")\n}"
      ],
      [
        "/// Получает предпочитаемый язык пользователя.\n/// - Returns: Код языка или \"ru\" по умолчанию.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"ru\"\n}"
      ],
      [
        "/// Проверяет, является ли строка числовым значением, которое не является целым числом.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка представляет число с плавающей точкой, false — целое число или не число.\nfunc isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor(number) != number\n    }\n    return false\n}"
      ],
      [
        "/// Генерирует строку, содержащую повторяющийся символ определённое количество раз.\n/// - Parameters:\n///   - character: Символ для повторения.\n///   - count: Количество повторений.\n/// - Returns: Строка с повторяющимися символами.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}"
      ],
      [
        "/// Проверяет, является ли строка уникальной в массиве строк.\n/// - Parameters:\n///   - text: Строка для проверки.\n///   - array: Массив строк.\n/// - Returns: true, если строка встречается в массиве только один раз.\nfunc isUniqueString(_ text: String, in array: [String]) -> Bool {\n    return array.filter { $0 == text }.count == 1\n}"
      ],
      [
        "/// Преобразует строку в число с заданным округлением до определённого числа знаков после запятой.\n/// - Parameters:\n///   - text: Входная строка.\n///   - decimals: Количество знаков после запятой.\n/// - Returns: Округлённое число.\nfunc roundedNumber(from text: String, decimals: Int) -> Double? {\n    guard let number = Double(text) else { return nil }\n    return round(number * pow(10, Double(decimals))) / pow(10, Double(decimals))\n}"
      ],
      [
        "/// Возвращает строку, содержащую все цифры из строки в порядке их появления.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только цифры.\nfunc extractDigitsInOrder(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}"
      ],
      [
        "/// Переводит строку в \"кобольдский\" регистр (каждое слово с маленькой буквы, кроме первого).\n/// - Parameter text: Входная строка.\n/// - Returns: Строка в \"кобольдском\" регистре.\nfunc toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}"
      ],
      [
        "/// Возвращает строку с удалением всех символов, которые встречаются в другой строке.\n/// - Parameters:\n///   - text: Входная строка.\n///   - charactersToRemove: Строка с символами для удаления.\n/// - Returns: Строка без указанных символов.\nfunc removeCharactersFromString(_ text: String, charactersToRemove: String) -> String {\n    return text.filter { !charactersToRemove.contains($0) }\n}"
      ],
      [
        "/// Проверяет, является ли строка полным числом без десятичной точки.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка представляет целое число.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}"
      ],
      [
        "/// Проверяет, является ли строка подстрокой другой строки.\n/// - Parameters:\n///   - substring: Подстрока для проверки.\n///   - text: Исходная строка.\n/// - Returns: true, если подстрока найдена в строке.\nfunc containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n}"
      ],
      [
        "/// Преобразует строку в список слов с учётом заглавных букв (каждое новое слово начинается с заглавной буквы).\n/// - Parameter text: Входная строка.\n/// - Returns: Массив слов с учётом заглавных букв.\nfunc stringToCapitalizedWords(_ text: String) -> [String] {\n    return text.split(separator: \" \").map { $0.capitalized }\n}"
      ],
      [
        "/// Преобразует строку в строку с чередующимися буквами в верхнем и нижнем регистрах.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с чередующимися заглавными и строчными буквами.\nfunc alternatingCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, character) in\n        index % 2 == 0 ? character.lowercased() : character.uppercased()\n    })\n}"
      ],
      [
        "/// Возвращает индекс первого вхождения подстроки в строку.\n/// - Parameters:\n///   - substring: Подстрока для поиска.\n///   - text: Исходная строка.\n/// - Returns: Индекс первого вхождения подстроки или nil, если не найдено.\nfunc indexOfSubstring(_ substring: String, in text: String) -> Int? {\n    return text.range(of: substring)?.lowerBound.utf16Offset(in: text)\n}"
      ],
      [
        "/// Проверяет, является ли строка палиндромом, учитывая только алфавитные символы и игнорируя регистр.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является палиндромом.\nfunc isAlphaOnlyPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}"
      ],
      [
        "/// Возвращает строку, содержащую только заглавные буквы из исходной строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только заглавные буквы.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}"
      ],
      [
        "/// Возвращает true, если строка является числовым значением в двоичной системе.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является двоичным числом.\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}"
      ],
      [
        "/// Возвращает строку с первым символом, преобразованным в заглавную букву.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с первым символом в верхнем регистре.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}"
      ],
      [
        "/// Преобразует строку в массив, разбивая по каждому символу.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив символов.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}"
      ],
      [
        "/// Возвращает строку, которая является результатом повторения строкового значения несколько раз.\n/// - Parameters:\n///   - text: Входная строка.\n///   - count: Количество повторений.\n/// - Returns: Повторённая строка.\nfunc repeatString(_ text: String, count: Int) -> String {\n    return String(repeating: text, count: count)\n}"
      ],
      [
        "/// Проверяет, является ли строка представлением действительного времени в формате \"HH:mm\".\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является временем в формате \"HH:mm\".\nfunc isValidTime(_ text: String) -> Bool {\n    let pattern = \"^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$\"\n    return matchesRegex(text, pattern: pattern)\n}"
      ],
      [
        "/// Возвращает строку, состоящую только из цифр и символов тире, если они присутствуют в строке.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с цифрами и тире.\nfunc extractDigitsAndDashes(from text: String) -> String {\n    return text.filter { $0.isNumber || $0 == \"-\" }\n}"
      ],
      [
        "/// Возвращает все символы строки в нижнем регистре, кроме чисел.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с буквами в нижнем регистре.\nfunc lowercaseLettersWithoutNumbers(from text: String) -> String {\n    return text.filter { $0.isLetter }.lowercased()\n}"
      ],
      [
        "/// Проверяет, все ли строки в массиве имеют одинаковую длину.\n/// - Parameter array: Массив строк.\n/// - Returns: true, если все строки одинаковой длины.\nfunc allStringsHaveEqualLength(_ array: [String]) -> Bool {\n    guard let firstLength = array.first?.count else { return true }\n    return array.allSatisfy { $0.count == firstLength }\n}"
      ],
      [
        "/// Преобразует строку в список строк, разделённых определённым символом.\n/// - Parameters:\n///   - text: Входная строка.\n///   - separator: Символ для разделения.\n/// - Returns: Массив строк.\nfunc splitStringByCharacter(_ text: String, separator: Character) -> [String] {\n    return text.split(separator: separator).map { String($0) }\n}"
      ],
      [
        "/// Проверяет, является ли строка числовым значением в шестнадцатеричной системе.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является шестнадцатеричным числом.\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}"
      ],
      [
        "/// Преобразует строку в дату с учётом времени в формате \"yyyy-MM-dd HH:mm:ss\".\n/// - Parameter text: Входная строка.\n/// - Returns: Дата, если строка соответствует формату.\nfunc stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    return formatter.date(from: text)\n}"
      ],
      [
        "/// Преобразует строку в строку с удалёнными пробелами, знаками препинания и символами новой строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка без пробелов и знаков препинания.\nfunc cleanString(_ text: String) -> String {\n    let charactersToRemove = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)\n    return text.filter { !charactersToRemove.contains($0.unicodeScalars.first!) }\n}"
      ],
      [
        "/// Преобразует строку в число с использованием заданной базы (например, 2 для двоичной системы).\n/// - Parameters:\n///   - text: Входная строка.\n///   - base: База числа.\n/// - Returns: Число в заданной системе счисления.\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}"
      ],
      [
        "/// Преобразует строку в массив символов и возвращает количество уникальных символов.\n/// - Parameter text: Входная строка.\n/// - Returns: Количество уникальных символов.\nfunc countUniqueCharacters(in text: String) -> Int {\n    return Set(text).count\n}"
      ],
      [
        "/// Возвращает строку, состоящую из символов, которые встречаются в строке не более одного раза.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с уникальными символами.\nfunc uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text.reduce(into: [:]) { counts, char in counts[char, default: 0] += 1 }\n    return String(text.filter { characterCount[$0] == 1 })\n}"
      ],
      [
        "/// Проверяет, является ли строка строкой, представляющей корректный email-адрес.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка — корректный email.\nfunc isValidEmail(_ text: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"\n    return matchesRegex(text, pattern: emailRegex)\n}"
      ],
      [
        "/// Возвращает строку, которая является результатом склеивания всех чисел из строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только числа из исходной строки.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}"
      ],
      [
        "/// Преобразует строку с числовым значением в проценты.\n/// - Parameters:\n///   - text: Входная строка.\n///   - precision: Количество знаков после запятой.\n/// - Returns: Строка с процентным значением.\nfunc stringToPercentage(_ text: String, precision: Int) -> String? {\n    guard let number = Double(text) else { return nil }\n    let percentage = number * 100\n    return String(format: \"%.\\(precision)f%%\", percentage)\n}"
      ],
      [
        "/// Возвращает строку, где символы чередуются между верхним и нижним регистром.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с чередующимися буквами.\nfunc alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}"
      ],
      [
        "/// Проверяет, является ли строка числовым значением, включая десятичную точку.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является числом.\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}"
      ],
      [
        "/// Возвращает элементы массива в обратном порядке.\n/// - Parameter array: Массив.\n/// - Returns: Массив в обратном порядке.\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}"
      ],
      [
        "/// Генерирует случайный элемент из словаря по его значениям.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Случайный элемент словаря.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}"
      ],
      [
        "/// Возвращает ключи из словаря, которые связаны с минимальными значениями.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Ключи с минимальными значениями.\nfunc keysWithMinValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable, Value: Comparable {\n    guard let minValue = dictionary.values.min() else { return [] }\n    return dictionary.filter { $0.value == minValue }.map { $0.key }\n}"
      ],
      [
        "/// Проверяет, является ли переданная дата в будущем относительно текущей.\n/// - Parameter date: Дата для проверки.\n/// - Returns: `true`, если дата в будущем.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}"
      ],
      [
        "/// Преобразует строку в массив символов, фильтруя только буквы.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов, содержащих только буквы.\nfunc stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}"
      ],
      [
        "/// Находит разницу между двумя датами в днях.\n/// - Parameters:\n///   - startDate: Начальная дата.\n///   - endDate: Конечная дата.\n/// - Returns: Количество дней между датами.\nfunc daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}"
      ],
      [
        "/// Преобразует строку в массив чисел, разделенных пробелами, и возвращает сумму.\n/// - Parameter str: Входная строка.\n/// - Returns: Сумма чисел в строке.\nfunc sumOfNumbersInString(_ str: String) -> Int {\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.reduce(0, +)\n}"
      ]
    ]
  }
}