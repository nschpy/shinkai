{
  "title": "HuggingFaceTB/SmolLM2-1.7B-supervised-full-fine-tuning",
  "description": "Супервизорное полное дообучение модели HuggingFaceTB/SmolLM2-1.7B с последующим инференсом и оценкой на тестовом наборе данных по метрикам BLEU и ROUGE.",
  "metrics": {
    "BLEU": 0.2500855093778992,
    "ROUGE-L": 0.36825438796127963,
    "PREDICTIONS": [
      "func isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}\n\n## Input/Output:\n\n/// Проверяет, является ли пользователь авторизованным.\n/// - Returns: `true`, если пользователь авторизован.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty",
      "/// Генерирует сообщение о времени работы дня.\n/// - Parameter name: Имя пользователя.\n/// - Returns: Сообщение.\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро, \\(name)\"\n    case 12..<18: return \"Добрый день, \\(name)\"\n    case 18..<23: return \"Добрый вечер, \\(name)\"\n    default: return \"Доброй ночи, \\(name)\"\n    }\n}\n\n## Test:\nimport XCTest\n\nfinal class GenerateGreetingMessageTests: XCTestCase {\n    func testGenerateGreetingMessage() {\n        let expected = \"Добр",
      "/// Форматирует сумму в формате \"РТС\".\n/// - Parameter amount: Значение для форматирования.\n/// - Returns: Комментарий с результатом.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"₽\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ₽\"\n}\n\n## Examples:\n/// Форматирует сумму в формате \"РТС\".\n/// - Parameter amount: Значение для форматирования.\n/// - Returns: Комментарий с результ",
      "/// Send a local push notification to a device.\n/// - Parameter message: Message to send.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}\n\n/// Send a local push notification to a device.\n/// - Parameter message: Message to send.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}\n\n/// Send a local push notification to a device.\n/// - Parameter message: Message to send.\nfunc sendLocalPush(",
      "/// Shows the onboarding screen if it hasn't been shown yet.\n/// - Returns: `true` if the user hasn't seen the onboarding screen.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n/// Shows the onboarding screen if it hasn't been shown yet.\n/// - Returns: `true` if the user hasn't seen the onboarding screen.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n/// Shows the onboarding screen if it hasn't been shown yet.\n/// - Returns: `true` if the user hasn't seen the onboarding screen.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n/// Shows the onboarding screen if it hasn't been shown yet.\n/// - Returns: `true` if the user hasn't seen the onboarding screen.\nfunc shouldShowOnboarding() -> Bool {",
      "/// Saves the last viewed product to User Defaults.\n/// - Parameter productId: The product ID.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}\n\n## Notes:\n- Saves the last viewed product to User Defaults.\n- The `productId` is passed as a parameter.\n\n## Examples:\n- Save the last product viewed.\n- Save the last product viewed.\n- Save the last viewed product.\n\n## Related:\n- [Design your Swift codebase for a single developer](/design-swift-codebase-single-developer).\n- [Document your Swift codebase for a single developer](/document-swift-codebase-single-developer).\n- [Document your Swift codebase for multiple developers](/document-swift-codebase-multiple-developers).\n\n## Further reading:\n- [Writing Swift Documentation](https://developer.apple.com/library/archive/documentation/Swift/Conceptual/Swift_Programming_Language/WritingDocumentation.html#//apple_",
      "/// Displays a promo banner if it's been more than 24 hours since the last one.\n/// - Returns: Whether to show the promo banner.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\n## Notes:\n- This function shows a promo banner if it's been more than 24 hours since the last one.\n- It retrieves the last time the promo banner was shown from UserDefaults.\n- The function returns `true` if it's time to show the promo banner.\n\n## Tests:\n\nimport XCTest\n\nclass UserDefaultsTests: XCTestCase {\n    func testLastPromoShown() {\n        let userDefaults = UserDefaults.standard\n        userDefaults.set(Date(), forKey: \"lastPromoShown\")\n        XCTAssertEqual(userDefaults.object(forKey: \"lastPromoShown",
      "/// Converts coordinates to a string.\n/// - Parameters:\n///   - lat: The latitude.\n///   - lon: The longitude.\n/// - Returns: The coordinates as a string.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}\n\nFunction:\n\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}\n## Documentation:\n/// Converts coordinates to a string.\n/// - Parameters:\n///   - lat: The latitude.\n///   - lon: The longitude.\n/// - Returns: The coordinates as a string.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}\n\nFunction:\n\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"",
      "/// Returns `true` if the given `profile` contains all required keys.\n/// - Parameter profile: A dictionary of user profile data.\n/// - Returns: `true` if all keys are present and non-empty.\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}\n\n## Notes:\n- Use `///-` style comments.\n- Include parameter and return descriptions, and emphasize intent over implementation.\n- Return only the comment and the function.\n\n## Tests:\nimport XCTest\n\nclass IsUserProfileCompleteTests: XCTestCase {\n    func testExample() {\n        /// Returns `true` if the given `profile` contains all required keys.\n        /// - Parameter profile: A dictionary of user profile data.\n        /// - Returns: `true` if all keys are present and non-empty.\n        func isUserProfileComplete(profile: [String: String]) -> Bool {\n            let requiredKeys = [\"first",
      "/// Checks if a phone number is valid in Russia.\n/// - Parameter phone: The phone number to check.\n/// - Returns: `true` if the phone number is valid, `false` otherwise.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\n/// Checks if a phone number is valid in Russia.\n/// - Parameter phone: The phone number to check.\n/// - Returns: `true` if the phone number is valid, `false` otherwise.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\n/// Checks if a phone number is valid in Russia.\n/// - Parameter phone: The phone number to check.\n/// - Returns: `true` if the phone number is valid, `false` otherwise.\nfunc isValidRussian",
      "/// Returns stars based on rating.\n/// - Parameter rating: Rating from 0.0 to 1.0.\n/// - Returns: String with stars.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}\n\n/// Returns stars based on rating.\n/// - Parameter rating: Rating from 0.0 to 1.0.\n/// - Returns: String with stars.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}\n\n/// Returns stars based on rating.\n/// - Parameter rating: Rating from 0.0 to 1.0.\n",
      "/// Проверяет, подключён ли устройство к интернету.\n/// - Returns: `true`, если подключено.\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n\n/// Проверяет, подключён ли устройство к интернету.\n/// - Returns: `true`, если подключено.\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n\n/// Проверяет, подключён ли устройство к интернету.\n/// - Returns: `true`, если подключено.\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n\n/// Проверяет, подключён ли",
      "/// Возвращает строку с приветствием для доставки заказа.\n/// - Parameter deliveryDate: Дата доставки.\n/// - Returns: Строка с приветствием.\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"Сегодня\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"Завтра\"\n    } else {\n        return \"Позже\"\n    }\n}\n\n## Test:\n/// Возвращает строку с приветствием для доставки заказа.\n/// - Parameter deliveryDate: Дата доставки.\n/// - Returns: Строка с при",
      "/// Returns a string containing the hashtags for the given array of tags.\n/// - Parameter tags: An array of tags.\n/// - Returns: A string containing the hashtags.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}\n\n## Examples:\n/// The `hashtags` function returns a string containing the hashtags for the given array of tags.\n/// - Parameter tags: An array of tags.\n/// - Returns: A string containing the hashtags.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}\n\n/// The `hashtags` function returns a string containing the hashtags for the given array of tags.\n/// - Parameter tags: An array of tags.\n/// - Returns: A string containing the hashtags.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased",
      "/// Save the scroll offset in UserDefaults.\n/// - Parameter offset: The scroll offset.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}\n\n/// Return the scroll offset from UserDefaults.\n/// - Returns: The scroll offset.\nfunc getScrollOffset() -> Double? {\n    return UserDefaults.standard.double(forKey: \"productListScrollOffset\")\n}\n\n/// Save the scroll offset in UserDefaults.\n/// - Parameter offset: The scroll offset.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}\n\n/// Return the scroll offset from UserDefaults.\n/// - Returns: The scroll offset.\nfunc getScrollOffset() -> Double? {\n    return UserDefaults.standard.double(forKey: \"productListScrollOffset\")\n}\n\n/// Save the scroll offset in UserDefaults.\n/// - Parameter offset: The scroll offset.\nfunc saveSc",
      "/// Проверяет, находится ли точка внутри длины 30 км от центра\n/// - Parameters:\n///   - lat: Широта\n///   - lon: Долгота\n/// - Returns: true, если точка внутри диапазона\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // Москва\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}\n\n## Solution\n/// Проверяет, находится ли точка внутри длины 30 км от центра\n",
      "/// Generates a deep link for a given product ID.\n/// - Parameter productId: The product ID.\n/// - Returns: The deep link or nil if the ID is invalid.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\n/// Generates a deep link for a given product ID.\n/// - Parameter productId: The product ID.\n/// - Returns: The deep link or nil if the ID is invalid.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\n/// Generates a deep link for a given product ID.\n/// - Parameter productId: The product ID.\n/// - Returns: The deep link or nil if the ID is invalid.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\n/// Generates a deep link for a given product ID.",
      "/// Checks if the last viewed ID is different than the new ID.\n/// - Parameters:\n///   - lastViewedId: The last viewed ID.\n///   - newMessageId: The new message ID.\n/// - Returns: `true` if the IDs are different.\n\n/// Checks if the last viewed ID is different than the new ID.\n/// - Parameters:\n///   - lastViewedId: The last viewed ID.\n///   - newMessageId: The new message ID.\n/// - Returns: `true` if the IDs are different.\n\n/// Checks if the last viewed ID is different than the new ID.\n/// - Parameters:\n///   - lastViewedId: The last viewed ID.\n///   - newMessageId: The new message ID.\n/// - Returns: `true` if the IDs are different.\n\n/// Checks if the last viewed ID is different than the new ID.\n/// - Parameters:\n///   - lastViewedId: The last viewed ID.\n///   - newMessageId: The new message ID.\n",
      "/// Returns the percentage of progress from `current` to `target`.\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of progress.\n/// - Complexity: O(1).\n\n/// Returns the percentage of progress from `current` to `target`.\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of progress.\n/// - Complexity: O(1).\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}\n\n/// Returns the percentage of progress from `current` to `target`.\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of progress.\n/// - Complexity: O(1).\nfunc progressPercentage(current:",
      "/// Проверяет, является ли пользователь авторизованным.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}\n\nFunction:\n\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}\n## Documentation:\n/// Проверяет, является ли пользов",
      "/// Возвращает строку со своим именем, готовой для вставки в сообщение \"Доброе утро, <name>\".\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро, \\(name)\"\n    case 12..<18: return \"Добрый день, \\(name)\"\n    case 18..<23: return \"Добрый вечер, \\(name)\"\n    default: return \"Доброй ночи, \\(name)\"\n    }\n}\n\n## Documentation:\n/// Возвращает строку со своим именем, готовой для",
      "/// Formats a number to Russian currency.\n/// - Parameter amount: A number to format.\n/// - Returns: A string representation of the number.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"₽\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ₽\"\n}\n\nFunction:\n\nfunc isEven(_ number: Int) -> Bool {\n    return number % 2 == 0\n}\n## Documentation:\n/// Determines if a number is even.\n/// - Parameter number: A number to check.\n/// - Returns: `true` if the number is even, `false` otherwise.\nfunc isEven(_ number: Int) -> Bool {\n    return number % 2 == 0\n}\n\nFunction:\n\nfunc average(_ numbers: [Int]) -> Double {\n    guard !numbers.isEmpty else { return 0 }\n    return Double(numbers.",
      "///- sendLocalPush(message:)\n/// - Parameter message: The message to send\n/// - Returns: Nothing\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}\n\n## Solution\n\n///- sendLocalPush(message:)\n/// - Parameter message: The message to send\n/// - Returns: Nothing\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}\n\n## Challenge 2\n\nYou are documenting a Swift codebase.",
      "/// Show the onboarding screen if the user has not seen it yet.\n/// - Returns: `true` if the onboarding screen should be shown.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n## Notes:\n\n- Use the `///` comment style for all documentation.\n- Document only the function and its purpose.\n- Emphasize intent over implementation.\n\n## Tips:\n\n- Document a function once and add it to the project's `Documentation` enum.\n- Use the `///-` style for comments.\n- Don't document every function. Focus on the most important ones.\n\n## Challenges:\n\n- Write a comment for a function that reads a string from a file and returns its uppercase version.\n- Write a comment for a function that calculates the factorial of a number.\n- Write a comment for a function that checks if a number is even.\n\n## References:\n\n- [SwiftDoc](https://github.com/apple/swift-doc)\n- [SwiftDoc Examples](https://github.com",
      "/// Save the last product viewed in the app.\n/// - Parameter productId: The product ID.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}\n\nFunction:\n\nfunc printText(_ text: String) {\n    print(text)\n}\n## Documentation:\n/// Prints text to the console.\n/// - Parameter text: The text to print.\nfunc printText(_ text: String) {\n    print(text)\n}\n\nFunction:\n\nfunc printText(_ text: String) {\n    print(text)\n}\n## Documentation:\n/// Prints text to the console.\n/// - Parameter text: The text to print.\nfunc printText(_ text: String) {\n    print(text)\n}\n\nFunction:\n\nfunc printText(_ text: String) {\n    print(text)\n}\n## Documentation:\n/// Prints text to the console.\n/// - Parameter text: The text to print.\nfunc printText(_ text: String) {\n    print(text)\n}\n",
      "/// Returns whether or not to show a promo banner.\n/// - Returns: `true` if the promo banner should be shown.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\n## Explanation:\n/// Returns whether or not to show a promo banner.\n/// - Returns: `true` if the promo banner should be shown.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\n## Notes:\n/// - This function returns whether or not to show a promo banner.\n/// - The function checks the time since the last promo banner was shown.\n/// - The return value indicates whether or not to show the",
      "/// Converts coordinates to a string in the format `📍 <latitude>, <longitude>`.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}\n\n/// Converts coordinates to a string in the format `📍 <latitude>, <longitude>`.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}\n\n/// Converts coordinates to a string in the format `📍 <latitude>, <longitude>`.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}\n\n/// Converts coordinates to a string in the format `📍 <latitude>, <longitude>`.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\",",
      "/// Checks if a given user profile is complete.\n/// - Parameter profile: The user profile.\n/// - Returns: `true` if all required keys are present, `false` otherwise.\n/// - Complexity: O(n).\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}\n\n/// Checks if a given user profile is complete.\n/// - Parameter profile: The user profile.\n/// - Returns: `true` if all required keys are present, `false` otherwise.\n/// - Complexity: O(n).\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}\n\n/// Checks if a given user profile is complete.\n/// - Parameter profile: The user profile",
      "/// Проверяет, является ли строка разбитой на символы после точки начала строки, состоящей из числа с кодом 7 и 10 символов.\n/// - Parameter phone: Входная строка.\n/// - Returns: `true`, если строка является форматом телефона.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\n## Sample output\n/// Проверяет, является ли строка разбитой на символы посл",
      "/// Returns a string of filled and empty stars to represent a rating.\n/// - Parameter rating: The rating between 0 and 5.\n/// - Returns: A string of filled and empty stars.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}\n\n### Function:\n\n/// Returns a string of filled and empty stars to represent a rating.\n/// - Parameter rating: The rating between 0 and 5.\n/// - Returns: A string of filled and empty stars.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}\n\n### Function:\n\n///",
      "/// Проверяет, существует ли интернет.\n/// - Returns: `true`, если интернет подключен.\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n\n/// Проверяет, существует ли интернет.\n/// - Returns: `true`, если интернет подключен.\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n\n/// Проверяет, существует ли интернет.\n/// - Returns: `true`, если интернет подключен.\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n\n/// Проверяет, существует ли интернет.\n/// - Returns: `true`, ес",
      "/// Возвращает строку с рассчитанным статусом доставки по дате.\n/// - Parameter deliveryDate: Дата доставки.\n/// - Returns: Строка с рассчитанным статусом доставки.\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"Сегодня\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"Завтра\"\n    } else {\n        return \"Позже\"\n    }\n}\n\n### Правила\n\n- Объявляйте функцию с именем возвращаемого типа.\n- Добавьте ст",
      "/// Converts an array of strings into a string with hashtags.\n/// - Parameter tags: An array of strings.\n/// - Returns: A string with hashtags.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}\n\nFunction:\n\nfunc count(_ numbers: [Int]) -> Int {\n    return numbers.count\n}\n## Documentation:\n/// Counts the number of elements in an array.\n/// - Parameter numbers: An array of integers.\n/// - Returns: The number of elements in the array.\nfunc count(_ numbers: [Int]) -> Int {\n    return numbers.count\n}\n\nFunction:\n\nfunc sum(_ numbers: [Int]) -> Int {\n    return numbers.reduce(0, +)\n}\n## Documentation:\n/// Calculates the sum of an array of integers.\n/// - Parameter numbers: An array of integers.\n/// - Returns: The sum of the array.\nfunc sum(_ numbers: [Int]) -> Int {\n    return numbers.reduce(0",
      "/// Saves the current scroll offset for the ProductListView.\n/// - Parameter offset: The offset to save.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}\n\n### Function:\n\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}\n## Documentation:\n/// Saves the current scroll offset for the ProductListView.\n/// - Parameter offset: The offset to save.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}\n\n### Function:\n\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}\n## Documentation:\n/// Saves the current scroll offset for the ProductListView.\n/// - Parameter offset: The offset to save.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults",
      "/// Проверяет, входит ли полученная точка в доставку.\n/// - Parameters:\n///   - lat: Широта.\n///   - lon: Долгота.\n/// - Returns: true, если точка внутри доставки.\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // Москва\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}\n\n## Test:\n/// Проверяет, входит ли полученная точка в доставку.\n/// - Parameters:\n///  ",
      "/// Returns a product Deeplink.\n/// - Parameter productId: The product ID.\n/// - Returns: A Deeplink.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\n/// Returns a product Deeplink.\n/// - Parameter productId: The product ID.\n/// - Returns: A Deeplink.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\n/// Returns a product Deeplink.\n/// - Parameter productId: The product ID.\n/// - Returns: A Deeplink.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\n/// Returns a product Deeplink.\n/// - Parameter productId: The product ID.\n/// - Returns: A Deeplink.\nfunc generateProductDeeplink(productId: String)",
      "/// Determines if a new message has been received since the last time the user viewed it.\n/// - Parameters:\n///   - lastViewedId: The last time the user viewed the message.\n///   - newMessageId: The new message ID.\n/// - Returns: `true` if the new message has been received since the last time the user viewed it.\n/// - Complexity: O(1)\n\n/// Determines if a new message has been received since the last time the user viewed it.\n/// - Parameters:\n///   - lastViewedId: The last time the user viewed the message.\n///   - newMessageId: The new message ID.\n/// - Returns: `true` if the new message has been received since the last time the user viewed it.\n/// - Complexity: O(1)\n\n/// Determines if a new message has been received since the last time the user viewed it.\n/// - Parameters:\n///   - lastViewedId: The last time the user viewed the message.\n///   - newMessageId: The new message ID.\n/// - Returns",
      "/// Calculates the percentage of completion for a progress bar.\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of completion.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}\n\n### 1.1.1. Parameter\n\n/// Calculates the percentage of completion for a progress bar.\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of completion.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}\n\n### 1.1.2. Return\n\n/// Calculates the percentage of completion for a progress bar.\n/// - Parameters:\n///",
      "/// Returns a URL to the Terms and Conditions page for the given locale.\n/// - Parameter locale: The locale of the page.\n/// - Returns: A URL to the page.\nfunc termsAndConditionsURL(locale: String) -> URL? {\n    let urlString = \"https://example.com/terms_\\(locale).html\"\n    return URL(string: urlString)\n}\n\nFunction:\n\nfunc loadImage(_ url: URL) -> Data? {\n    return try? Data(contentsOf: url)\n}\n## Documentation:\n/// Loads an image from a URL.\n/// - Parameter url: The URL to the image.\n/// - Returns: The image data, or `nil`.\nfunc loadImage(_ url: URL) -> Data? {\n    return try? Data(contentsOf: url)\n}\n\nFunction:\n\nfunc someFunction(_ someParameter: String, _ anotherParameter: Int) -> Bool {\n    return true\n}\n## Documentation:\n/// Returns `true` if the given parameters are both `String` and `Int`.\n/// - Parameters:\n///   - someParameter: The",
      "///-isEventStarted(at:)\n///Returns `true` if the given date is after today.\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}\n\nFunction:\n\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}\n## Documentation:\n///-isEventStarted(at:)\n///Returns `true` if the given date is after today.\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}\n\nFunction:\n\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}\n## Documentation:\n///-isEventStarted(at:)\n///Returns `true` if the given date is after today.\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}\n\nFunction:\n\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}\n## Documentation:\n///-isEventStarted(",
      "/// Save the current user's theme to UserDefaults.\n/// - Parameter theme: The theme to save.\nfunc saveUserTheme(_ theme: String) {\n    UserDefaults.standard.set(theme, forKey: \"appTheme\")\n}\n\n## Notes:\n/// The current user's theme is saved to UserDefaults.\n\n## Examples:\n/// This function saves the current user's theme to UserDefaults.\n/// - Parameter theme: The theme to save.\nfunc saveUserTheme(_ theme: String) {\n    UserDefaults.standard.set(theme, forKey: \"appTheme\")\n}\n\n## Related:\n/// [`UserDefaults`](https://developer.apple.com/documentation/user_interface_engineering/user_defaults)\n/// [`UserDefaults.standard`](https://developer.apple.com/documentation/user_interface_engineering/user_defaults/standard)\n/// [`set(_:forKey:)`](https://developer.apple.com/documentation/user_interface_engineering/user_defaults/set_forkey",
      "/// Get the theme of the user's current device.\n/// - Returns: The theme, or `nil` if it cannot be determined.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}\n\n/// Get the theme of the user's current device.\n/// - Returns: The theme, or `nil` if it cannot be determined.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}\n\n/// Get the theme of the user's current device.\n/// - Returns: The theme, or `nil` if it cannot be determined.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}\n\n/// Get the theme of the user's current device.\n/// - Returns: The theme, or `nil` if it cannot be determined.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")",
      "/// Clears the user session by removing all stored user data from the user defaults.\n/// - Parameter keys: The keys to remove.\nfunc clearUserSession(_ keys: [String]) {\n    keys.forEach { UserDefaults.standard.removeObject(forKey: $0) }\n}\n\nFunction:\n\nfunc getUserProfile() -> UserProfile? {\n    guard let profileData = UserDefaults.standard.data(forKey: \"userProfile\") else { return nil }\n    return try? JSONDecoder().decode(UserProfile.self, from: profileData)\n}\n## Documentation:\n\n/// Gets the user profile from the user defaults.\n/// - Returns: The user profile or `nil`.\nfunc getUserProfile() -> UserProfile? {\n    guard let profileData = UserDefaults.standard.data(forKey: \"userProfile\") else { return nil }\n    return try? JSONDecoder().decode(UserProfile.self, from: profileData)\n}\n\nFunction:\n\nfunc getUserProfile(_ completion: @escaping (UserProfile?) -> Void) {\n    guard let profileData = UserDefault",
      "/// Генерирует отзыв для системы.\n/// - Returns: Отзыв в формате Markdown.\nfunc generateFeedbackTemplate() -> String {\n    let systemVersion = UIDevice.current.systemVersion\n    let model = UIDevice.current.model\n    return \"Устройство: \\(model)\\nВерсия iOS: \\(systemVersion)\\nВаш отзыв: \"\n}\n\nFunction:\n\nfunc generateFeedbackTemplate(_ systemVersion: String, model: String) -> String {\n    return \"Устройство: \\(model)\\nВерсия iOS: \\(systemVersion)\\nВаш отзыв: \"\n}\n## Documentation:\n/// Генерирует отзыв для системы.\n/// - Parameters:\n///   - systemVersion: Версия iOS.\n///   - model: Модель устройст",
      "/// Determines if a count value is greater than the free limit.\n/// - Parameter count: The count value.\n/// - Returns: `true` if the count is greater than the free limit.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n\n/// Determines if a count value is greater than the free limit.\n/// - Parameter count: The count value.\n/// - Returns: `true` if the count is greater than the free limit.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n\n/// Determines if a count value is greater than the free limit.\n/// - Parameter count: The count value.\n/// - Returns: `true` if the count is greater than the free limit.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n\n/// Determines if a count value is greater than the free limit.\n/// - Parameter count: The count value.\n//",
      "/// Formats a date to a string in the format \"dd MMM yyyy\".\n/// - Parameter date: The date to format.\n/// - Returns: A string representation of the date.\nfunc formatOrderDate(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd MMM yyyy\"\n    return formatter.string(from: date)\n}\n\n## Markdown:\n# FormatOrderDate(_:)\n/// Formats a date to a string in the format \"dd MMM yyyy\".\n/// - Parameter date: The date to format.\n/// - Returns: A string representation of the date.\nfunc formatOrderDate(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd MMM yyyy\"\n    return formatter.string(from: date)\n}\n\n## Swift Playgrounds:\nPlaygroundPage.current.setLiveView(formatOrderDate(Date()))\n\n## SwiftUI:\n@State private var date = Date()\n\nButton(action: {\n    date = Date()\n})",
      "/// Returns the number of days between two dates.\n/// - Parameters:\n///   - from: The start date.\n///   - to: The end date.\n/// - Returns: The number of days.\nfunc daysBetween(_ from: Date, _ to: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: from, to: to).day ?? 0\n}\n\nFunction:\n\nfunc find(_ array: [Int], _ value: Int) -> Int? {\n    return array.first(where: { $0 == value })\n}\n## Documentation:\n/// Finds the first occurrence of a value in an array.\n/// - Parameters:\n///   - array: The array to search.\n///   - value: The value to find.\n/// - Returns: The index of the value, or `nil` if not found.\nfunc find(_ array: [Int], _ value: Int) -> Int? {\n    return array.first(where: { $0 == value })\n}\n\nFunction:\n\nfunc find(_ array: [Int], _ value: Int",
      "/// Saves the last seen banner ID to UserDefaults.\n/// - Parameter id: The ID of the last seen banner.\n/// - Returns: Nothing.\n/// - Requires: A valid banner ID.\nfunc saveLastSeenBannerId(_ id: String) {\n    UserDefaults.standard.set(id, forKey: \"lastSeenBannerId\")\n}\n\n### Example\n\n/// Saves the last seen banner ID to UserDefaults.\n/// - Parameter id: The ID of the last seen banner.\n/// - Returns: Nothing.\n/// - Requires: A valid banner ID.\nfunc saveLastSeenBannerId(_ id: String) {\n    UserDefaults.standard.set(id, forKey: \"lastSeenBannerId\")\n}\n\n## Documentation:\n/// Saves the last seen banner ID to UserDefaults.\n/// - Parameter id: The ID of the last seen banner.\n/// - Returns: Nothing.\n/// - Requires: A valid banner ID.\nfunc saveLastSeenBannerId(_ id: String) {\n    UserDefaults",
      "/// Refreshes the cache when the last update is more than six hours old.\n/// - Parameter since: The last update.\n/// - Returns: `true` if the cache should be refreshed.\nfunc shouldRefreshCache(since lastUpdate: Date) -> Bool {\n    return Date().timeIntervalSince(lastUpdate) > 6 * 3600\n}\n\n## Notes:\n/// Refreshes the cache when the last update is more than six hours old.\n/// - Parameter since: The last update.\n/// - Returns: `true` if the cache should be refreshed.\nfunc shouldRefreshCache(since lastUpdate: Date) -> Bool {\n    return Date().timeIntervalSince(lastUpdate) > 6 * 3600\n}\n\n## Details:\n/// Refreshes the cache when the last update is more than six hours old.\n/// - Parameter since: The last update.\n/// - Returns: `true` if the cache should be refreshed.\nfunc shouldRefreshCache(since lastUpdate: Date) -> Bool {\n    return Date().timeIntervalSince(lastUpdate) > 6",
      "/// Проверяет, авторизован ли пользователь.\n/// - Returns: `true`, если пользователь авторизован, иначе `false`.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}\n\n## Test\nimport XCTest\n\nclass IsUserLoggedInTests: XCTestCase {\n    func testIsUserLoggedIn() {\n        let isUserLoggedIn = isUserLoggedIn()\n        XCTAssertEqual(isUserLoggedIn, true)\n    }\n}\n\n## Критерии реализации\n\nРеализуйте ф",
      "/// Checks if a user is a new registrant.\n/// - Parameter registrationDate: The registration date.\n/// - Returns: `true` if the user is new, `false` otherwise.\n/// - Complexity: O(1).\nfunc isNewUser(registrationDate: Date) -> Bool {\n    return Date().timeIntervalSince(registrationDate) < 7 * 86400\n}\n\nFunction:\n\nfunc sumOfSquares(_ numbers: [Int]) -> Int {\n    return numbers.map { $0 * $0 }.reduce(0, +)\n}\n## Documentation:\n/// Calculates the sum of the squares of a list of numbers.\n/// - Parameter numbers: The numbers to square and sum.\n/// - Returns: The sum of the squares.\n/// - Complexity: O(n).\nfunc sumOfSquares(_ numbers: [Int]) -> Int {\n    return numbers.map { $0 * $0 }.reduce(0, +)\n}\n\nFunction:\n\nfunc isPrime(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n   ",
      "/// Returns the number of times the app has been launched.\n/// - Returns: The number of times the app has been launched.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\n/// Returns the number of times the app has been launched.\n/// - Returns: The number of times the app has been launched.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\n/// Returns the number of times the app has been launched.\n/// - Returns: The number of times the app has been launched.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\n/// Returns the number of times the app has been launched.\n/// - Returns: The number of times the app has been launched.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\n/// Returns the number of times the app has been launched",
      "/// Increments the app's launch count.\n/// - Returns: The new launch count.\nfunc incrementAppLaunchCount() {\n    let count = getAppLaunchCount() + 1\n    UserDefaults.standard.set(count, forKey: \"launchCount\")\n}\n\n/// Returns the current launch count.\n/// - Returns: The current launch count.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\n/// Increments the app's launch count.\n/// - Returns: The new launch count.\nfunc incrementAppLaunchCount() {\n    let count = getAppLaunchCount() + 1\n    UserDefaults.standard.set(count, forKey: \"launchCount\")\n}\n\n/// Returns the current launch count.\n/// - Returns: The current launch count.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\n/// Increments the app's launch count.\n/// - Returns: The new launch count.\nfunc increment",
      "/// Checks whether Face ID is available on the device.\n/// - Returns: `true` if Face ID is available.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}\n\n## Discussion:\n/// Checks whether Face ID is available on the device.\n/// - Returns: `true` if Face ID is available.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}\n\n## Best Practices:\n- Use ///-style Swift comments.\n- Include parameter and return descriptions, and emphasize intent over implementation.\n- Return only the comment and the function.\n\n## Example:\n/// Checks whether Face ID is available on the device.\n/// - Returns: `true` if Face ID",
      "/// Возвращает строку с именем месяца в русском языке, если он принадлежит диапазону месяцев.\n/// - Parameter month: Месяц в целочисленном формате.\n/// - Returns: Строка с именем месяца в русском языке.\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.monthSymbols[safe: month - 1] ?? \"\"\n}\n\n/// Возвращает строку с именем месяца в русском языке, если он принадле",
      "/// Returns the URL for getting orders for a user.\n/// - Parameter userId: The ID of the user.\n/// - Returns: The URL for getting the user's orders.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}\n\n/// Returns the URL for getting orders for a user.\n/// - Parameter userId: The ID of the user.\n/// - Returns: The URL for getting the user's orders.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}\n\n/// Returns the URL for getting orders for a user.\n/// - Parameter userId: The ID of the user.\n/// - Returns: The URL for getting the user's orders.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}\n\n/// Returns the",
      "/// Returns whether dark mode is enabled.\n/// - Returns: `true` if dark mode is enabled, `false` otherwise.\nfunc isDarkModeEnabled() -> Bool {\n    return UserDefaults.standard.bool(forKey: \"darkMode\")\n}\n\nFunction:\n\nfunc loadImage(_ url: URL, completion: @escaping (Data?, Error?) -> Void) {\n    URLSession.shared.dataTask(with: url) { data, response, error in\n        DispatchQueue.main.async {\n            completion(data, error)\n        }\n    }.resume()\n}\n## Documentation:\n/// Loads an image from a URL.\n/// - Parameters:\n///   - url: The URL of the image.\n///   - completion: A closure to be called when the image is loaded.\nfunc loadImage(_ url: URL, completion: @escaping (Data?, Error?) -> Void) {\n    URLSession.shared.dataTask(with: url) { data, response, error in\n        DispatchQueue.main.async {\n            completion(data, error)\n        }\n    }.resume()\n}",
      "/// Checks if location access has been granted.\n/// - Returns: `true` if location access is granted, `false` otherwise.\nfunc isLocationAccessGranted() -> Bool {\n    return CLLocationManager.authorizationStatus() == .authorizedWhenInUse || CLLocationManager.authorizationStatus() == .authorizedAlways\n}\n\n/// Checks if location access has been granted.\n/// - Returns: `true` if location access is granted, `false` otherwise.\nfunc isLocationAccessGranted() -> Bool {\n    return CLLocationManager.authorizationStatus() == .authorizedWhenInUse || CLLocationManager.authorizationStatus() == .authorizedAlways\n}\n\n/// Checks if location access has been granted.\n/// - Returns: `true` if location access is granted, `false` otherwise.\nfunc isLocationAccessGranted() -> Bool {\n    return CLLocationManager.authorizationStatus() == .authorizedWhenInUse || CLLocationManager.authorizationStatus() == .authorizedAlways\n}\n\n/// Checks if location access has been granted.\n/// - Returns: `true` if location access is granted, `false",
      "/// Formats a number of seconds into a string with leading zeros.\n/// - Parameter seconds: The number of seconds.\n/// - Returns: A string with leading zeros.\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n}\n\nFunction:\n\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n}\n## Documentation:\n/// Formats a number of seconds into a string with leading zeros.\n/// - Parameter seconds: The number of seconds.\n/// - Returns: A string with leading zeros.\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n}\n\nFunction:\n\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n",
      "/// Checks if the number of attempts exceeds the limit.\n/// - Parameter attempts: The number of attempts.\n/// - Returns: `true` if the limit was exceeded.\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}\n\nFunction:\n\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}\n## Documentation:\n/// Checks if the number of attempts exceeds the limit.\n/// - Parameter attempts: The number of attempts.\n/// - Returns: `true` if the limit was exceeded.\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}\n\nFunction:\n\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}\n## Documentation:\n/// Checks if the number of attempts exceeds the limit.\n/// - Parameter attempts: The number of attempts.\n/// - Returns: `true` if the limit was exceeded.\nfunc isPin",
      "/// Документирует функцию для получения текста ответа на вопрос: На сколько доставлено.\n/// - Parameter status: Код статуса доставки.\n/// - Returns: Текст ответа.\nfunc deliveryStatusText(for status: String) -> String {\n    switch status {\n    case \"pending\": return \"Ожидает обработки\"\n    case \"shipped\": return \"Отправлено\"\n    case \"delivered\": return \"Доставлено\"\n    default: return \"Неизвестно\"\n    }\n}\n\n## Discussion:\n\nКомментарии к функциям помогают программистам понять, какую",
      "/// Resets the app data.\n/// - Returns: Nothing.\nfunc resetAppData() {\n    if let appDomain = Bundle.main.bundleIdentifier {\n        UserDefaults.standard.removePersistentDomain(forName: appDomain)\n    }\n}\n\nFunction:\n\nfunc getUserData(_ key: String) -> String? {\n    guard let data = UserDefaults.standard.object(forKey: key) as? Data else { return nil }\n    return String(data: data, encoding: .utf8)\n}\n## Documentation:\n/// Returns the user data with the given key.\n/// - Parameter key: The key of the data.\n/// - Returns: The data or `nil`.\nfunc getUserData(_ key: String) -> String? {\n    guard let data = UserDefaults.standard.object(forKey: key) as? Data else { return nil }\n    return String(data: data, encoding: .utf8)\n}\n\nFunction:\n\nfunc createUserData(_ key: String, value: String) {\n    UserDefaults.standard.set(value.data(using:",
      "/// Pings a server and returns whether the response indicates a successful connection.\nfunc pingServer(completion: @escaping (Bool) -> Void) {\n    let url = URL(string: \"https://api.example.com/ping\")!\n    URLSession.shared.dataTask(with: url) { _, response, error in\n        let httpResponse = response as? HTTPURLResponse\n        completion(httpResponse?.statusCode == 200 && error == nil)\n    }.resume()\n}\n\nFunction:\n\nfunc checkForDuplicates<T: Hashable>(_ array: [T]) -> Bool {\n    return Set(array).count == array.count\n}\n## Documentation:\n/// Returns `true` if the given array contains no duplicates.\nfunc checkForDuplicates<T: Hashable>(_ array: [T]) -> Bool {\n    return Set(array).count == array.count\n}\n\nFunction:\n\nfunc isValidPassword(_ password: String) -> Bool {\n    return password.count >= 8 && password.containsNumber && password.containsLowercaseLetter && password.containsUpp",
      "/// Saves the current user's preferred language.\n/// - Parameter languageCode: The language code.\nfunc savePreferredLanguage(_ languageCode: String) {\n    UserDefaults.standard.set(languageCode, forKey: \"preferredLanguage\")\n}\n\n/// Returns the current user's preferred language.\n/// - Returns: The language code.\nfunc preferredLanguage() -> String? {\n    return UserDefaults.standard.value(forKey: \"preferredLanguage\") as? String\n}\n\n/// Returns the current user's preferred language.\n/// - Returns: The language code.\nfunc preferredLanguage() -> String? {\n    return UserDefaults.standard.value(forKey: \"preferredLanguage\") as? String\n}\n\n/// Saves the current user's preferred language.\n/// - Parameter languageCode: The language code.\nfunc savePreferredLanguage(_ languageCode: String) {\n    UserDefaults.standard.set(languageCode, forKey: \"preferredLanguage\")\n}\n\n/// Saves the current user's preferred language.\n/// - Parameter languageCode: The language code.\nfunc savePreferred",
      "/// Возвращает предпочтительный язык.\n/// - Returns: Предпочтительный язык.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"ru\"\n}\n\nFunction:\n\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"ru\"\n}\n## Documentation:\n/// Возвращает предпочтительный язык.\n/// - Returns: Предпочтительный язык.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"ru\"\n}\n\nFunction:\n\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\")",
      "/// Checks if a text contains a non-integer number.\n/// - Parameter text: The text to check.\n/// - Returns: `true`, if the text contains a non-integer number.\nfunc isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor(number) != number\n    }\n    return false\n}\n\n## Discussion:\nThis is a simple function that checks if a string contains a non-integer number. It does so by converting the string to a double, and then checking if the result is equal to the floor of the double.\n\nThe function has a single parameter, `text`, which is the string to check. It returns a boolean value, indicating whether the string contains a non-integer number.\n\nThe function uses the `Double` type to convert the string to a double. This is because `Double` is a floating-point type, which can represent decimal numbers more accurately than `Int` or `Float`.\n\nThe function then uses the `floor` method to round down the double to the nearest integer. This is done to ensure that the result is always an integer, even if the original number was",
      "/// - Parameter character: The character to repeat.\n/// - Parameter count: The number of times to repeat the character.\n/// - Returns: A string containing the repeated character.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}\n\n/// - Parameter character: The character to repeat.\n/// - Parameter count: The number of times to repeat the character.\n/// - Returns: A string containing the repeated character.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}\n\n/// - Parameter character: The character to repeat.\n/// - Parameter count: The number of times to repeat the character.\n/// - Returns: A string containing the repeated character.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}\n\n/// - Parameter character: The character to repeat.\n/// - Parameter count: The number of times to repeat the character.\n",
      "/// - Parameter text: The string to check.\n/// - Parameter array: The array of strings to search in.\n/// - Returns: `true` if the string is unique in the array.\n/// - Complexity: O(N), where N is the number of elements in the array.\nfunc isUniqueString(_ text: String, in array: [String]) -> Bool {\n    return array.filter { $0 == text }.count == 1\n}\n\n/// Checks if a string is unique in an array.\n/// - Parameters:\n///   - text: The string to check.\n///   - array: The array of strings to search in.\n/// - Returns: `true` if the string is unique in the array.\nfunc isUniqueString(_ text: String, in array: [String]) -> Bool {\n    return array.filter { $0 == text }.count == 1\n}\n\n/// - Parameters:\n///   - text: The string to check.\n///   - array: The array of strings to search in.\n/// - Returns: `true` if the string is unique in",
      "/// Returns a rounded number with the specified number of decimals.\n/// - Parameters:\n///   - text: The text to round.\n///   - decimals: The number of decimals to round to.\n/// - Returns: A rounded number.\nfunc roundedNumber(from text: String, decimals: Int) -> Double? {\n    guard let number = Double(text) else { return nil }\n    return round(number * pow(10, Double(decimals))) / pow(10, Double(decimals))\n}\n\n### Function:\n\nfunc roundedNumber(from text: String, decimals: Int) -> Double? {\n    guard let number = Double(text) else { return nil }\n    return round(number * pow(10, Double(decimals))) / pow(10, Double(decimals))\n}\n\n### Documentation:\n/// Returns a rounded number with the specified number of decimals.\n/// - Parameters:\n///   - text: The text to round.\n///   - decimals: The number of decimals to round to.\n/// - Returns: A rounded number.\nfunc roundedNumber(from text:",
      "/// Extracts all digits in order from a string.\n/// - Parameter text: The string to process.\n/// - Returns: The string without non-numeric characters.\nfunc extractDigitsInOrder(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n\n## Documenting a Swift function\n\nYou are documenting a Swift codebase. Given a function and a short description of where and how it is used, write a documentation comment that helps future developers understand its purpose.\nUse ///-style Swift comments.\nInclude parameter and return descriptions, and emphasize intent over implementation.\nReturn only the comment and the function.\n\nFunction:\n\nfunc extractDigitsInOrder(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n## Documentation:\n/// Extracts all digits in order from a string.\n/// - Parameter text: The string to process.\n/// - Returns: The string without non-numeric characters.\nfunc extractDigitsInOrder(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n\n## Document",
      "/// Converts a string to a cobol-case-formatted string.\n/// - Parameter text: The text to convert.\n/// - Returns: A cobol-case-formatted string.\nfunc toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}\n\n## Why?\n\n/// Converts a string to a cobol-case-formatted string.\n/// - Parameter text: The text to convert.\n/// - Returns: A cobol-case-formatted string.\nfunc toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}\n",
      "/// Removes all occurrences of characters in a `String` from another `String`.\n/// - Parameters:\n///   - text: The text to remove characters from.\n///   - charactersToRemove: The characters to remove.\n/// - Returns: A `String` with all occurrences of characters in `charactersToRemove` removed.\nfunc removeCharactersFromString(_ text: String, charactersToRemove: String) -> String {\n    return text.filter { !charactersToRemove.contains($0) }\n}\n\n/// Removes all occurrences of characters in a `String` from another `String`.\n/// - Parameters:\n///   - text: The text to remove characters from.\n///   - charactersToRemove: The characters to remove.\n/// - Returns: A `String` with all occurrences of characters in `charactersToRemove` removed.\nfunc removeCharactersFromString(_ text: String, charactersToRemove: String) -> String {\n    return text.filter { !charactersToRemove.contains($0) }\n}\n\n/// Removes all occurrences of characters in a `String` from another `String`.",
      "/// Returns `true` if the input string is a whole number.\n/// - Parameter text: The text to check.\n/// - Returns: `true` if the string represents a whole number, `false` otherwise.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}\n\n## Example:\n/// Returns `true` if the input string is a whole number.\n/// - Parameter text: The text to check.\n/// - Returns: `true` if the string represents a whole number, `false` otherwise.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}\n\n/// Returns `true` if the input string is a whole number.\n/// - Parameter text: The text to check.\n/// - Returns: `true` if the string represents a whole number, `false` otherwise.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}\n\n## Challenge:\nWrite a function to determine if a string is a whole number.\n\n**Hint:** Use",
      "/// Returns `true` if `text` contains the given `substring`.\n/// - Parameters:\n///   - substring: The substring to search for.\n///   - text: The text to search in.\n/// - Returns: `true` if the substring is found, `false` otherwise.\nfunc containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n}\n\n## Example\n\nIn this example, we have a function that checks if a given string contains a substring. The function has a short description of what it does, and includes a parameter and return description.\n\n### Example:\n\n/// Returns `true` if `text` contains the given `substring`.\n/// - Parameters:\n///   - substring: The substring to search for.\n///   - text: The text to search in.\n/// - Returns: `true` if the substring is found, `false` otherwise.\nfunc containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n",
      "/// Returns a list of words in the given text, capitalized.\nfunc stringToCapitalizedWords(_ text: String) -> [String] {\n    return text.split(separator: \" \").map { $0.capitalized }\n}\n\nFunction:\n\nfunc countWords(_ text: String) -> Int {\n    return text.split(separator: \" \").count\n}\n## Documentation:\n/// Counts the number of words in the given text.\nfunc countWords(_ text: String) -> Int {\n    return text.split(separator: \" \").count\n}\n\nFunction:\n\nfunc calculate(_ value: Double, _ power: Int) -> Double {\n    return pow(value, power)\n}\n## Documentation:\n/// Calculates the value of a number raised to a power.\nfunc calculate(_ value: Double, _ power: Int) -> Double {\n    return pow(value, power)\n}\n\nFunction:\n\nfunc isEven(_ number: Int) -> Bool {\n    return number % 2 == 0\n}\n## Documentation:\n/// Determines whether a number is even.\nfunc isEven(_",
      "/// Converts a string to alternating case.\n/// - Parameter text: The input string.\n/// - Returns: The converted string.\nfunc alternatingCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, character) in\n        index % 2 == 0 ? character.lowercased() : character.uppercased()\n    })\n}\n\n## Notes:\n\n* The `enumerated()` method is useful for converting a string to alternating case.\n* This function is useful for converting text to alternating case.\n* The `enumerated()` method returns an array of tuples, where each tuple contains an index and a character.\n* The `map()` function applies a given closure to each element of the array and returns a new array.\n* The `%` operator returns the remainder of a division operation.\n* The `%` operator is useful for converting a number to alternating case.\n\n## References:\n\n* [Swift Docs](https://docs.swift.org/swift-book/ReferenceManual/Concepts/Comments.html)\n* [Enumerated](https://developer.apple.com",
      "/// Finds the first occurrence of a substring in a string, returning the index of the first character.\n/// - Parameters:\n///   - substring: The substring to search for.\n///   - text: The string to search.\n/// - Returns: The index of the first occurrence of the substring, or `nil` if not found.\nfunc indexOfSubstring(_ substring: String, in text: String) -> Int? {\n    return text.range(of: substring)?.lowerBound.utf16Offset(in: text)\n}\n\n## Note\n\n/// Finds the first occurrence of a substring in a string, returning the index of the first character.\n/// - Parameters:\n///   - substring: The substring to search for.\n///   - text: The string to search.\n/// - Returns: The index of the first occurrence of the substring, or `nil` if not found.\nfunc indexOfSubstring(_ substring: String, in text: String) -> Int? {\n    return text.range(of: substring)?.lowerBound.utf16",
      "/// Returns `true` if the given text is a palindrome, ignoring case, and contains only letters.\nfunc isAlphaOnlyPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}\n\nFunction:\n\nfunc isPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}\n## Documentation:\n/// Returns `true` if the given text is a palindrome, ignoring case, and contains only letters.\nfunc isPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}\n\nFunction:\n\nfunc isAlphaOnlyPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}\n## Documentation:\n",
      "/// Extracts uppercase letters from a string.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}\n\n/// Extracts uppercase letters from a string.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}\n\n/// Extracts uppercase letters from a string.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}\n\n/// Extracts uppercase letters from a string.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}\n\n/// Extracts uppercase letters from a string.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}\n\n/// Extracts uppercase letters from a string.\nfunc extractUppercaseLetters(from text: String) ->",
      "/// Returns `true` if the string is a binary number.\n/// - Parameter text: The string to test.\n/// - Returns: `true` if all characters are either `0` or `1`.\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}\n\nFunction:\n\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}\n## Documentation:\n/// Returns `true` if the string is a binary number.\n/// - Parameter text: The string to test.\n/// - Returns: `true` if all characters are either `0` or `1`.\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}\n\nFunction:\n\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" ||",
      "/// Capitalizes the first letter of a string.\n/// - Parameter text: The string to capitalize.\n/// - Returns: The capitalized string.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}\n\n## What you should see:\n/// Capitalizes the first letter of a string.\n/// - Parameter text: The string to capitalize.\n/// - Returns: The capitalized string.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}\n\n## Why:\n/// Swift documentation comments are a convenient way to provide a quick summary of a function's purpose and usage.\n/// - Parameter text: The string to capitalize.\n/// - Returns: The capitalized string.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}\n\n",
      "/// Converts a string to an array of characters.\n/// - Parameter text: The text to convert.\n/// - Returns: An array of characters.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}\n\n### In-Depth:\n\nSwift's documentation comments are simple to write and easy to read.\n\nA Swift function is documented by writing a single /// comment at the beginning of the function.\n\nThe first line of the comment should describe the function's purpose.\n\nYou can use the following keywords to describe the function:\n\n- Parameter: The name of a parameter.\n- Return: The name of the function's return value.\n- Where: The name of the function's scope.\n\nThe second line of the comment should describe the function's parameters, and the third line should describe the function's return value.\n\nYou can use the following keywords to describe the parameters:\n\n- Parameter: The name of a parameter.\n- Return: The name of the function's return value.\n\nThe following example shows how to write a function's documentation comments.\n\nfunc stringToCharArray(_ text:",
      "/// Repeats a string a specified number of times.\n/// - Parameters:\n///   - text: The string to repeat.\n///   - count: The number of times to repeat the string.\n/// - Returns: A new string with the specified text repeated count times.\n/// - Example:\n///   - repeatString(\"Hello\", count: 3)\n///     /// \"HelloHelloHello\"\n\n/// - Example:\n///   - repeatString(\"World\", count: 2)\n///     /// \"WorldWorld\"\n\n/// - Example:\n///   - repeatString(\" \", count: 3)\n///     /// \" \"\n/// - Example:\n///   - repeatString(\"!\", count: 1)\n///     /// \"!\"\n\n/// - Example:\n///   - repeatString(\"!\", count: 10)\n///     /// \"!!!!!!!!!\"\n\n/// - Example:\n///   - repeatString(\"Hello\", count: 3)\n///     /// \"HelloHelloHello\"\n\n/// - Example",
      "/// Returns `true` if the given string is a valid time (e.g. \"13:30\").\n/// - Parameter text: The time to validate.\n/// - Returns: `true` if the time is valid.\nfunc isValidTime(_ text: String) -> Bool {\n    let pattern = \"^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$\"\n    return matchesRegex(text, pattern: pattern)\n}\n\n## How it works\n\nThe function has a single parameter, a string representing a time in the format \"HH:MM\", and a return type of `Bool`.\n\nThe function body contains a single statement that checks whether the input matches a regex pattern.\n\nThe regex pattern is defined in the function's comment, using the `///-` style.\n\nThe function returns `true` if the input matches the pattern, and `false` otherwise.\n\n## Tips\n\nWrite a single comment that explains the function's purpose and behavior.\n\nExplain the purpose of each parameter in the function's comment.\n\nUse the `///-",
      "/// Extracts digits and dashes from a string.\n/// - Parameter text: The string to process.\n/// - Returns: A string with digits and dashes.\n\n## Parameters\n- `text`: The string to process.\n\n## Returns\nA string with digits and dashes.\n\n## Notes\n- The function filters the given text to keep only digits and dashes.\n\n## Example\n```swift\nlet text = \"123-456-7890\"\nlet result = extractDigitsAndDashes(from: text)\n// \"123-456-7890\"\n```\n\n---\n\n# 001-write-a-function-that-returns-the-number-of-digits-in-a-string\n\nYou are documenting a Swift codebase. Given a function and a short description of where and how it is used, write a documentation comment that helps future developers understand its purpose.\nUse ///-style Swift comments.\nInclude parameter and return descriptions, and emphasize intent over implementation.\nReturn only the comment and the function.\n\nFunction:\n\nfunc countDigits",
      "/// Returns a new string with lowercase letters from the input string without\n/// numbers.\n/// - Parameter text: The text to filter.\n/// - Returns: A new string with lowercase letters.\nfunc lowercaseLettersWithoutNumbers(from text: String) -> String {\n    return text.filter { $0.isLetter }.lowercased()\n}\n\nFunction:\n\nfunc countDigits(_ in: String) -> Int {\n    return in.filter { $0.isNumber }.count\n}\n## Documentation:\n/// Returns the number of digits in the given string.\n/// - Parameter in: The string to count digits from.\n/// - Returns: The number of digits in the string.\nfunc countDigits(_ in: String) -> Int {\n    return in.filter { $0.isNumber }.count\n}\n\nFunction:\n\nfunc filterNumbers(_ in: String) -> String {\n    return in.filter { $0.isNumber }\n}\n## Documentation:\n/// Filters the given string to remove all non-numeric characters.\n/// - Parameter in: The string to filter.\n/// - Returns: A",
      "/// Checks if all strings in an array have the same length.\n/// - Parameter array: An array of strings.\n/// - Returns: `true` if all strings have the same length, `false` otherwise.\nfunc allStringsHaveEqualLength(_ array: [String]) -> Bool {\n    guard let firstLength = array.first?.count else { return true }\n    return array.allSatisfy { $0.count == firstLength }\n}\n\n/// Checks if all strings in an array have the same length.\n/// - Parameter array: An array of strings.\n/// - Returns: `true` if all strings have the same length, `false` otherwise.\nfunc allStringsHaveEqualLength(_ array: [String]) -> Bool {\n    guard let firstLength = array.first?.count else { return true }\n    return array.allSatisfy { $0.count == firstLength }\n}\n\n/// Checks if all strings in an array have the same length.\n/// - Parameter array: An array of strings.\n/// - Returns: `true` if all strings have the same length, `false` otherwise",
      "/// Splits a string by a character, returning an array of strings.\nfunc splitStringByCharacter(_ text: String, separator: Character) -> [String] {\n    return text.split(separator: separator).map { String($0) }\n}\n\n### Description\n\nSplits a string by a character, returning an array of strings.\n\n### Parameters\n\n- `text`: The string to split.\n- `separator`: The character to split by.\n\n- Returns: An array of strings, where each string is a substring of the input string separated by the given character.\n\n### Example\n\n/// Splits a string by a character, returning an array of strings.\n/// - Parameters:\n///   - text: The string to split.\n///   - separator: The character to split by.\n/// - Returns: An array of strings, where each string is a substring of the input string separated by the given character.\nfunc splitStringByCharacter(_ text: String, separator: Character) -> [String] {\n    return text.split(separator: separator).map { String($0) }\n}\n\n",
      "/// Returns `true` if the given string is a hexadecimal number.\n/// - Parameter text: The string to check.\n/// - Returns: `true` if the string starts with a hexadecimal digit.\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}\n\n## Sample usage\n\nisHexadecimalNumber(\"FF\") // true\nisHexadecimalNumber(\"0xFF\") // true\nisHexadecimalNumber(\"0XFF\") // false\n\n## Tips\n\nUse /// and ///@ to describe the function's purpose.\nUse ///@ to document a function that returns a value.\nUse ///@ to document a function that accepts a parameter.\nUse ///@ to document a function that returns a value and a parameter.\n\nFunction:\n\nfunc getFibonacci(_ n: Int) -> Int? {\n    guard n >= 2 else { return n }\n    let (a, b) = (",
      "/// Converts a string to a date.\n/// - Parameter text: A date in the format yyyy-MM-dd HH:mm:ss.\n/// - Returns: A date in the same format.\nfunc stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    return formatter.date(from: text)\n}\n\nFunction:\n\nfunc stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    return formatter.date(from: text)\n}\n## Documentation:\n/// Converts a string to a date.\n/// - Parameter text: A date in the format yyyy-MM-dd HH:mm:ss.\n/// - Returns: A date in the same format.\nfunc stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd",
      "/// Cleans a string by removing all whitespace and punctuation characters.\n/// - Parameter text: The text to clean.\n/// - Returns: A new string without whitespace or punctuation.\n\n/// - Parameter text: The text to clean.\n/// - Returns: A new string without whitespace or punctuation.\nfunc cleanString(_ text: String) -> String {\n    let charactersToRemove = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)\n    return text.filter { !charactersToRemove.contains($0.unicodeScalars.first!) }\n}\n\n/// Cleans a string by removing all whitespace and punctuation characters.\n/// - Parameter text: The text to clean.\n/// - Returns: A new string without whitespace or punctuation.\nfunc cleanString(_ text: String) -> String {\n    let charactersToRemove = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)\n    return text.filter { !charactersToRemove.contains($0.unicodeScalars.first!) }\n}\n\n/// Cleans a string by removing all whitespace and punctuation characters",
      "/// Converts a string to an integer using a specified base.\n/// - Parameter text: The string to convert.\n/// - Parameter base: The base of the number.\n/// - Returns: The integer representation of the number.\n/// - Throws: `InvalidBaseError` if the base is not a valid number.\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}\n\n/// Converts a string to an integer using a specified base.\n/// - Parameters:\n///   - text: The string to convert.\n///   - base: The base of the number.\n/// - Returns: The integer representation of the number.\n/// - Throws: `InvalidBaseError` if the base is not a valid number.\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}\n\n/// Converts a string to an integer using a specified base.\n/// - Parameters:\n///   - text: The string to convert.\n//",
      "/// Counts the number of unique characters in a string.\n/// - Parameter text: The string to count.\n/// - Returns: The number of unique characters.\n/// - Complexity: O(n), where n is the length of the string.\n\n/// - Parameters:\n///   - text: The string to count.\n/// - Returns: The number of unique characters.\nfunc countUniqueCharacters(in text: String) -> Int {\n    return Set(text).count\n}\n\n/// Counts the number of unique characters in a string.\n/// - Parameter text: The string to count.\n/// - Returns: The number of unique characters.\n/// - Complexity: O(n), where n is the length of the string.\n\n/// - Parameters:\n///   - text: The string to count.\n/// - Returns: The number of unique characters.\nfunc countUniqueCharacters(in text: String) -> Int {\n    return Set(text).count\n}\n\n/// Counts the number of unique characters in a string.\n/// - Parameter text: The string to count.\n/// - Returns",
      "/// Returns a string with only unique characters.\n/// - Parameter text: A string.\n/// - Returns: A string with only unique characters.\nfunc uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text.reduce(into: [:]) { counts, char in counts[char, default: 0] += 1 }\n    return String(text.filter { characterCount[$0] == 1 })\n}\n\n/// Returns a string with only unique characters.\n/// - Parameter text: A string.\n/// - Returns: A string with only unique characters.\nfunc uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text.reduce(into: [:]) { counts, char in counts[char, default: 0] += 1 }\n    return String(text.filter { characterCount[$0] == 1 })\n}\n\n/// Returns a string with only unique characters.\n/// - Parameter text: A string.\n/// - Returns: A string with only unique characters.\nfunc uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text",
      "/// Checks if a given string is a valid email address.\n/// - Parameter text: The string to check.\n/// - Returns: `true` if the string is a valid email, `false` otherwise.\n/// - Complexity: O(n).\nfunc isValidEmail(_ text: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"\n    return matchesRegex(text, pattern: emailRegex)\n}\n\n/// Checks if a given string is a valid email address.\n/// - Parameter text: The string to check.\n/// - Returns: `true` if the string is a valid email, `false` otherwise.\n/// - Complexity: O(n).\nfunc isValidEmail(_ text: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,",
      "/// Extracts numbers from a string.\n/// - Parameter text: The text to extract numbers from.\n/// - Returns: The extracted numbers as a string.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n\n/// Extracts numbers from a string.\n/// - Parameter text: The text to extract numbers from.\n/// - Returns: The extracted numbers as a string.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n\n/// Extracts numbers from a string.\n/// - Parameter text: The text to extract numbers from.\n/// - Returns: The extracted numbers as a string.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n\n/// Extracts numbers from a string.\n/// - Parameter text: The text to extract numbers from.\n/// - Returns: The extracted numbers as a string.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0",
      "/// Converts a string to a percentage.\n/// - Parameters:\n///   - text: The text to convert.\n///   - precision: The number of decimal places to round to.\n/// - Returns: The number as a percentage, or `nil` if the text is invalid.\nfunc stringToPercentage(_ text: String, precision: Int) -> String? {\n    guard let number = Double(text) else { return nil }\n    let percentage = number * 100\n    return String(format: \"%.\\(precision)f%%\", percentage)\n}\n\nDocumentation:\n\n/// Converts a string to a percentage.\n/// - Parameters:\n///   - text: The text to convert.\n///   - precision: The number of decimal places to round to.\n/// - Returns: The number as a percentage, or `nil` if the text is invalid.\nfunc stringToPercentage(_ text: String, precision: Int) -> String? {\n    guard let number = Double(text) else { return nil }\n    let percentage = number * 100\n    return String(format: \"%.",
      "/// Returns a string with alternating uppercase and lowercase letters.\n/// - Parameter text: The text to convert.\n/// - Returns: The converted text.\nfunc alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}\n\n/// Возвращает строку с указанным режимом шифрования.\n/// - Parameter text: Входная строка.\n/// - Returns: Обратная строка с указанным режимом шифрования.\nfunc alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}\n",
      "/// - Parameters:\n///   - text: A string to check.\n///   - Returns true if the string is a number.\n/// - Returns: True if the string is a number.\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}\n\nFunction:\n\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}\n## Documentation:\n/// - Parameters:\n///   - text: A string to check.\n///   - Returns true if the string is a number.\n/// - Returns: True if the string is a number.\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}\n\nFunction:\n\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}\n## Documentation:\n/// - Parameters:\n///   - text: A string to check.\n///   - Returns true if the string is a number.\n/// - Returns: True if the string is a number.\n",
      "/// Reverses an array of elements.\n/// - Parameter array: An array of elements.\n/// - Returns: A new array with the elements in reverse order.\n\n/// Reverses an array of elements.\n/// - Parameter array: An array of elements.\n/// - Returns: A new array with the elements in reverse order.\n\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}\n\n/// Reverses an array of elements.\n/// - Parameter array: An array of elements.\n/// - Returns: A new array with the elements in reverse order.\n\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}\n\n/// Reverses an array of elements.\n/// - Parameter array: An array of elements.\n/// - Returns: A new array with the elements in reverse order.\n\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}\n\n/// Reverses an array of elements.\n//",
      "/// Returns a random element from a dictionary.\n/// - Parameter dictionary: A dictionary.\n/// - Returns: A tuple of key-value pair.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}\n\n/// Returns a random element from a dictionary.\n/// - Parameter dictionary: A dictionary.\n/// - Returns: A tuple of key-value pair.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}\n\n/// Returns a random element from a dictionary.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}\n\n/// Returns a random element from a dictionary.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}\n\n",
      "/// Returns the keys with the minimum values in a dictionary.\n/// - Parameter dictionary: A dictionary of values.\n/// - Returns: The keys with the minimum values.\nfunc keysWithMinValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable, Value: Comparable {\n    guard let minValue = dictionary.values.min() else { return [] }\n    return dictionary.filter { $0.value == minValue }.map { $0.key }\n}\n\n#if !swift(5)\n/// Returns the keys with the minimum values in a dictionary.\n/// - Parameter dictionary: A dictionary of values.\n/// - Returns: The keys with the minimum values.\nfunc keysWithMinValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable, Value: Comparable {\n    guard let minValue = dictionary.values.min() else { return [] }\n    return dictionary.filter { $0.value == minValue }.map { $0.key }\n}\n#endif\n\n#if swift(5)\n/// Returns the keys",
      "/// Determines if a given date is in the future.\n/// - Parameter date: A date.\n/// - Returns: `true` if `date` is in the future.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n\nFunction:\n\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n## Documentation:\n/// Determines if a given date is in the future.\n/// - Parameter date: A date.\n/// - Returns: `true` if `date` is in the future.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n\nFunction:\n\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n## Documentation:\n/// Determines if a given date is in the future.\n/// - Parameter date: A date.\n/// - Returns: `true` if `date` is in the future.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n\nFunction",
      "/// Converts a string to an array of alphabetic characters.\n/// - Parameter str: The string to convert.\n/// - Returns: An array of alphabetic characters.\nfunc stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}\n\nFunction:\n\nfunc areaOfTriangle(_ base: Double, height: Double) -> Double {\n    return 0.5 * base * height\n}\n## Documentation:\n/// Calculates the area of a triangle.\n/// - Parameters:\n///   - base: The base of the triangle.\n///   - height: The height of the triangle.\n/// - Returns: The area of the triangle.\nfunc areaOfTriangle(_ base: Double, height: Double) -> Double {\n    return 0.5 * base * height\n}\n\nFunction:\n\nfunc areaOfRectangle(_ width: Double, height: Double) -> Double {\n    return width * height\n}\n## Documentation:\n/// Calculates the area of a rectangle.\n/// - Parameters:\n///   - width: The width",
      "/// Calculates the number of days between two dates.\n/// - Parameters:\n///   - startDate: The start date.\n///   - endDate: The end date.\n/// - Returns: The number of days between the dates.\n/// - Complexity: O(1).\nfunc daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}\n\n/// Calculates the number of days between two dates.\n/// - Parameters:\n///   - startDate: The start date.\n///   - endDate: The end date.\n/// - Returns: The number of days between the dates.\n/// - Complexity: O(1).\nfunc daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}\n\n/// Calculates the number of days between two dates.\n/// - Parameters:\n//",
      "/// Returns the sum of all numbers in a string.\n/// - Parameter str: A string containing numbers.\n/// - Returns: The sum of all numbers in the string.\n/// - Complexity: O(n) where n is the length of the string.\n\n/// - Parameter str: A string containing numbers.\n/// - Returns: The sum of all numbers in the string.\nfunc sumOfNumbersInString(_ str: String) -> Int {\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.reduce(0, +)\n}\n\n/// Returns the sum of all numbers in a string.\n/// - Parameter str: A string containing numbers.\n/// - Returns: The sum of all numbers in the string.\nfunc sumOfNumbersInString(_ str: String) -> Int {\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.reduce(0, +)\n}\n\n/// Returns the sum of all numbers in a string.\n/// - Parameter str: A string containing numbers.\n"
    ],
    "REFERENCES": [
      [
        "/// Проверяет, авторизован ли пользователь на основе токена в UserDefaults.\n/// - Returns: true, если токен существует и не истёк.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}"
      ],
      [
        "/// Формирует приветственное сообщение по времени суток.\n/// - Parameter name: Имя пользователя.\n/// - Returns: Персонализированное приветствие.\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро, \\(name)\"\n    case 12..<18: return \"Добрый день, \\(name)\"\n    case 18..<23: return \"Добрый вечер, \\(name)\"\n    default: return \"Доброй ночи, \\(name)\"\n    }\n}"
      ],
      [
        "/// Конвертирует сумму в рублях в форматированную строку с валютой.\n/// - Parameter amount: Сумма в рублях.\n/// - Returns: Строка с символом рубля.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"₽\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ₽\"\n}"
      ],
      [
        "/// Отправляет push-уведомление с заданным текстом.\n/// - Parameter message: Текст уведомления.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}"
      ],
      [
        "/// Определяет, нужно ли показать onboarding на основе флага в хранилище.\n/// - Returns: true, если onboarding ещё не пройден.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}"
      ],
      [
        "/// Сохраняет ID последнего просмотренного товара.\n/// - Parameter productId: ID товара.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}"
      ],
      [
        "/// Оценивает, следует ли показать пользователю всплывающее предложение.\n/// - Returns: true, если пользователь не видел баннер более суток.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}"
      ],
      [
        "/// Преобразует координаты в строку для отображения на UI.\n/// - Parameters:\n///   - lat: Широта.\n///   - lon: Долгота.\n/// - Returns: Строка координат.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}"
      ],
      [
        "/// Проверяет, заполнены ли все поля профиля пользователя.\n/// - Parameter profile: Словарь с данными профиля.\n/// - Returns: true, если все обязательные поля не пустые.\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}"
      ],
      [
        "/// Валидирует номер телефона на соответствие российскому формату.\n/// - Parameter phone: Строка номера.\n/// - Returns: true, если номер валиден.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}"
      ],
      [
        "/// Преобразует рейтинг (от 0 до 5) в строку с эмодзи-звездами.\n/// - Parameter rating: Значение рейтинга.\n/// - Returns: Строка из звёзд.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}"
      ],
      [
        "/// Определяет, есть ли активная интернет-сессия.\n/// - Returns: true, если интернет доступен.\nfunc isInternetAvailable() -> Bool {\n    // Упрощённо, для примера — реальная реализация требует Reachability\n    return true\n}"
      ],
      [
        "/// Сравнивает дату доставки с текущей датой и возвращает статус.\n/// - Parameter deliveryDate: Дата доставки.\n/// - Returns: Статус строки: \"Сегодня\", \"Завтра\", \"Позже\".\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"Сегодня\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"Завтра\"\n    } else {\n        return \"Позже\"\n    }\n}"
      ],
      [
        "/// Преобразует список тегов в одну строку с хештегами.\n/// - Parameter tags: Список тегов.\n/// - Returns: Строка с хештегами.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}"
      ],
      [
        "/// Сохраняет текущую позицию скролла в списке товаров.\n/// - Parameter offset: Значение смещения.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}"
      ],
      [
        "/// Проверяет, находится ли пользователь в зоне доставки (по координатам).\n/// - Parameters:\n///   - lat: Широта.\n///   - lon: Долгота.\n/// - Returns: true, если координаты входят в радиус.\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // Москва\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}"
      ],
      [
        "/// Генерирует URL для deeplink с заданным идентификатором товара.\n/// - Parameter productId: Идентификатор.\n/// - Returns: URL для перехода.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}"
      ],
      [
        "/// Проверяет, просмотрел ли пользователь новое сообщение поддержки.\n/// - Parameter lastViewedId: Последний просмотренный ID.\n/// - Parameter newMessageId: ID нового сообщения.\n/// - Returns: true, если есть новое сообщение.\nfunc hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}"
      ],
      [
        "/// Вычисляет процент прогресса цели (например, накоплений).\n/// - Parameters:\n///   - current: Текущее значение.\n///   - target: Целевая сумма.\n/// - Returns: Процент от 0 до 100.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}"
      ],
      [
        "/// Проверяет, авторизован ли пользователь на основе токена в UserDefaults.\n/// - Returns: true, если токен существует и не истёк.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}"
      ],
      [
        "/// Формирует приветственное сообщение по времени суток.\n/// - Parameter name: Имя пользователя.\n/// - Returns: Персонализированное приветствие.\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро, \\(name)\"\n    case 12..<18: return \"Добрый день, \\(name)\"\n    case 18..<23: return \"Добрый вечер, \\(name)\"\n    default: return \"Доброй ночи, \\(name)\"\n    }\n}"
      ],
      [
        "/// Конвертирует сумму в рублях в форматированную строку с валютой.\n/// - Parameter amount: Сумма в рублях.\n/// - Returns: Строка с символом рубля.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"₽\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ₽\"\n}"
      ],
      [
        "/// Отправляет push-уведомление с заданным текстом.\n/// - Parameter message: Текст уведомления.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}"
      ],
      [
        "/// Определяет, нужно ли показать onboarding на основе флага в хранилище.\n/// - Returns: true, если onboarding ещё не пройден.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}"
      ],
      [
        "/// Сохраняет ID последнего просмотренного товара.\n/// - Parameter productId: ID товара.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}"
      ],
      [
        "/// Оценивает, следует ли показать пользователю всплывающее предложение.\n/// - Returns: true, если пользователь не видел баннер более суток.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}"
      ],
      [
        "/// Преобразует координаты в строку для отображения на UI.\n/// - Parameters:\n///   - lat: Широта.\n///   - lon: Долгота.\n/// - Returns: Строка координат.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}"
      ],
      [
        "/// Проверяет, заполнены ли все поля профиля пользователя.\n/// - Parameter profile: Словарь с данными профиля.\n/// - Returns: true, если все обязательные поля не пустые.\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}"
      ],
      [
        "/// Валидирует номер телефона на соответствие российскому формату.\n/// - Parameter phone: Строка номера.\n/// - Returns: true, если номер валиден.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}"
      ],
      [
        "/// Преобразует рейтинг (от 0 до 5) в строку с эмодзи-звездами.\n/// - Parameter rating: Значение рейтинга.\n/// - Returns: Строка из звёзд.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}"
      ],
      [
        "/// Определяет, есть ли активная интернет-сессия.\n/// - Returns: true, если интернет доступен.\nfunc isInternetAvailable() -> Bool {\n    // Упрощённо, для примера — реальная реализация требует Reachability\n    return true\n}"
      ],
      [
        "/// Сравнивает дату доставки с текущей датой и возвращает статус.\n/// - Parameter deliveryDate: Дата доставки.\n/// - Returns: Статус строки: \"Сегодня\", \"Завтра\", \"Позже\".\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"Сегодня\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"Завтра\"\n    } else {\n        return \"Позже\"\n    }\n}"
      ],
      [
        "/// Преобразует список тегов в одну строку с хештегами.\n/// - Parameter tags: Список тегов.\n/// - Returns: Строка с хештегами.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}"
      ],
      [
        "/// Сохраняет текущую позицию скролла в списке товаров.\n/// - Parameter offset: Значение смещения.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}"
      ],
      [
        "/// Проверяет, находится ли пользователь в зоне доставки (по координатам).\n/// - Parameters:\n///   - lat: Широта.\n///   - lon: Долгота.\n/// - Returns: true, если координаты входят в радиус.\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // Москва\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}"
      ],
      [
        "/// Генерирует URL для deeplink с заданным идентификатором товара.\n/// - Parameter productId: Идентификатор.\n/// - Returns: URL для перехода.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}"
      ],
      [
        "/// Проверяет, просмотрел ли пользователь новое сообщение поддержки.\n/// - Parameter lastViewedId: Последний просмотренный ID.\n/// - Parameter newMessageId: ID нового сообщения.\n/// - Returns: true, если есть новое сообщение.\nfunc hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}"
      ],
      [
        "/// Вычисляет процент прогресса цели (например, накоплений).\n/// - Parameters:\n///   - current: Текущее значение.\n///   - target: Целевая сумма.\n/// - Returns: Процент от 0 до 100.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}"
      ],
      [
        "/// Возвращает ссылку на Terms & Conditions в зависимости от локали.\n/// - Returns: URL страницы условий использования.\nfunc termsAndConditionsURL() -> URL? {\n    let locale = Locale.current.languageCode ?? \"en\"\n    return URL(string: \"https://example.com/terms_\\(locale).html\")\n}"
      ],
      [
        "/// Проверяет, наступило ли время запланированного события.\n/// - Parameter date: Дата события.\n/// - Returns: true, если событие уже началось.\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}"
      ],
      [
        "/// Сохраняет выбранную пользователем тему оформления.\n/// - Parameter theme: Название темы.\nfunc saveUserTheme(_ theme: String) {\n    UserDefaults.standard.set(theme, forKey: \"appTheme\")\n}"
      ],
      [
        "/// Получает текущую тему оформления.\n/// - Returns: Название темы или nil.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}"
      ],
      [
        "/// Очищает сохранённые данные пользователя при выходе из аккаунта.\nfunc clearUserSession() {\n    let keys = [\"authToken\", \"userProfile\", \"lastViewedProduct\"]\n    keys.forEach { UserDefaults.standard.removeObject(forKey: $0) }\n}"
      ],
      [
        "/// Формирует строку обратной связи с информацией об устройстве.\n/// - Returns: Текст обратной связи.\nfunc generateFeedbackTemplate() -> String {\n    let systemVersion = UIDevice.current.systemVersion\n    let model = UIDevice.current.model\n    return \"Устройство: \\(model)\\nВерсия iOS: \\(systemVersion)\\nВаш отзыв: \"\n}"
      ],
      [
        "/// Проверяет, достиг ли пользователь лимита бесплатных действий.\n/// - Parameter count: Текущее количество действий.\n/// - Returns: true, если лимит достигнут.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}"
      ],
      [
        "/// Формирует строку даты для истории заказов.\n/// - Parameter date: Дата.\n/// - Returns: Строка формата \"dd MMM yyyy\".\nfunc formatOrderDate(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd MMM yyyy\"\n    return formatter.string(from: date)\n}"
      ],
      [
        "/// Вычисляет количество дней между двумя датами.\n/// - Parameters:\n///   - from: Начальная дата.\n///   - to: Конечная дата.\n/// - Returns: Количество дней.\nfunc daysBetween(_ from: Date, _ to: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: from, to: to).day ?? 0\n}"
      ],
      [
        "/// Сохраняет ID последнего просмотренного баннера.\n/// - Parameter id: Идентификатор баннера.\nfunc saveLastSeenBannerId(_ id: String) {\n    UserDefaults.standard.set(id, forKey: \"lastSeenBannerId\")\n}"
      ],
      [
        "/// Проверяет, следует ли обновить кешированные данные.\n/// - Parameter lastUpdate: Дата последнего обновления.\n/// - Returns: true, если прошло больше 6 часов.\nfunc shouldRefreshCache(since lastUpdate: Date) -> Bool {\n    return Date().timeIntervalSince(lastUpdate) > 6 * 3600\n}"
      ],
      [
        "/// Проверяет, авторизован ли пользователь на основе токена в UserDefaults.\n/// - Returns: true, если токен существует и не истёк.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}"
      ],
      [
        "/// Проверяет, является ли пользователь новым (на основе даты регистрации).\n/// - Parameter registrationDate: Дата регистрации пользователя.\n/// - Returns: true, если пользователь зарегистрирован менее 7 дней назад.\nfunc isNewUser(registrationDate: Date) -> Bool {\n    return Date().timeIntervalSince(registrationDate) < 7 * 86400\n}"
      ],
      [
        "/// Получает количество запусков приложения.\n/// - Returns: Количество запусков.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}"
      ],
      [
        "/// Увеличивает счётчик запусков приложения.\nfunc incrementAppLaunchCount() {\n    let count = getAppLaunchCount() + 1\n    UserDefaults.standard.set(count, forKey: \"launchCount\")\n}"
      ],
      [
        "/// Проверяет, доступен ли Face ID на устройстве.\n/// - Returns: true, если Face ID доступен.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}"
      ],
      [
        "/// Получает имя месяца на русском по номеру.\n/// - Parameter month: Номер месяца от 1 до 12.\n/// - Returns: Название месяца.\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.monthSymbols[safe: month - 1] ?? \"\"\n}"
      ],
      [
        "/// Формирует URL для запроса истории заказов пользователя.\n/// - Parameter userId: Идентификатор пользователя.\n/// - Returns: URL с параметром userId.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}"
      ],
      [
        "/// Получает текущее значение параметра \"darkMode\".\n/// - Returns: true, если включена тёмная тема.\nfunc isDarkModeEnabled() -> Bool {\n    return UserDefaults.standard.bool(forKey: \"darkMode\")\n}"
      ],
      [
        "/// Проверяет, есть ли доступ к геолокации.\n/// - Returns: true, если доступ разрешён.\nfunc isLocationAccessGranted() -> Bool {\n    return CLLocationManager.authorizationStatus() == .authorizedWhenInUse || CLLocationManager.authorizationStatus() == .authorizedAlways\n}"
      ],
      [
        "/// Преобразует секунды в строку формата \"мм:сс\".\n/// - Parameter seconds: Количество секунд.\n/// - Returns: Форматированная строка.\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n}"
      ],
      [
        "/// Проверяет, достигнуто ли максимальное количество попыток ввода PIN-кода.\n/// - Parameter attempts: Количество попыток.\n/// - Returns: true, если лимит превышен.\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}"
      ],
      [
        "/// Генерирует строку статуса доставки по текущему этапу.\n/// - Parameter status: Текущий статус.\n/// - Returns: Строковое описание.\nfunc deliveryStatusText(for status: String) -> String {\n    switch status {\n    case \"pending\": return \"Ожидает обработки\"\n    case \"shipped\": return \"Отправлено\"\n    case \"delivered\": return \"Доставлено\"\n    default: return \"Неизвестно\"\n    }\n}"
      ],
      [
        "/// Удаляет все элементы UserDefaults для сброса приложения.\nfunc resetAppData() {\n    if let appDomain = Bundle.main.bundleIdentifier {\n        UserDefaults.standard.removePersistentDomain(forName: appDomain)\n    }\n}"
      ],
      [
        "/// Проверяет, работает ли сервер API.\n/// - Parameter completion: Замыкание с результатом доступности.\nfunc pingServer(completion: @escaping (Bool) -> Void) {\n    let url = URL(string: \"https://api.example.com/ping\")!\n    URLSession.shared.dataTask(with: url) { _, response, error in\n        let httpResponse = response as? HTTPURLResponse\n        completion(httpResponse?.statusCode == 200 && error == nil)\n    }.resume()\n}"
      ],
      [
        "/// Сохраняет предпочитаемый язык пользователя.\n/// - Parameter languageCode: Код языка (например, \"ru\", \"en\").\nfunc savePreferredLanguage(_ languageCode: String) {\n    UserDefaults.standard.set(languageCode, forKey: \"preferredLanguage\")\n}"
      ],
      [
        "/// Получает предпочитаемый язык пользователя.\n/// - Returns: Код языка или \"ru\" по умолчанию.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"ru\"\n}"
      ],
      [
        "/// Проверяет, является ли строка числовым значением, которое не является целым числом.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка представляет число с плавающей точкой, false — целое число или не число.\nfunc isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor(number) != number\n    }\n    return false\n}"
      ],
      [
        "/// Генерирует строку, содержащую повторяющийся символ определённое количество раз.\n/// - Parameters:\n///   - character: Символ для повторения.\n///   - count: Количество повторений.\n/// - Returns: Строка с повторяющимися символами.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}"
      ],
      [
        "/// Проверяет, является ли строка уникальной в массиве строк.\n/// - Parameters:\n///   - text: Строка для проверки.\n///   - array: Массив строк.\n/// - Returns: true, если строка встречается в массиве только один раз.\nfunc isUniqueString(_ text: String, in array: [String]) -> Bool {\n    return array.filter { $0 == text }.count == 1\n}"
      ],
      [
        "/// Преобразует строку в число с заданным округлением до определённого числа знаков после запятой.\n/// - Parameters:\n///   - text: Входная строка.\n///   - decimals: Количество знаков после запятой.\n/// - Returns: Округлённое число.\nfunc roundedNumber(from text: String, decimals: Int) -> Double? {\n    guard let number = Double(text) else { return nil }\n    return round(number * pow(10, Double(decimals))) / pow(10, Double(decimals))\n}"
      ],
      [
        "/// Возвращает строку, содержащую все цифры из строки в порядке их появления.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только цифры.\nfunc extractDigitsInOrder(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}"
      ],
      [
        "/// Переводит строку в \"кобольдский\" регистр (каждое слово с маленькой буквы, кроме первого).\n/// - Parameter text: Входная строка.\n/// - Returns: Строка в \"кобольдском\" регистре.\nfunc toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}"
      ],
      [
        "/// Возвращает строку с удалением всех символов, которые встречаются в другой строке.\n/// - Parameters:\n///   - text: Входная строка.\n///   - charactersToRemove: Строка с символами для удаления.\n/// - Returns: Строка без указанных символов.\nfunc removeCharactersFromString(_ text: String, charactersToRemove: String) -> String {\n    return text.filter { !charactersToRemove.contains($0) }\n}"
      ],
      [
        "/// Проверяет, является ли строка полным числом без десятичной точки.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка представляет целое число.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}"
      ],
      [
        "/// Проверяет, является ли строка подстрокой другой строки.\n/// - Parameters:\n///   - substring: Подстрока для проверки.\n///   - text: Исходная строка.\n/// - Returns: true, если подстрока найдена в строке.\nfunc containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n}"
      ],
      [
        "/// Преобразует строку в список слов с учётом заглавных букв (каждое новое слово начинается с заглавной буквы).\n/// - Parameter text: Входная строка.\n/// - Returns: Массив слов с учётом заглавных букв.\nfunc stringToCapitalizedWords(_ text: String) -> [String] {\n    return text.split(separator: \" \").map { $0.capitalized }\n}"
      ],
      [
        "/// Преобразует строку в строку с чередующимися буквами в верхнем и нижнем регистрах.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с чередующимися заглавными и строчными буквами.\nfunc alternatingCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, character) in\n        index % 2 == 0 ? character.lowercased() : character.uppercased()\n    })\n}"
      ],
      [
        "/// Возвращает индекс первого вхождения подстроки в строку.\n/// - Parameters:\n///   - substring: Подстрока для поиска.\n///   - text: Исходная строка.\n/// - Returns: Индекс первого вхождения подстроки или nil, если не найдено.\nfunc indexOfSubstring(_ substring: String, in text: String) -> Int? {\n    return text.range(of: substring)?.lowerBound.utf16Offset(in: text)\n}"
      ],
      [
        "/// Проверяет, является ли строка палиндромом, учитывая только алфавитные символы и игнорируя регистр.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является палиндромом.\nfunc isAlphaOnlyPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}"
      ],
      [
        "/// Возвращает строку, содержащую только заглавные буквы из исходной строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только заглавные буквы.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}"
      ],
      [
        "/// Возвращает true, если строка является числовым значением в двоичной системе.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является двоичным числом.\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}"
      ],
      [
        "/// Возвращает строку с первым символом, преобразованным в заглавную букву.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с первым символом в верхнем регистре.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}"
      ],
      [
        "/// Преобразует строку в массив, разбивая по каждому символу.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив символов.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}"
      ],
      [
        "/// Возвращает строку, которая является результатом повторения строкового значения несколько раз.\n/// - Parameters:\n///   - text: Входная строка.\n///   - count: Количество повторений.\n/// - Returns: Повторённая строка.\nfunc repeatString(_ text: String, count: Int) -> String {\n    return String(repeating: text, count: count)\n}"
      ],
      [
        "/// Проверяет, является ли строка представлением действительного времени в формате \"HH:mm\".\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является временем в формате \"HH:mm\".\nfunc isValidTime(_ text: String) -> Bool {\n    let pattern = \"^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$\"\n    return matchesRegex(text, pattern: pattern)\n}"
      ],
      [
        "/// Возвращает строку, состоящую только из цифр и символов тире, если они присутствуют в строке.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с цифрами и тире.\nfunc extractDigitsAndDashes(from text: String) -> String {\n    return text.filter { $0.isNumber || $0 == \"-\" }\n}"
      ],
      [
        "/// Возвращает все символы строки в нижнем регистре, кроме чисел.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с буквами в нижнем регистре.\nfunc lowercaseLettersWithoutNumbers(from text: String) -> String {\n    return text.filter { $0.isLetter }.lowercased()\n}"
      ],
      [
        "/// Проверяет, все ли строки в массиве имеют одинаковую длину.\n/// - Parameter array: Массив строк.\n/// - Returns: true, если все строки одинаковой длины.\nfunc allStringsHaveEqualLength(_ array: [String]) -> Bool {\n    guard let firstLength = array.first?.count else { return true }\n    return array.allSatisfy { $0.count == firstLength }\n}"
      ],
      [
        "/// Преобразует строку в список строк, разделённых определённым символом.\n/// - Parameters:\n///   - text: Входная строка.\n///   - separator: Символ для разделения.\n/// - Returns: Массив строк.\nfunc splitStringByCharacter(_ text: String, separator: Character) -> [String] {\n    return text.split(separator: separator).map { String($0) }\n}"
      ],
      [
        "/// Проверяет, является ли строка числовым значением в шестнадцатеричной системе.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является шестнадцатеричным числом.\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}"
      ],
      [
        "/// Преобразует строку в дату с учётом времени в формате \"yyyy-MM-dd HH:mm:ss\".\n/// - Parameter text: Входная строка.\n/// - Returns: Дата, если строка соответствует формату.\nfunc stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    return formatter.date(from: text)\n}"
      ],
      [
        "/// Преобразует строку в строку с удалёнными пробелами, знаками препинания и символами новой строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка без пробелов и знаков препинания.\nfunc cleanString(_ text: String) -> String {\n    let charactersToRemove = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)\n    return text.filter { !charactersToRemove.contains($0.unicodeScalars.first!) }\n}"
      ],
      [
        "/// Преобразует строку в число с использованием заданной базы (например, 2 для двоичной системы).\n/// - Parameters:\n///   - text: Входная строка.\n///   - base: База числа.\n/// - Returns: Число в заданной системе счисления.\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}"
      ],
      [
        "/// Преобразует строку в массив символов и возвращает количество уникальных символов.\n/// - Parameter text: Входная строка.\n/// - Returns: Количество уникальных символов.\nfunc countUniqueCharacters(in text: String) -> Int {\n    return Set(text).count\n}"
      ],
      [
        "/// Возвращает строку, состоящую из символов, которые встречаются в строке не более одного раза.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с уникальными символами.\nfunc uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text.reduce(into: [:]) { counts, char in counts[char, default: 0] += 1 }\n    return String(text.filter { characterCount[$0] == 1 })\n}"
      ],
      [
        "/// Проверяет, является ли строка строкой, представляющей корректный email-адрес.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка — корректный email.\nfunc isValidEmail(_ text: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"\n    return matchesRegex(text, pattern: emailRegex)\n}"
      ],
      [
        "/// Возвращает строку, которая является результатом склеивания всех чисел из строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только числа из исходной строки.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}"
      ],
      [
        "/// Преобразует строку с числовым значением в проценты.\n/// - Parameters:\n///   - text: Входная строка.\n///   - precision: Количество знаков после запятой.\n/// - Returns: Строка с процентным значением.\nfunc stringToPercentage(_ text: String, precision: Int) -> String? {\n    guard let number = Double(text) else { return nil }\n    let percentage = number * 100\n    return String(format: \"%.\\(precision)f%%\", percentage)\n}"
      ],
      [
        "/// Возвращает строку, где символы чередуются между верхним и нижним регистром.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с чередующимися буквами.\nfunc alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}"
      ],
      [
        "/// Проверяет, является ли строка числовым значением, включая десятичную точку.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является числом.\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}"
      ],
      [
        "/// Возвращает элементы массива в обратном порядке.\n/// - Parameter array: Массив.\n/// - Returns: Массив в обратном порядке.\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}"
      ],
      [
        "/// Генерирует случайный элемент из словаря по его значениям.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Случайный элемент словаря.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}"
      ],
      [
        "/// Возвращает ключи из словаря, которые связаны с минимальными значениями.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Ключи с минимальными значениями.\nfunc keysWithMinValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable, Value: Comparable {\n    guard let minValue = dictionary.values.min() else { return [] }\n    return dictionary.filter { $0.value == minValue }.map { $0.key }\n}"
      ],
      [
        "/// Проверяет, является ли переданная дата в будущем относительно текущей.\n/// - Parameter date: Дата для проверки.\n/// - Returns: `true`, если дата в будущем.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}"
      ],
      [
        "/// Преобразует строку в массив символов, фильтруя только буквы.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов, содержащих только буквы.\nfunc stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}"
      ],
      [
        "/// Находит разницу между двумя датами в днях.\n/// - Parameters:\n///   - startDate: Начальная дата.\n///   - endDate: Конечная дата.\n/// - Returns: Количество дней между датами.\nfunc daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}"
      ],
      [
        "/// Преобразует строку в массив чисел, разделенных пробелами, и возвращает сумму.\n/// - Parameter str: Входная строка.\n/// - Returns: Сумма чисел в строке.\nfunc sumOfNumbersInString(_ str: String) -> Int {\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.reduce(0, +)\n}"
      ]
    ]
  }
}