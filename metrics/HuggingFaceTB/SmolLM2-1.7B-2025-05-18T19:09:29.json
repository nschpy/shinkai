{
  "title": "HuggingFaceTB/SmolLM2-1.7B-supervised-full-fine-tuning",
  "description": "–°—É–ø–µ—Ä–≤–∏–∑–æ—Ä–Ω–æ–µ –ø–æ–ª–Ω–æ–µ –¥–æ–æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ HuggingFaceTB/SmolLM2-1.7B —Å –ø–æ—Å–ª–µ–¥—É—é—â–∏–º –∏–Ω—Ñ–µ—Ä–µ–Ω—Å–æ–º –∏ –æ—Ü–µ–Ω–∫–æ–π –Ω–∞ —Ç–µ—Å—Ç–æ–≤–æ–º –Ω–∞–±–æ—Ä–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ –º–µ—Ç—Ä–∏–∫–∞–º BLEU –∏ ROUGE.",
  "metrics": {
    "BLEU": 0.2500855093778992,
    "ROUGE-L": 0.36825438796127963,
    "PREDICTIONS": [
      "func isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞\n    return !token.isEmpty\n}\n\n## Input/Output:\n\n/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–º.\n/// - Returns: `true`, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞\n    return !token.isEmpty",
      "/// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –≤—Ä–µ–º–µ–Ω–∏ —Ä–∞–±–æ—Ç—ã –¥–Ω—è.\n/// - Parameter name: –ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Returns: –°–æ–æ–±—â–µ–Ω–∏–µ.\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ, \\(name)\"\n    case 12..<18: return \"–î–æ–±—Ä—ã–π –¥–µ–Ω—å, \\(name)\"\n    case 18..<23: return \"–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä, \\(name)\"\n    default: return \"–î–æ–±—Ä–æ–π –Ω–æ—á–∏, \\(name)\"\n    }\n}\n\n## Test:\nimport XCTest\n\nfinal class GenerateGreetingMessageTests: XCTestCase {\n    func testGenerateGreetingMessage() {\n        let expected = \"–î–æ–±—Ä",
      "/// –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å—É–º–º—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ \"–†–¢–°\".\n/// - Parameter amount: –ó–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.\n/// - Returns: –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"‚ÇΩ\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ‚ÇΩ\"\n}\n\n## Examples:\n/// –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å—É–º–º—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ \"–†–¢–°\".\n/// - Parameter amount: –ó–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.\n/// - Returns: –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π —Å —Ä–µ–∑—É–ª—å—Ç",
      "/// Send a local push notification to a device.\n/// - Parameter message: Message to send.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}\n\n/// Send a local push notification to a device.\n/// - Parameter message: Message to send.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}\n\n/// Send a local push notification to a device.\n/// - Parameter message: Message to send.\nfunc sendLocalPush(",
      "/// Shows the onboarding screen if it hasn't been shown yet.\n/// - Returns: `true` if the user hasn't seen the onboarding screen.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n/// Shows the onboarding screen if it hasn't been shown yet.\n/// - Returns: `true` if the user hasn't seen the onboarding screen.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n/// Shows the onboarding screen if it hasn't been shown yet.\n/// - Returns: `true` if the user hasn't seen the onboarding screen.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n/// Shows the onboarding screen if it hasn't been shown yet.\n/// - Returns: `true` if the user hasn't seen the onboarding screen.\nfunc shouldShowOnboarding() -> Bool {",
      "/// Saves the last viewed product to User Defaults.\n/// - Parameter productId: The product ID.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}\n\n## Notes:\n- Saves the last viewed product to User Defaults.\n- The `productId` is passed as a parameter.\n\n## Examples:\n- Save the last product viewed.\n- Save the last product viewed.\n- Save the last viewed product.\n\n## Related:\n- [Design your Swift codebase for a single developer](/design-swift-codebase-single-developer).\n- [Document your Swift codebase for a single developer](/document-swift-codebase-single-developer).\n- [Document your Swift codebase for multiple developers](/document-swift-codebase-multiple-developers).\n\n## Further reading:\n- [Writing Swift Documentation](https://developer.apple.com/library/archive/documentation/Swift/Conceptual/Swift_Programming_Language/WritingDocumentation.html#//apple_",
      "/// Displays a promo banner if it's been more than 24 hours since the last one.\n/// - Returns: Whether to show the promo banner.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\n## Notes:\n- This function shows a promo banner if it's been more than 24 hours since the last one.\n- It retrieves the last time the promo banner was shown from UserDefaults.\n- The function returns `true` if it's time to show the promo banner.\n\n## Tests:\n\nimport XCTest\n\nclass UserDefaultsTests: XCTestCase {\n    func testLastPromoShown() {\n        let userDefaults = UserDefaults.standard\n        userDefaults.set(Date(), forKey: \"lastPromoShown\")\n        XCTAssertEqual(userDefaults.object(forKey: \"lastPromoShown",
      "/// Converts coordinates to a string.\n/// - Parameters:\n///   - lat: The latitude.\n///   - lon: The longitude.\n/// - Returns: The coordinates as a string.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}\n\nFunction:\n\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}\n## Documentation:\n/// Converts coordinates to a string.\n/// - Parameters:\n///   - lat: The latitude.\n///   - lon: The longitude.\n/// - Returns: The coordinates as a string.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}\n\nFunction:\n\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"",
      "/// Returns `true` if the given `profile` contains all required keys.\n/// - Parameter profile: A dictionary of user profile data.\n/// - Returns: `true` if all keys are present and non-empty.\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}\n\n## Notes:\n- Use `///-` style comments.\n- Include parameter and return descriptions, and emphasize intent over implementation.\n- Return only the comment and the function.\n\n## Tests:\nimport XCTest\n\nclass IsUserProfileCompleteTests: XCTestCase {\n    func testExample() {\n        /// Returns `true` if the given `profile` contains all required keys.\n        /// - Parameter profile: A dictionary of user profile data.\n        /// - Returns: `true` if all keys are present and non-empty.\n        func isUserProfileComplete(profile: [String: String]) -> Bool {\n            let requiredKeys = [\"first",
      "/// Checks if a phone number is valid in Russia.\n/// - Parameter phone: The phone number to check.\n/// - Returns: `true` if the phone number is valid, `false` otherwise.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\n/// Checks if a phone number is valid in Russia.\n/// - Parameter phone: The phone number to check.\n/// - Returns: `true` if the phone number is valid, `false` otherwise.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\n/// Checks if a phone number is valid in Russia.\n/// - Parameter phone: The phone number to check.\n/// - Returns: `true` if the phone number is valid, `false` otherwise.\nfunc isValidRussian",
      "/// Returns stars based on rating.\n/// - Parameter rating: Rating from 0.0 to 1.0.\n/// - Returns: String with stars.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"‚òÖ\", count: filledStars) + String(repeating: \"‚òÜ\", count: emptyStars)\n}\n\n/// Returns stars based on rating.\n/// - Parameter rating: Rating from 0.0 to 1.0.\n/// - Returns: String with stars.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"‚òÖ\", count: filledStars) + String(repeating: \"‚òÜ\", count: emptyStars)\n}\n\n/// Returns stars based on rating.\n/// - Parameter rating: Rating from 0.0 to 1.0.\n",
      "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –ø–æ–¥–∫–ª—é—á—ë–Ω –ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É.\n/// - Returns: `true`, –µ—Å–ª–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–æ.\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n\n/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –ø–æ–¥–∫–ª—é—á—ë–Ω –ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É.\n/// - Returns: `true`, –µ—Å–ª–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–æ.\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n\n/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –ø–æ–¥–∫–ª—é—á—ë–Ω –ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É.\n/// - Returns: `true`, –µ—Å–ª–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–æ.\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n\n/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –ø–æ–¥–∫–ª—é—á—ë–Ω –ª–∏",
      "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É —Å –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ–º –¥–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏ –∑–∞–∫–∞–∑–∞.\n/// - Parameter deliveryDate: –î–∞—Ç–∞ –¥–æ—Å—Ç–∞–≤–∫–∏.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ–º.\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"–°–µ–≥–æ–¥–Ω—è\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"–ó–∞–≤—Ç—Ä–∞\"\n    } else {\n        return \"–ü–æ–∑–∂–µ\"\n    }\n}\n\n## Test:\n/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É —Å –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ–º –¥–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏ –∑–∞–∫–∞–∑–∞.\n/// - Parameter deliveryDate: –î–∞—Ç–∞ –¥–æ—Å—Ç–∞–≤–∫–∏.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å –ø—Ä–∏",
      "/// Returns a string containing the hashtags for the given array of tags.\n/// - Parameter tags: An array of tags.\n/// - Returns: A string containing the hashtags.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}\n\n## Examples:\n/// The `hashtags` function returns a string containing the hashtags for the given array of tags.\n/// - Parameter tags: An array of tags.\n/// - Returns: A string containing the hashtags.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}\n\n/// The `hashtags` function returns a string containing the hashtags for the given array of tags.\n/// - Parameter tags: An array of tags.\n/// - Returns: A string containing the hashtags.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased",
      "/// Save the scroll offset in UserDefaults.\n/// - Parameter offset: The scroll offset.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}\n\n/// Return the scroll offset from UserDefaults.\n/// - Returns: The scroll offset.\nfunc getScrollOffset() -> Double? {\n    return UserDefaults.standard.double(forKey: \"productListScrollOffset\")\n}\n\n/// Save the scroll offset in UserDefaults.\n/// - Parameter offset: The scroll offset.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}\n\n/// Return the scroll offset from UserDefaults.\n/// - Returns: The scroll offset.\nfunc getScrollOffset() -> Double? {\n    return UserDefaults.standard.double(forKey: \"productListScrollOffset\")\n}\n\n/// Save the scroll offset in UserDefaults.\n/// - Parameter offset: The scroll offset.\nfunc saveSc",
      "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ç–æ—á–∫–∞ –≤–Ω—É—Ç—Ä–∏ –¥–ª–∏–Ω—ã 30 –∫–º –æ—Ç —Ü–µ–Ω—Ç—Ä–∞\n/// - Parameters:\n///   - lat: –®–∏—Ä–æ—Ç–∞\n///   - lon: –î–æ–ª–≥–æ—Ç–∞\n/// - Returns: true, –µ—Å–ª–∏ —Ç–æ—á–∫–∞ –≤–Ω—É—Ç—Ä–∏ –¥–∏–∞–ø–∞–∑–æ–Ω–∞\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // –ú–æ—Å–∫–≤–∞\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}\n\n## Solution\n/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ç–æ—á–∫–∞ –≤–Ω—É—Ç—Ä–∏ –¥–ª–∏–Ω—ã 30 –∫–º –æ—Ç —Ü–µ–Ω—Ç—Ä–∞\n",
      "/// Generates a deep link for a given product ID.\n/// - Parameter productId: The product ID.\n/// - Returns: The deep link or nil if the ID is invalid.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\n/// Generates a deep link for a given product ID.\n/// - Parameter productId: The product ID.\n/// - Returns: The deep link or nil if the ID is invalid.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\n/// Generates a deep link for a given product ID.\n/// - Parameter productId: The product ID.\n/// - Returns: The deep link or nil if the ID is invalid.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\n/// Generates a deep link for a given product ID.",
      "/// Checks if the last viewed ID is different than the new ID.\n/// - Parameters:\n///   - lastViewedId: The last viewed ID.\n///   - newMessageId: The new message ID.\n/// - Returns: `true` if the IDs are different.\n\n/// Checks if the last viewed ID is different than the new ID.\n/// - Parameters:\n///   - lastViewedId: The last viewed ID.\n///   - newMessageId: The new message ID.\n/// - Returns: `true` if the IDs are different.\n\n/// Checks if the last viewed ID is different than the new ID.\n/// - Parameters:\n///   - lastViewedId: The last viewed ID.\n///   - newMessageId: The new message ID.\n/// - Returns: `true` if the IDs are different.\n\n/// Checks if the last viewed ID is different than the new ID.\n/// - Parameters:\n///   - lastViewedId: The last viewed ID.\n///   - newMessageId: The new message ID.\n",
      "/// Returns the percentage of progress from `current` to `target`.\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of progress.\n/// - Complexity: O(1).\n\n/// Returns the percentage of progress from `current` to `target`.\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of progress.\n/// - Complexity: O(1).\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}\n\n/// Returns the percentage of progress from `current` to `target`.\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of progress.\n/// - Complexity: O(1).\nfunc progressPercentage(current:",
      "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–º.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞\n    return !token.isEmpty\n}\n\nFunction:\n\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞\n    return !token.isEmpty\n}\n## Documentation:\n/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤",
      "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É —Å–æ —Å–≤–æ–∏–º –∏–º–µ–Ω–µ–º, –≥–æ—Ç–æ–≤–æ–π –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ –≤ —Å–æ–æ–±—â–µ–Ω–∏–µ \"–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ, <name>\".\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ, \\(name)\"\n    case 12..<18: return \"–î–æ–±—Ä—ã–π –¥–µ–Ω—å, \\(name)\"\n    case 18..<23: return \"–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä, \\(name)\"\n    default: return \"–î–æ–±—Ä–æ–π –Ω–æ—á–∏, \\(name)\"\n    }\n}\n\n## Documentation:\n/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É —Å–æ —Å–≤–æ–∏–º –∏–º–µ–Ω–µ–º, –≥–æ—Ç–æ–≤–æ–π –¥–ª—è",
      "/// Formats a number to Russian currency.\n/// - Parameter amount: A number to format.\n/// - Returns: A string representation of the number.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"‚ÇΩ\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ‚ÇΩ\"\n}\n\nFunction:\n\nfunc isEven(_ number: Int) -> Bool {\n    return number % 2 == 0\n}\n## Documentation:\n/// Determines if a number is even.\n/// - Parameter number: A number to check.\n/// - Returns: `true` if the number is even, `false` otherwise.\nfunc isEven(_ number: Int) -> Bool {\n    return number % 2 == 0\n}\n\nFunction:\n\nfunc average(_ numbers: [Int]) -> Double {\n    guard !numbers.isEmpty else { return 0 }\n    return Double(numbers.",
      "///- sendLocalPush(message:)\n/// - Parameter message: The message to send\n/// - Returns: Nothing\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}\n\n## Solution\n\n///- sendLocalPush(message:)\n/// - Parameter message: The message to send\n/// - Returns: Nothing\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}\n\n## Challenge 2\n\nYou are documenting a Swift codebase.",
      "/// Show the onboarding screen if the user has not seen it yet.\n/// - Returns: `true` if the onboarding screen should be shown.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}\n\n## Notes:\n\n- Use the `///` comment style for all documentation.\n- Document only the function and its purpose.\n- Emphasize intent over implementation.\n\n## Tips:\n\n- Document a function once and add it to the project's `Documentation` enum.\n- Use the `///-` style for comments.\n- Don't document every function. Focus on the most important ones.\n\n## Challenges:\n\n- Write a comment for a function that reads a string from a file and returns its uppercase version.\n- Write a comment for a function that calculates the factorial of a number.\n- Write a comment for a function that checks if a number is even.\n\n## References:\n\n- [SwiftDoc](https://github.com/apple/swift-doc)\n- [SwiftDoc Examples](https://github.com",
      "/// Save the last product viewed in the app.\n/// - Parameter productId: The product ID.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}\n\nFunction:\n\nfunc printText(_ text: String) {\n    print(text)\n}\n## Documentation:\n/// Prints text to the console.\n/// - Parameter text: The text to print.\nfunc printText(_ text: String) {\n    print(text)\n}\n\nFunction:\n\nfunc printText(_ text: String) {\n    print(text)\n}\n## Documentation:\n/// Prints text to the console.\n/// - Parameter text: The text to print.\nfunc printText(_ text: String) {\n    print(text)\n}\n\nFunction:\n\nfunc printText(_ text: String) {\n    print(text)\n}\n## Documentation:\n/// Prints text to the console.\n/// - Parameter text: The text to print.\nfunc printText(_ text: String) {\n    print(text)\n}\n",
      "/// Returns whether or not to show a promo banner.\n/// - Returns: `true` if the promo banner should be shown.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\n## Explanation:\n/// Returns whether or not to show a promo banner.\n/// - Returns: `true` if the promo banner should be shown.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}\n\n## Notes:\n/// - This function returns whether or not to show a promo banner.\n/// - The function checks the time since the last promo banner was shown.\n/// - The return value indicates whether or not to show the",
      "/// Converts coordinates to a string in the format `üìç <latitude>, <longitude>`.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}\n\n/// Converts coordinates to a string in the format `üìç <latitude>, <longitude>`.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}\n\n/// Converts coordinates to a string in the format `üìç <latitude>, <longitude>`.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}\n\n/// Converts coordinates to a string in the format `üìç <latitude>, <longitude>`.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"üìç %.4f, %.4f\",",
      "/// Checks if a given user profile is complete.\n/// - Parameter profile: The user profile.\n/// - Returns: `true` if all required keys are present, `false` otherwise.\n/// - Complexity: O(n).\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}\n\n/// Checks if a given user profile is complete.\n/// - Parameter profile: The user profile.\n/// - Returns: `true` if all required keys are present, `false` otherwise.\n/// - Complexity: O(n).\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}\n\n/// Checks if a given user profile is complete.\n/// - Parameter profile: The user profile",
      "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ —Ä–∞–∑–±–∏—Ç–æ–π –Ω–∞ —Å–∏–º–≤–æ–ª—ã –ø–æ—Å–ª–µ —Ç–æ—á–∫–∏ –Ω–∞—á–∞–ª–∞ —Å—Ç—Ä–æ–∫–∏, —Å–æ—Å—Ç–æ—è—â–µ–π –∏–∑ —á–∏—Å–ª–∞ —Å –∫–æ–¥–æ–º 7 –∏ 10 —Å–∏–º–≤–æ–ª–æ–≤.\n/// - Parameter phone: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: `true`, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —è–≤–ª—è–µ—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}\n\n## Sample output\n/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ —Ä–∞–∑–±–∏—Ç–æ–π –Ω–∞ —Å–∏–º–≤–æ–ª—ã –ø–æ—Å–ª",
      "/// Returns a string of filled and empty stars to represent a rating.\n/// - Parameter rating: The rating between 0 and 5.\n/// - Returns: A string of filled and empty stars.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"‚òÖ\", count: filledStars) + String(repeating: \"‚òÜ\", count: emptyStars)\n}\n\n### Function:\n\n/// Returns a string of filled and empty stars to represent a rating.\n/// - Parameter rating: The rating between 0 and 5.\n/// - Returns: A string of filled and empty stars.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"‚òÖ\", count: filledStars) + String(repeating: \"‚òÜ\", count: emptyStars)\n}\n\n### Function:\n\n///",
      "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç.\n/// - Returns: `true`, –µ—Å–ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω.\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n\n/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç.\n/// - Returns: `true`, –µ—Å–ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω.\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n\n/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç.\n/// - Returns: `true`, –µ—Å–ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω.\nfunc isInternetAvailable() -> Bool {\n    return true\n}\n\n/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç.\n/// - Returns: `true`, –µ—Å",
      "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É —Å —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—ã–º —Å—Ç–∞—Ç—É—Å–æ–º –¥–æ—Å—Ç–∞–≤–∫–∏ –ø–æ –¥–∞—Ç–µ.\n/// - Parameter deliveryDate: –î–∞—Ç–∞ –¥–æ—Å—Ç–∞–≤–∫–∏.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—ã–º —Å—Ç–∞—Ç—É—Å–æ–º –¥–æ—Å—Ç–∞–≤–∫–∏.\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"–°–µ–≥–æ–¥–Ω—è\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"–ó–∞–≤—Ç—Ä–∞\"\n    } else {\n        return \"–ü–æ–∑–∂–µ\"\n    }\n}\n\n### –ü—Ä–∞–≤–∏–ª–∞\n\n- –û–±—ä—è–≤–ª—è–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é —Å –∏–º–µ–Ω–µ–º –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ —Ç–∏–ø–∞.\n- –î–æ–±–∞–≤—å—Ç–µ —Å—Ç",
      "/// Converts an array of strings into a string with hashtags.\n/// - Parameter tags: An array of strings.\n/// - Returns: A string with hashtags.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}\n\nFunction:\n\nfunc count(_ numbers: [Int]) -> Int {\n    return numbers.count\n}\n## Documentation:\n/// Counts the number of elements in an array.\n/// - Parameter numbers: An array of integers.\n/// - Returns: The number of elements in the array.\nfunc count(_ numbers: [Int]) -> Int {\n    return numbers.count\n}\n\nFunction:\n\nfunc sum(_ numbers: [Int]) -> Int {\n    return numbers.reduce(0, +)\n}\n## Documentation:\n/// Calculates the sum of an array of integers.\n/// - Parameter numbers: An array of integers.\n/// - Returns: The sum of the array.\nfunc sum(_ numbers: [Int]) -> Int {\n    return numbers.reduce(0",
      "/// Saves the current scroll offset for the ProductListView.\n/// - Parameter offset: The offset to save.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}\n\n### Function:\n\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}\n## Documentation:\n/// Saves the current scroll offset for the ProductListView.\n/// - Parameter offset: The offset to save.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}\n\n### Function:\n\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}\n## Documentation:\n/// Saves the current scroll offset for the ProductListView.\n/// - Parameter offset: The offset to save.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults",
      "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –≤—Ö–æ–¥–∏—Ç –ª–∏ –ø–æ–ª—É—á–µ–Ω–Ω–∞—è —Ç–æ—á–∫–∞ –≤ –¥–æ—Å—Ç–∞–≤–∫—É.\n/// - Parameters:\n///   - lat: –®–∏—Ä–æ—Ç–∞.\n///   - lon: –î–æ–ª–≥–æ—Ç–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Ç–æ—á–∫–∞ –≤–Ω—É—Ç—Ä–∏ –¥–æ—Å—Ç–∞–≤–∫–∏.\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // –ú–æ—Å–∫–≤–∞\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}\n\n## Test:\n/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –≤—Ö–æ–¥–∏—Ç –ª–∏ –ø–æ–ª—É—á–µ–Ω–Ω–∞—è —Ç–æ—á–∫–∞ –≤ –¥–æ—Å—Ç–∞–≤–∫—É.\n/// - Parameters:\n///  ",
      "/// Returns a product Deeplink.\n/// - Parameter productId: The product ID.\n/// - Returns: A Deeplink.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\n/// Returns a product Deeplink.\n/// - Parameter productId: The product ID.\n/// - Returns: A Deeplink.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\n/// Returns a product Deeplink.\n/// - Parameter productId: The product ID.\n/// - Returns: A Deeplink.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}\n\n/// Returns a product Deeplink.\n/// - Parameter productId: The product ID.\n/// - Returns: A Deeplink.\nfunc generateProductDeeplink(productId: String)",
      "/// Determines if a new message has been received since the last time the user viewed it.\n/// - Parameters:\n///   - lastViewedId: The last time the user viewed the message.\n///   - newMessageId: The new message ID.\n/// - Returns: `true` if the new message has been received since the last time the user viewed it.\n/// - Complexity: O(1)\n\n/// Determines if a new message has been received since the last time the user viewed it.\n/// - Parameters:\n///   - lastViewedId: The last time the user viewed the message.\n///   - newMessageId: The new message ID.\n/// - Returns: `true` if the new message has been received since the last time the user viewed it.\n/// - Complexity: O(1)\n\n/// Determines if a new message has been received since the last time the user viewed it.\n/// - Parameters:\n///   - lastViewedId: The last time the user viewed the message.\n///   - newMessageId: The new message ID.\n/// - Returns",
      "/// Calculates the percentage of completion for a progress bar.\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of completion.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}\n\n### 1.1.1. Parameter\n\n/// Calculates the percentage of completion for a progress bar.\n/// - Parameters:\n///   - current: The current value.\n///   - target: The target value.\n/// - Returns: The percentage of completion.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}\n\n### 1.1.2. Return\n\n/// Calculates the percentage of completion for a progress bar.\n/// - Parameters:\n///",
      "/// Returns a URL to the Terms and Conditions page for the given locale.\n/// - Parameter locale: The locale of the page.\n/// - Returns: A URL to the page.\nfunc termsAndConditionsURL(locale: String) -> URL? {\n    let urlString = \"https://example.com/terms_\\(locale).html\"\n    return URL(string: urlString)\n}\n\nFunction:\n\nfunc loadImage(_ url: URL) -> Data? {\n    return try? Data(contentsOf: url)\n}\n## Documentation:\n/// Loads an image from a URL.\n/// - Parameter url: The URL to the image.\n/// - Returns: The image data, or `nil`.\nfunc loadImage(_ url: URL) -> Data? {\n    return try? Data(contentsOf: url)\n}\n\nFunction:\n\nfunc someFunction(_ someParameter: String, _ anotherParameter: Int) -> Bool {\n    return true\n}\n## Documentation:\n/// Returns `true` if the given parameters are both `String` and `Int`.\n/// - Parameters:\n///   - someParameter: The",
      "///-isEventStarted(at:)\n///Returns `true` if the given date is after today.\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}\n\nFunction:\n\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}\n## Documentation:\n///-isEventStarted(at:)\n///Returns `true` if the given date is after today.\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}\n\nFunction:\n\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}\n## Documentation:\n///-isEventStarted(at:)\n///Returns `true` if the given date is after today.\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}\n\nFunction:\n\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}\n## Documentation:\n///-isEventStarted(",
      "/// Save the current user's theme to UserDefaults.\n/// - Parameter theme: The theme to save.\nfunc saveUserTheme(_ theme: String) {\n    UserDefaults.standard.set(theme, forKey: \"appTheme\")\n}\n\n## Notes:\n/// The current user's theme is saved to UserDefaults.\n\n## Examples:\n/// This function saves the current user's theme to UserDefaults.\n/// - Parameter theme: The theme to save.\nfunc saveUserTheme(_ theme: String) {\n    UserDefaults.standard.set(theme, forKey: \"appTheme\")\n}\n\n## Related:\n/// [`UserDefaults`](https://developer.apple.com/documentation/user_interface_engineering/user_defaults)\n/// [`UserDefaults.standard`](https://developer.apple.com/documentation/user_interface_engineering/user_defaults/standard)\n/// [`set(_:forKey:)`](https://developer.apple.com/documentation/user_interface_engineering/user_defaults/set_forkey",
      "/// Get the theme of the user's current device.\n/// - Returns: The theme, or `nil` if it cannot be determined.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}\n\n/// Get the theme of the user's current device.\n/// - Returns: The theme, or `nil` if it cannot be determined.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}\n\n/// Get the theme of the user's current device.\n/// - Returns: The theme, or `nil` if it cannot be determined.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}\n\n/// Get the theme of the user's current device.\n/// - Returns: The theme, or `nil` if it cannot be determined.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")",
      "/// Clears the user session by removing all stored user data from the user defaults.\n/// - Parameter keys: The keys to remove.\nfunc clearUserSession(_ keys: [String]) {\n    keys.forEach { UserDefaults.standard.removeObject(forKey: $0) }\n}\n\nFunction:\n\nfunc getUserProfile() -> UserProfile? {\n    guard let profileData = UserDefaults.standard.data(forKey: \"userProfile\") else { return nil }\n    return try? JSONDecoder().decode(UserProfile.self, from: profileData)\n}\n## Documentation:\n\n/// Gets the user profile from the user defaults.\n/// - Returns: The user profile or `nil`.\nfunc getUserProfile() -> UserProfile? {\n    guard let profileData = UserDefaults.standard.data(forKey: \"userProfile\") else { return nil }\n    return try? JSONDecoder().decode(UserProfile.self, from: profileData)\n}\n\nFunction:\n\nfunc getUserProfile(_ completion: @escaping (UserProfile?) -> Void) {\n    guard let profileData = UserDefault",
      "/// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ—Ç–∑—ã–≤ –¥–ª—è —Å–∏—Å—Ç–µ–º—ã.\n/// - Returns: –û—Ç–∑—ã–≤ –≤ —Ñ–æ—Ä–º–∞—Ç–µ Markdown.\nfunc generateFeedbackTemplate() -> String {\n    let systemVersion = UIDevice.current.systemVersion\n    let model = UIDevice.current.model\n    return \"–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: \\(model)\\n–í–µ—Ä—Å–∏—è iOS: \\(systemVersion)\\n–í–∞—à –æ—Ç–∑—ã–≤: \"\n}\n\nFunction:\n\nfunc generateFeedbackTemplate(_ systemVersion: String, model: String) -> String {\n    return \"–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: \\(model)\\n–í–µ—Ä—Å–∏—è iOS: \\(systemVersion)\\n–í–∞—à –æ—Ç–∑—ã–≤: \"\n}\n## Documentation:\n/// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ—Ç–∑—ã–≤ –¥–ª—è —Å–∏—Å—Ç–µ–º—ã.\n/// - Parameters:\n///   - systemVersion: –í–µ—Ä—Å–∏—è iOS.\n///   - model: –ú–æ–¥–µ–ª—å —É—Å—Ç—Ä–æ–π—Å—Ç",
      "/// Determines if a count value is greater than the free limit.\n/// - Parameter count: The count value.\n/// - Returns: `true` if the count is greater than the free limit.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n\n/// Determines if a count value is greater than the free limit.\n/// - Parameter count: The count value.\n/// - Returns: `true` if the count is greater than the free limit.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n\n/// Determines if a count value is greater than the free limit.\n/// - Parameter count: The count value.\n/// - Returns: `true` if the count is greater than the free limit.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}\n\n/// Determines if a count value is greater than the free limit.\n/// - Parameter count: The count value.\n//",
      "/// Formats a date to a string in the format \"dd MMM yyyy\".\n/// - Parameter date: The date to format.\n/// - Returns: A string representation of the date.\nfunc formatOrderDate(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd MMM yyyy\"\n    return formatter.string(from: date)\n}\n\n## Markdown:\n# FormatOrderDate(_:)\n/// Formats a date to a string in the format \"dd MMM yyyy\".\n/// - Parameter date: The date to format.\n/// - Returns: A string representation of the date.\nfunc formatOrderDate(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd MMM yyyy\"\n    return formatter.string(from: date)\n}\n\n## Swift Playgrounds:\nPlaygroundPage.current.setLiveView(formatOrderDate(Date()))\n\n## SwiftUI:\n@State private var date = Date()\n\nButton(action: {\n    date = Date()\n})",
      "/// Returns the number of days between two dates.\n/// - Parameters:\n///   - from: The start date.\n///   - to: The end date.\n/// - Returns: The number of days.\nfunc daysBetween(_ from: Date, _ to: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: from, to: to).day ?? 0\n}\n\nFunction:\n\nfunc find(_ array: [Int], _ value: Int) -> Int? {\n    return array.first(where: { $0 == value })\n}\n## Documentation:\n/// Finds the first occurrence of a value in an array.\n/// - Parameters:\n///   - array: The array to search.\n///   - value: The value to find.\n/// - Returns: The index of the value, or `nil` if not found.\nfunc find(_ array: [Int], _ value: Int) -> Int? {\n    return array.first(where: { $0 == value })\n}\n\nFunction:\n\nfunc find(_ array: [Int], _ value: Int",
      "/// Saves the last seen banner ID to UserDefaults.\n/// - Parameter id: The ID of the last seen banner.\n/// - Returns: Nothing.\n/// - Requires: A valid banner ID.\nfunc saveLastSeenBannerId(_ id: String) {\n    UserDefaults.standard.set(id, forKey: \"lastSeenBannerId\")\n}\n\n### Example\n\n/// Saves the last seen banner ID to UserDefaults.\n/// - Parameter id: The ID of the last seen banner.\n/// - Returns: Nothing.\n/// - Requires: A valid banner ID.\nfunc saveLastSeenBannerId(_ id: String) {\n    UserDefaults.standard.set(id, forKey: \"lastSeenBannerId\")\n}\n\n## Documentation:\n/// Saves the last seen banner ID to UserDefaults.\n/// - Parameter id: The ID of the last seen banner.\n/// - Returns: Nothing.\n/// - Requires: A valid banner ID.\nfunc saveLastSeenBannerId(_ id: String) {\n    UserDefaults",
      "/// Refreshes the cache when the last update is more than six hours old.\n/// - Parameter since: The last update.\n/// - Returns: `true` if the cache should be refreshed.\nfunc shouldRefreshCache(since lastUpdate: Date) -> Bool {\n    return Date().timeIntervalSince(lastUpdate) > 6 * 3600\n}\n\n## Notes:\n/// Refreshes the cache when the last update is more than six hours old.\n/// - Parameter since: The last update.\n/// - Returns: `true` if the cache should be refreshed.\nfunc shouldRefreshCache(since lastUpdate: Date) -> Bool {\n    return Date().timeIntervalSince(lastUpdate) > 6 * 3600\n}\n\n## Details:\n/// Refreshes the cache when the last update is more than six hours old.\n/// - Parameter since: The last update.\n/// - Returns: `true` if the cache should be refreshed.\nfunc shouldRefreshCache(since lastUpdate: Date) -> Bool {\n    return Date().timeIntervalSince(lastUpdate) > 6",
      "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å.\n/// - Returns: `true`, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω, –∏–Ω–∞—á–µ `false`.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞\n    return !token.isEmpty\n}\n\n## Test\nimport XCTest\n\nclass IsUserLoggedInTests: XCTestCase {\n    func testIsUserLoggedIn() {\n        let isUserLoggedIn = isUserLoggedIn()\n        XCTAssertEqual(isUserLoggedIn, true)\n    }\n}\n\n## –ö—Ä–∏—Ç–µ—Ä–∏–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏\n\n–†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ñ",
      "/// Checks if a user is a new registrant.\n/// - Parameter registrationDate: The registration date.\n/// - Returns: `true` if the user is new, `false` otherwise.\n/// - Complexity: O(1).\nfunc isNewUser(registrationDate: Date) -> Bool {\n    return Date().timeIntervalSince(registrationDate) < 7 * 86400\n}\n\nFunction:\n\nfunc sumOfSquares(_ numbers: [Int]) -> Int {\n    return numbers.map { $0 * $0 }.reduce(0, +)\n}\n## Documentation:\n/// Calculates the sum of the squares of a list of numbers.\n/// - Parameter numbers: The numbers to square and sum.\n/// - Returns: The sum of the squares.\n/// - Complexity: O(n).\nfunc sumOfSquares(_ numbers: [Int]) -> Int {\n    return numbers.map { $0 * $0 }.reduce(0, +)\n}\n\nFunction:\n\nfunc isPrime(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n   ",
      "/// Returns the number of times the app has been launched.\n/// - Returns: The number of times the app has been launched.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\n/// Returns the number of times the app has been launched.\n/// - Returns: The number of times the app has been launched.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\n/// Returns the number of times the app has been launched.\n/// - Returns: The number of times the app has been launched.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\n/// Returns the number of times the app has been launched.\n/// - Returns: The number of times the app has been launched.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\n/// Returns the number of times the app has been launched",
      "/// Increments the app's launch count.\n/// - Returns: The new launch count.\nfunc incrementAppLaunchCount() {\n    let count = getAppLaunchCount() + 1\n    UserDefaults.standard.set(count, forKey: \"launchCount\")\n}\n\n/// Returns the current launch count.\n/// - Returns: The current launch count.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\n/// Increments the app's launch count.\n/// - Returns: The new launch count.\nfunc incrementAppLaunchCount() {\n    let count = getAppLaunchCount() + 1\n    UserDefaults.standard.set(count, forKey: \"launchCount\")\n}\n\n/// Returns the current launch count.\n/// - Returns: The current launch count.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}\n\n/// Increments the app's launch count.\n/// - Returns: The new launch count.\nfunc increment",
      "/// Checks whether Face ID is available on the device.\n/// - Returns: `true` if Face ID is available.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}\n\n## Discussion:\n/// Checks whether Face ID is available on the device.\n/// - Returns: `true` if Face ID is available.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}\n\n## Best Practices:\n- Use ///-style Swift comments.\n- Include parameter and return descriptions, and emphasize intent over implementation.\n- Return only the comment and the function.\n\n## Example:\n/// Checks whether Face ID is available on the device.\n/// - Returns: `true` if Face ID",
      "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É —Å –∏–º–µ–Ω–µ–º –º–µ—Å—è—Ü–∞ –≤ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ, –µ—Å–ª–∏ –æ–Ω –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –¥–∏–∞–ø–∞–∑–æ–Ω—É –º–µ—Å—è—Ü–µ–≤.\n/// - Parameter month: –ú–µ—Å—è—Ü –≤ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å –∏–º–µ–Ω–µ–º –º–µ—Å—è—Ü–∞ –≤ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ.\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.monthSymbols[safe: month - 1] ?? \"\"\n}\n\n/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É —Å –∏–º–µ–Ω–µ–º –º–µ—Å—è—Ü–∞ –≤ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ, –µ—Å–ª–∏ –æ–Ω –ø—Ä–∏–Ω–∞–¥–ª–µ",
      "/// Returns the URL for getting orders for a user.\n/// - Parameter userId: The ID of the user.\n/// - Returns: The URL for getting the user's orders.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}\n\n/// Returns the URL for getting orders for a user.\n/// - Parameter userId: The ID of the user.\n/// - Returns: The URL for getting the user's orders.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}\n\n/// Returns the URL for getting orders for a user.\n/// - Parameter userId: The ID of the user.\n/// - Returns: The URL for getting the user's orders.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}\n\n/// Returns the",
      "/// Returns whether dark mode is enabled.\n/// - Returns: `true` if dark mode is enabled, `false` otherwise.\nfunc isDarkModeEnabled() -> Bool {\n    return UserDefaults.standard.bool(forKey: \"darkMode\")\n}\n\nFunction:\n\nfunc loadImage(_ url: URL, completion: @escaping (Data?, Error?) -> Void) {\n    URLSession.shared.dataTask(with: url) { data, response, error in\n        DispatchQueue.main.async {\n            completion(data, error)\n        }\n    }.resume()\n}\n## Documentation:\n/// Loads an image from a URL.\n/// - Parameters:\n///   - url: The URL of the image.\n///   - completion: A closure to be called when the image is loaded.\nfunc loadImage(_ url: URL, completion: @escaping (Data?, Error?) -> Void) {\n    URLSession.shared.dataTask(with: url) { data, response, error in\n        DispatchQueue.main.async {\n            completion(data, error)\n        }\n    }.resume()\n}",
      "/// Checks if location access has been granted.\n/// - Returns: `true` if location access is granted, `false` otherwise.\nfunc isLocationAccessGranted() -> Bool {\n    return CLLocationManager.authorizationStatus() == .authorizedWhenInUse || CLLocationManager.authorizationStatus() == .authorizedAlways\n}\n\n/// Checks if location access has been granted.\n/// - Returns: `true` if location access is granted, `false` otherwise.\nfunc isLocationAccessGranted() -> Bool {\n    return CLLocationManager.authorizationStatus() == .authorizedWhenInUse || CLLocationManager.authorizationStatus() == .authorizedAlways\n}\n\n/// Checks if location access has been granted.\n/// - Returns: `true` if location access is granted, `false` otherwise.\nfunc isLocationAccessGranted() -> Bool {\n    return CLLocationManager.authorizationStatus() == .authorizedWhenInUse || CLLocationManager.authorizationStatus() == .authorizedAlways\n}\n\n/// Checks if location access has been granted.\n/// - Returns: `true` if location access is granted, `false",
      "/// Formats a number of seconds into a string with leading zeros.\n/// - Parameter seconds: The number of seconds.\n/// - Returns: A string with leading zeros.\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n}\n\nFunction:\n\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n}\n## Documentation:\n/// Formats a number of seconds into a string with leading zeros.\n/// - Parameter seconds: The number of seconds.\n/// - Returns: A string with leading zeros.\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n}\n\nFunction:\n\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n",
      "/// Checks if the number of attempts exceeds the limit.\n/// - Parameter attempts: The number of attempts.\n/// - Returns: `true` if the limit was exceeded.\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}\n\nFunction:\n\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}\n## Documentation:\n/// Checks if the number of attempts exceeds the limit.\n/// - Parameter attempts: The number of attempts.\n/// - Returns: `true` if the limit was exceeded.\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}\n\nFunction:\n\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}\n## Documentation:\n/// Checks if the number of attempts exceeds the limit.\n/// - Parameter attempts: The number of attempts.\n/// - Returns: `true` if the limit was exceeded.\nfunc isPin",
      "/// –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä—É–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ –æ—Ç–≤–µ—Ç–∞ –Ω–∞ –≤–æ–ø—Ä–æ—Å: –ù–∞ —Å–∫–æ–ª—å–∫–æ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ.\n/// - Parameter status: –ö–æ–¥ —Å—Ç–∞—Ç—É—Å–∞ –¥–æ—Å—Ç–∞–≤–∫–∏.\n/// - Returns: –¢–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞.\nfunc deliveryStatusText(for status: String) -> String {\n    switch status {\n    case \"pending\": return \"–û–∂–∏–¥–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏\"\n    case \"shipped\": return \"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ\"\n    case \"delivered\": return \"–î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ\"\n    default: return \"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ\"\n    }\n}\n\n## Discussion:\n\n–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∫ —Ñ—É–Ω–∫—Ü–∏—è–º –ø–æ–º–æ–≥–∞—é—Ç –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞–º –ø–æ–Ω—è—Ç—å, –∫–∞–∫—É—é",
      "/// Resets the app data.\n/// - Returns: Nothing.\nfunc resetAppData() {\n    if let appDomain = Bundle.main.bundleIdentifier {\n        UserDefaults.standard.removePersistentDomain(forName: appDomain)\n    }\n}\n\nFunction:\n\nfunc getUserData(_ key: String) -> String? {\n    guard let data = UserDefaults.standard.object(forKey: key) as? Data else { return nil }\n    return String(data: data, encoding: .utf8)\n}\n## Documentation:\n/// Returns the user data with the given key.\n/// - Parameter key: The key of the data.\n/// - Returns: The data or `nil`.\nfunc getUserData(_ key: String) -> String? {\n    guard let data = UserDefaults.standard.object(forKey: key) as? Data else { return nil }\n    return String(data: data, encoding: .utf8)\n}\n\nFunction:\n\nfunc createUserData(_ key: String, value: String) {\n    UserDefaults.standard.set(value.data(using:",
      "/// Pings a server and returns whether the response indicates a successful connection.\nfunc pingServer(completion: @escaping (Bool) -> Void) {\n    let url = URL(string: \"https://api.example.com/ping\")!\n    URLSession.shared.dataTask(with: url) { _, response, error in\n        let httpResponse = response as? HTTPURLResponse\n        completion(httpResponse?.statusCode == 200 && error == nil)\n    }.resume()\n}\n\nFunction:\n\nfunc checkForDuplicates<T: Hashable>(_ array: [T]) -> Bool {\n    return Set(array).count == array.count\n}\n## Documentation:\n/// Returns `true` if the given array contains no duplicates.\nfunc checkForDuplicates<T: Hashable>(_ array: [T]) -> Bool {\n    return Set(array).count == array.count\n}\n\nFunction:\n\nfunc isValidPassword(_ password: String) -> Bool {\n    return password.count >= 8 && password.containsNumber && password.containsLowercaseLetter && password.containsUpp",
      "/// Saves the current user's preferred language.\n/// - Parameter languageCode: The language code.\nfunc savePreferredLanguage(_ languageCode: String) {\n    UserDefaults.standard.set(languageCode, forKey: \"preferredLanguage\")\n}\n\n/// Returns the current user's preferred language.\n/// - Returns: The language code.\nfunc preferredLanguage() -> String? {\n    return UserDefaults.standard.value(forKey: \"preferredLanguage\") as? String\n}\n\n/// Returns the current user's preferred language.\n/// - Returns: The language code.\nfunc preferredLanguage() -> String? {\n    return UserDefaults.standard.value(forKey: \"preferredLanguage\") as? String\n}\n\n/// Saves the current user's preferred language.\n/// - Parameter languageCode: The language code.\nfunc savePreferredLanguage(_ languageCode: String) {\n    UserDefaults.standard.set(languageCode, forKey: \"preferredLanguage\")\n}\n\n/// Saves the current user's preferred language.\n/// - Parameter languageCode: The language code.\nfunc savePreferred",
      "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω—ã–π —è–∑—ã–∫.\n/// - Returns: –ü—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω—ã–π —è–∑—ã–∫.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"ru\"\n}\n\nFunction:\n\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"ru\"\n}\n## Documentation:\n/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω—ã–π —è–∑—ã–∫.\n/// - Returns: –ü—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω—ã–π —è–∑—ã–∫.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"ru\"\n}\n\nFunction:\n\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\")",
      "/// Checks if a text contains a non-integer number.\n/// - Parameter text: The text to check.\n/// - Returns: `true`, if the text contains a non-integer number.\nfunc isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor(number) != number\n    }\n    return false\n}\n\n## Discussion:\nThis is a simple function that checks if a string contains a non-integer number. It does so by converting the string to a double, and then checking if the result is equal to the floor of the double.\n\nThe function has a single parameter, `text`, which is the string to check. It returns a boolean value, indicating whether the string contains a non-integer number.\n\nThe function uses the `Double` type to convert the string to a double. This is because `Double` is a floating-point type, which can represent decimal numbers more accurately than `Int` or `Float`.\n\nThe function then uses the `floor` method to round down the double to the nearest integer. This is done to ensure that the result is always an integer, even if the original number was",
      "/// - Parameter character: The character to repeat.\n/// - Parameter count: The number of times to repeat the character.\n/// - Returns: A string containing the repeated character.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}\n\n/// - Parameter character: The character to repeat.\n/// - Parameter count: The number of times to repeat the character.\n/// - Returns: A string containing the repeated character.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}\n\n/// - Parameter character: The character to repeat.\n/// - Parameter count: The number of times to repeat the character.\n/// - Returns: A string containing the repeated character.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}\n\n/// - Parameter character: The character to repeat.\n/// - Parameter count: The number of times to repeat the character.\n",
      "/// - Parameter text: The string to check.\n/// - Parameter array: The array of strings to search in.\n/// - Returns: `true` if the string is unique in the array.\n/// - Complexity: O(N), where N is the number of elements in the array.\nfunc isUniqueString(_ text: String, in array: [String]) -> Bool {\n    return array.filter { $0 == text }.count == 1\n}\n\n/// Checks if a string is unique in an array.\n/// - Parameters:\n///   - text: The string to check.\n///   - array: The array of strings to search in.\n/// - Returns: `true` if the string is unique in the array.\nfunc isUniqueString(_ text: String, in array: [String]) -> Bool {\n    return array.filter { $0 == text }.count == 1\n}\n\n/// - Parameters:\n///   - text: The string to check.\n///   - array: The array of strings to search in.\n/// - Returns: `true` if the string is unique in",
      "/// Returns a rounded number with the specified number of decimals.\n/// - Parameters:\n///   - text: The text to round.\n///   - decimals: The number of decimals to round to.\n/// - Returns: A rounded number.\nfunc roundedNumber(from text: String, decimals: Int) -> Double? {\n    guard let number = Double(text) else { return nil }\n    return round(number * pow(10, Double(decimals))) / pow(10, Double(decimals))\n}\n\n### Function:\n\nfunc roundedNumber(from text: String, decimals: Int) -> Double? {\n    guard let number = Double(text) else { return nil }\n    return round(number * pow(10, Double(decimals))) / pow(10, Double(decimals))\n}\n\n### Documentation:\n/// Returns a rounded number with the specified number of decimals.\n/// - Parameters:\n///   - text: The text to round.\n///   - decimals: The number of decimals to round to.\n/// - Returns: A rounded number.\nfunc roundedNumber(from text:",
      "/// Extracts all digits in order from a string.\n/// - Parameter text: The string to process.\n/// - Returns: The string without non-numeric characters.\nfunc extractDigitsInOrder(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n\n## Documenting a Swift function\n\nYou are documenting a Swift codebase. Given a function and a short description of where and how it is used, write a documentation comment that helps future developers understand its purpose.\nUse ///-style Swift comments.\nInclude parameter and return descriptions, and emphasize intent over implementation.\nReturn only the comment and the function.\n\nFunction:\n\nfunc extractDigitsInOrder(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n## Documentation:\n/// Extracts all digits in order from a string.\n/// - Parameter text: The string to process.\n/// - Returns: The string without non-numeric characters.\nfunc extractDigitsInOrder(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n\n## Document",
      "/// Converts a string to a cobol-case-formatted string.\n/// - Parameter text: The text to convert.\n/// - Returns: A cobol-case-formatted string.\nfunc toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}\n\n## Why?\n\n/// Converts a string to a cobol-case-formatted string.\n/// - Parameter text: The text to convert.\n/// - Returns: A cobol-case-formatted string.\nfunc toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}\n",
      "/// Removes all occurrences of characters in a `String` from another `String`.\n/// - Parameters:\n///   - text: The text to remove characters from.\n///   - charactersToRemove: The characters to remove.\n/// - Returns: A `String` with all occurrences of characters in `charactersToRemove` removed.\nfunc removeCharactersFromString(_ text: String, charactersToRemove: String) -> String {\n    return text.filter { !charactersToRemove.contains($0) }\n}\n\n/// Removes all occurrences of characters in a `String` from another `String`.\n/// - Parameters:\n///   - text: The text to remove characters from.\n///   - charactersToRemove: The characters to remove.\n/// - Returns: A `String` with all occurrences of characters in `charactersToRemove` removed.\nfunc removeCharactersFromString(_ text: String, charactersToRemove: String) -> String {\n    return text.filter { !charactersToRemove.contains($0) }\n}\n\n/// Removes all occurrences of characters in a `String` from another `String`.",
      "/// Returns `true` if the input string is a whole number.\n/// - Parameter text: The text to check.\n/// - Returns: `true` if the string represents a whole number, `false` otherwise.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}\n\n## Example:\n/// Returns `true` if the input string is a whole number.\n/// - Parameter text: The text to check.\n/// - Returns: `true` if the string represents a whole number, `false` otherwise.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}\n\n/// Returns `true` if the input string is a whole number.\n/// - Parameter text: The text to check.\n/// - Returns: `true` if the string represents a whole number, `false` otherwise.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}\n\n## Challenge:\nWrite a function to determine if a string is a whole number.\n\n**Hint:** Use",
      "/// Returns `true` if `text` contains the given `substring`.\n/// - Parameters:\n///   - substring: The substring to search for.\n///   - text: The text to search in.\n/// - Returns: `true` if the substring is found, `false` otherwise.\nfunc containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n}\n\n## Example\n\nIn this example, we have a function that checks if a given string contains a substring. The function has a short description of what it does, and includes a parameter and return description.\n\n### Example:\n\n/// Returns `true` if `text` contains the given `substring`.\n/// - Parameters:\n///   - substring: The substring to search for.\n///   - text: The text to search in.\n/// - Returns: `true` if the substring is found, `false` otherwise.\nfunc containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n",
      "/// Returns a list of words in the given text, capitalized.\nfunc stringToCapitalizedWords(_ text: String) -> [String] {\n    return text.split(separator: \" \").map { $0.capitalized }\n}\n\nFunction:\n\nfunc countWords(_ text: String) -> Int {\n    return text.split(separator: \" \").count\n}\n## Documentation:\n/// Counts the number of words in the given text.\nfunc countWords(_ text: String) -> Int {\n    return text.split(separator: \" \").count\n}\n\nFunction:\n\nfunc calculate(_ value: Double, _ power: Int) -> Double {\n    return pow(value, power)\n}\n## Documentation:\n/// Calculates the value of a number raised to a power.\nfunc calculate(_ value: Double, _ power: Int) -> Double {\n    return pow(value, power)\n}\n\nFunction:\n\nfunc isEven(_ number: Int) -> Bool {\n    return number % 2 == 0\n}\n## Documentation:\n/// Determines whether a number is even.\nfunc isEven(_",
      "/// Converts a string to alternating case.\n/// - Parameter text: The input string.\n/// - Returns: The converted string.\nfunc alternatingCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, character) in\n        index % 2 == 0 ? character.lowercased() : character.uppercased()\n    })\n}\n\n## Notes:\n\n* The `enumerated()` method is useful for converting a string to alternating case.\n* This function is useful for converting text to alternating case.\n* The `enumerated()` method returns an array of tuples, where each tuple contains an index and a character.\n* The `map()` function applies a given closure to each element of the array and returns a new array.\n* The `%` operator returns the remainder of a division operation.\n* The `%` operator is useful for converting a number to alternating case.\n\n## References:\n\n* [Swift Docs](https://docs.swift.org/swift-book/ReferenceManual/Concepts/Comments.html)\n* [Enumerated](https://developer.apple.com",
      "/// Finds the first occurrence of a substring in a string, returning the index of the first character.\n/// - Parameters:\n///   - substring: The substring to search for.\n///   - text: The string to search.\n/// - Returns: The index of the first occurrence of the substring, or `nil` if not found.\nfunc indexOfSubstring(_ substring: String, in text: String) -> Int? {\n    return text.range(of: substring)?.lowerBound.utf16Offset(in: text)\n}\n\n## Note\n\n/// Finds the first occurrence of a substring in a string, returning the index of the first character.\n/// - Parameters:\n///   - substring: The substring to search for.\n///   - text: The string to search.\n/// - Returns: The index of the first occurrence of the substring, or `nil` if not found.\nfunc indexOfSubstring(_ substring: String, in text: String) -> Int? {\n    return text.range(of: substring)?.lowerBound.utf16",
      "/// Returns `true` if the given text is a palindrome, ignoring case, and contains only letters.\nfunc isAlphaOnlyPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}\n\nFunction:\n\nfunc isPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}\n## Documentation:\n/// Returns `true` if the given text is a palindrome, ignoring case, and contains only letters.\nfunc isPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}\n\nFunction:\n\nfunc isAlphaOnlyPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}\n## Documentation:\n",
      "/// Extracts uppercase letters from a string.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}\n\n/// Extracts uppercase letters from a string.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}\n\n/// Extracts uppercase letters from a string.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}\n\n/// Extracts uppercase letters from a string.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}\n\n/// Extracts uppercase letters from a string.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}\n\n/// Extracts uppercase letters from a string.\nfunc extractUppercaseLetters(from text: String) ->",
      "/// Returns `true` if the string is a binary number.\n/// - Parameter text: The string to test.\n/// - Returns: `true` if all characters are either `0` or `1`.\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}\n\nFunction:\n\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}\n## Documentation:\n/// Returns `true` if the string is a binary number.\n/// - Parameter text: The string to test.\n/// - Returns: `true` if all characters are either `0` or `1`.\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}\n\nFunction:\n\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" ||",
      "/// Capitalizes the first letter of a string.\n/// - Parameter text: The string to capitalize.\n/// - Returns: The capitalized string.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}\n\n## What you should see:\n/// Capitalizes the first letter of a string.\n/// - Parameter text: The string to capitalize.\n/// - Returns: The capitalized string.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}\n\n## Why:\n/// Swift documentation comments are a convenient way to provide a quick summary of a function's purpose and usage.\n/// - Parameter text: The string to capitalize.\n/// - Returns: The capitalized string.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}\n\n",
      "/// Converts a string to an array of characters.\n/// - Parameter text: The text to convert.\n/// - Returns: An array of characters.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}\n\n### In-Depth:\n\nSwift's documentation comments are simple to write and easy to read.\n\nA Swift function is documented by writing a single /// comment at the beginning of the function.\n\nThe first line of the comment should describe the function's purpose.\n\nYou can use the following keywords to describe the function:\n\n- Parameter: The name of a parameter.\n- Return: The name of the function's return value.\n- Where: The name of the function's scope.\n\nThe second line of the comment should describe the function's parameters, and the third line should describe the function's return value.\n\nYou can use the following keywords to describe the parameters:\n\n- Parameter: The name of a parameter.\n- Return: The name of the function's return value.\n\nThe following example shows how to write a function's documentation comments.\n\nfunc stringToCharArray(_ text:",
      "/// Repeats a string a specified number of times.\n/// - Parameters:\n///   - text: The string to repeat.\n///   - count: The number of times to repeat the string.\n/// - Returns: A new string with the specified text repeated count times.\n/// - Example:\n///   - repeatString(\"Hello\", count: 3)\n///     /// \"HelloHelloHello\"\n\n/// - Example:\n///   - repeatString(\"World\", count: 2)\n///     /// \"WorldWorld\"\n\n/// - Example:\n///   - repeatString(\" \", count: 3)\n///     /// \" \"\n/// - Example:\n///   - repeatString(\"!\", count: 1)\n///     /// \"!\"\n\n/// - Example:\n///   - repeatString(\"!\", count: 10)\n///     /// \"!!!!!!!!!\"\n\n/// - Example:\n///   - repeatString(\"Hello\", count: 3)\n///     /// \"HelloHelloHello\"\n\n/// - Example",
      "/// Returns `true` if the given string is a valid time (e.g. \"13:30\").\n/// - Parameter text: The time to validate.\n/// - Returns: `true` if the time is valid.\nfunc isValidTime(_ text: String) -> Bool {\n    let pattern = \"^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$\"\n    return matchesRegex(text, pattern: pattern)\n}\n\n## How it works\n\nThe function has a single parameter, a string representing a time in the format \"HH:MM\", and a return type of `Bool`.\n\nThe function body contains a single statement that checks whether the input matches a regex pattern.\n\nThe regex pattern is defined in the function's comment, using the `///-` style.\n\nThe function returns `true` if the input matches the pattern, and `false` otherwise.\n\n## Tips\n\nWrite a single comment that explains the function's purpose and behavior.\n\nExplain the purpose of each parameter in the function's comment.\n\nUse the `///-",
      "/// Extracts digits and dashes from a string.\n/// - Parameter text: The string to process.\n/// - Returns: A string with digits and dashes.\n\n## Parameters\n- `text`: The string to process.\n\n## Returns\nA string with digits and dashes.\n\n## Notes\n- The function filters the given text to keep only digits and dashes.\n\n## Example\n```swift\nlet text = \"123-456-7890\"\nlet result = extractDigitsAndDashes(from: text)\n// \"123-456-7890\"\n```\n\n---\n\n# 001-write-a-function-that-returns-the-number-of-digits-in-a-string\n\nYou are documenting a Swift codebase. Given a function and a short description of where and how it is used, write a documentation comment that helps future developers understand its purpose.\nUse ///-style Swift comments.\nInclude parameter and return descriptions, and emphasize intent over implementation.\nReturn only the comment and the function.\n\nFunction:\n\nfunc countDigits",
      "/// Returns a new string with lowercase letters from the input string without\n/// numbers.\n/// - Parameter text: The text to filter.\n/// - Returns: A new string with lowercase letters.\nfunc lowercaseLettersWithoutNumbers(from text: String) -> String {\n    return text.filter { $0.isLetter }.lowercased()\n}\n\nFunction:\n\nfunc countDigits(_ in: String) -> Int {\n    return in.filter { $0.isNumber }.count\n}\n## Documentation:\n/// Returns the number of digits in the given string.\n/// - Parameter in: The string to count digits from.\n/// - Returns: The number of digits in the string.\nfunc countDigits(_ in: String) -> Int {\n    return in.filter { $0.isNumber }.count\n}\n\nFunction:\n\nfunc filterNumbers(_ in: String) -> String {\n    return in.filter { $0.isNumber }\n}\n## Documentation:\n/// Filters the given string to remove all non-numeric characters.\n/// - Parameter in: The string to filter.\n/// - Returns: A",
      "/// Checks if all strings in an array have the same length.\n/// - Parameter array: An array of strings.\n/// - Returns: `true` if all strings have the same length, `false` otherwise.\nfunc allStringsHaveEqualLength(_ array: [String]) -> Bool {\n    guard let firstLength = array.first?.count else { return true }\n    return array.allSatisfy { $0.count == firstLength }\n}\n\n/// Checks if all strings in an array have the same length.\n/// - Parameter array: An array of strings.\n/// - Returns: `true` if all strings have the same length, `false` otherwise.\nfunc allStringsHaveEqualLength(_ array: [String]) -> Bool {\n    guard let firstLength = array.first?.count else { return true }\n    return array.allSatisfy { $0.count == firstLength }\n}\n\n/// Checks if all strings in an array have the same length.\n/// - Parameter array: An array of strings.\n/// - Returns: `true` if all strings have the same length, `false` otherwise",
      "/// Splits a string by a character, returning an array of strings.\nfunc splitStringByCharacter(_ text: String, separator: Character) -> [String] {\n    return text.split(separator: separator).map { String($0) }\n}\n\n### Description\n\nSplits a string by a character, returning an array of strings.\n\n### Parameters\n\n- `text`: The string to split.\n- `separator`: The character to split by.\n\n- Returns: An array of strings, where each string is a substring of the input string separated by the given character.\n\n### Example\n\n/// Splits a string by a character, returning an array of strings.\n/// - Parameters:\n///   - text: The string to split.\n///   - separator: The character to split by.\n/// - Returns: An array of strings, where each string is a substring of the input string separated by the given character.\nfunc splitStringByCharacter(_ text: String, separator: Character) -> [String] {\n    return text.split(separator: separator).map { String($0) }\n}\n\n",
      "/// Returns `true` if the given string is a hexadecimal number.\n/// - Parameter text: The string to check.\n/// - Returns: `true` if the string starts with a hexadecimal digit.\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}\n\n## Sample usage\n\nisHexadecimalNumber(\"FF\") // true\nisHexadecimalNumber(\"0xFF\") // true\nisHexadecimalNumber(\"0XFF\") // false\n\n## Tips\n\nUse /// and ///@ to describe the function's purpose.\nUse ///@ to document a function that returns a value.\nUse ///@ to document a function that accepts a parameter.\nUse ///@ to document a function that returns a value and a parameter.\n\nFunction:\n\nfunc getFibonacci(_ n: Int) -> Int? {\n    guard n >= 2 else { return n }\n    let (a, b) = (",
      "/// Converts a string to a date.\n/// - Parameter text: A date in the format yyyy-MM-dd HH:mm:ss.\n/// - Returns: A date in the same format.\nfunc stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    return formatter.date(from: text)\n}\n\nFunction:\n\nfunc stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    return formatter.date(from: text)\n}\n## Documentation:\n/// Converts a string to a date.\n/// - Parameter text: A date in the format yyyy-MM-dd HH:mm:ss.\n/// - Returns: A date in the same format.\nfunc stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd",
      "/// Cleans a string by removing all whitespace and punctuation characters.\n/// - Parameter text: The text to clean.\n/// - Returns: A new string without whitespace or punctuation.\n\n/// - Parameter text: The text to clean.\n/// - Returns: A new string without whitespace or punctuation.\nfunc cleanString(_ text: String) -> String {\n    let charactersToRemove = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)\n    return text.filter { !charactersToRemove.contains($0.unicodeScalars.first!) }\n}\n\n/// Cleans a string by removing all whitespace and punctuation characters.\n/// - Parameter text: The text to clean.\n/// - Returns: A new string without whitespace or punctuation.\nfunc cleanString(_ text: String) -> String {\n    let charactersToRemove = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)\n    return text.filter { !charactersToRemove.contains($0.unicodeScalars.first!) }\n}\n\n/// Cleans a string by removing all whitespace and punctuation characters",
      "/// Converts a string to an integer using a specified base.\n/// - Parameter text: The string to convert.\n/// - Parameter base: The base of the number.\n/// - Returns: The integer representation of the number.\n/// - Throws: `InvalidBaseError` if the base is not a valid number.\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}\n\n/// Converts a string to an integer using a specified base.\n/// - Parameters:\n///   - text: The string to convert.\n///   - base: The base of the number.\n/// - Returns: The integer representation of the number.\n/// - Throws: `InvalidBaseError` if the base is not a valid number.\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}\n\n/// Converts a string to an integer using a specified base.\n/// - Parameters:\n///   - text: The string to convert.\n//",
      "/// Counts the number of unique characters in a string.\n/// - Parameter text: The string to count.\n/// - Returns: The number of unique characters.\n/// - Complexity: O(n), where n is the length of the string.\n\n/// - Parameters:\n///   - text: The string to count.\n/// - Returns: The number of unique characters.\nfunc countUniqueCharacters(in text: String) -> Int {\n    return Set(text).count\n}\n\n/// Counts the number of unique characters in a string.\n/// - Parameter text: The string to count.\n/// - Returns: The number of unique characters.\n/// - Complexity: O(n), where n is the length of the string.\n\n/// - Parameters:\n///   - text: The string to count.\n/// - Returns: The number of unique characters.\nfunc countUniqueCharacters(in text: String) -> Int {\n    return Set(text).count\n}\n\n/// Counts the number of unique characters in a string.\n/// - Parameter text: The string to count.\n/// - Returns",
      "/// Returns a string with only unique characters.\n/// - Parameter text: A string.\n/// - Returns: A string with only unique characters.\nfunc uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text.reduce(into: [:]) { counts, char in counts[char, default: 0] += 1 }\n    return String(text.filter { characterCount[$0] == 1 })\n}\n\n/// Returns a string with only unique characters.\n/// - Parameter text: A string.\n/// - Returns: A string with only unique characters.\nfunc uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text.reduce(into: [:]) { counts, char in counts[char, default: 0] += 1 }\n    return String(text.filter { characterCount[$0] == 1 })\n}\n\n/// Returns a string with only unique characters.\n/// - Parameter text: A string.\n/// - Returns: A string with only unique characters.\nfunc uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text",
      "/// Checks if a given string is a valid email address.\n/// - Parameter text: The string to check.\n/// - Returns: `true` if the string is a valid email, `false` otherwise.\n/// - Complexity: O(n).\nfunc isValidEmail(_ text: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"\n    return matchesRegex(text, pattern: emailRegex)\n}\n\n/// Checks if a given string is a valid email address.\n/// - Parameter text: The string to check.\n/// - Returns: `true` if the string is a valid email, `false` otherwise.\n/// - Complexity: O(n).\nfunc isValidEmail(_ text: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,",
      "/// Extracts numbers from a string.\n/// - Parameter text: The text to extract numbers from.\n/// - Returns: The extracted numbers as a string.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n\n/// Extracts numbers from a string.\n/// - Parameter text: The text to extract numbers from.\n/// - Returns: The extracted numbers as a string.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n\n/// Extracts numbers from a string.\n/// - Parameter text: The text to extract numbers from.\n/// - Returns: The extracted numbers as a string.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}\n\n/// Extracts numbers from a string.\n/// - Parameter text: The text to extract numbers from.\n/// - Returns: The extracted numbers as a string.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0",
      "/// Converts a string to a percentage.\n/// - Parameters:\n///   - text: The text to convert.\n///   - precision: The number of decimal places to round to.\n/// - Returns: The number as a percentage, or `nil` if the text is invalid.\nfunc stringToPercentage(_ text: String, precision: Int) -> String? {\n    guard let number = Double(text) else { return nil }\n    let percentage = number * 100\n    return String(format: \"%.\\(precision)f%%\", percentage)\n}\n\nDocumentation:\n\n/// Converts a string to a percentage.\n/// - Parameters:\n///   - text: The text to convert.\n///   - precision: The number of decimal places to round to.\n/// - Returns: The number as a percentage, or `nil` if the text is invalid.\nfunc stringToPercentage(_ text: String, precision: Int) -> String? {\n    guard let number = Double(text) else { return nil }\n    let percentage = number * 100\n    return String(format: \"%.",
      "/// Returns a string with alternating uppercase and lowercase letters.\n/// - Parameter text: The text to convert.\n/// - Returns: The converted text.\nfunc alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}\n\n/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º —Ä–µ–∂–∏–º–æ–º —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –û–±—Ä–∞—Ç–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º —Ä–µ–∂–∏–º–æ–º —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è.\nfunc alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}\n",
      "/// - Parameters:\n///   - text: A string to check.\n///   - Returns true if the string is a number.\n/// - Returns: True if the string is a number.\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}\n\nFunction:\n\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}\n## Documentation:\n/// - Parameters:\n///   - text: A string to check.\n///   - Returns true if the string is a number.\n/// - Returns: True if the string is a number.\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}\n\nFunction:\n\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}\n## Documentation:\n/// - Parameters:\n///   - text: A string to check.\n///   - Returns true if the string is a number.\n/// - Returns: True if the string is a number.\n",
      "/// Reverses an array of elements.\n/// - Parameter array: An array of elements.\n/// - Returns: A new array with the elements in reverse order.\n\n/// Reverses an array of elements.\n/// - Parameter array: An array of elements.\n/// - Returns: A new array with the elements in reverse order.\n\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}\n\n/// Reverses an array of elements.\n/// - Parameter array: An array of elements.\n/// - Returns: A new array with the elements in reverse order.\n\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}\n\n/// Reverses an array of elements.\n/// - Parameter array: An array of elements.\n/// - Returns: A new array with the elements in reverse order.\n\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}\n\n/// Reverses an array of elements.\n//",
      "/// Returns a random element from a dictionary.\n/// - Parameter dictionary: A dictionary.\n/// - Returns: A tuple of key-value pair.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}\n\n/// Returns a random element from a dictionary.\n/// - Parameter dictionary: A dictionary.\n/// - Returns: A tuple of key-value pair.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}\n\n/// Returns a random element from a dictionary.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}\n\n/// Returns a random element from a dictionary.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}\n\n",
      "/// Returns the keys with the minimum values in a dictionary.\n/// - Parameter dictionary: A dictionary of values.\n/// - Returns: The keys with the minimum values.\nfunc keysWithMinValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable, Value: Comparable {\n    guard let minValue = dictionary.values.min() else { return [] }\n    return dictionary.filter { $0.value == minValue }.map { $0.key }\n}\n\n#if !swift(5)\n/// Returns the keys with the minimum values in a dictionary.\n/// - Parameter dictionary: A dictionary of values.\n/// - Returns: The keys with the minimum values.\nfunc keysWithMinValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable, Value: Comparable {\n    guard let minValue = dictionary.values.min() else { return [] }\n    return dictionary.filter { $0.value == minValue }.map { $0.key }\n}\n#endif\n\n#if swift(5)\n/// Returns the keys",
      "/// Determines if a given date is in the future.\n/// - Parameter date: A date.\n/// - Returns: `true` if `date` is in the future.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n\nFunction:\n\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n## Documentation:\n/// Determines if a given date is in the future.\n/// - Parameter date: A date.\n/// - Returns: `true` if `date` is in the future.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n\nFunction:\n\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n## Documentation:\n/// Determines if a given date is in the future.\n/// - Parameter date: A date.\n/// - Returns: `true` if `date` is in the future.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}\n\nFunction",
      "/// Converts a string to an array of alphabetic characters.\n/// - Parameter str: The string to convert.\n/// - Returns: An array of alphabetic characters.\nfunc stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}\n\nFunction:\n\nfunc areaOfTriangle(_ base: Double, height: Double) -> Double {\n    return 0.5 * base * height\n}\n## Documentation:\n/// Calculates the area of a triangle.\n/// - Parameters:\n///   - base: The base of the triangle.\n///   - height: The height of the triangle.\n/// - Returns: The area of the triangle.\nfunc areaOfTriangle(_ base: Double, height: Double) -> Double {\n    return 0.5 * base * height\n}\n\nFunction:\n\nfunc areaOfRectangle(_ width: Double, height: Double) -> Double {\n    return width * height\n}\n## Documentation:\n/// Calculates the area of a rectangle.\n/// - Parameters:\n///   - width: The width",
      "/// Calculates the number of days between two dates.\n/// - Parameters:\n///   - startDate: The start date.\n///   - endDate: The end date.\n/// - Returns: The number of days between the dates.\n/// - Complexity: O(1).\nfunc daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}\n\n/// Calculates the number of days between two dates.\n/// - Parameters:\n///   - startDate: The start date.\n///   - endDate: The end date.\n/// - Returns: The number of days between the dates.\n/// - Complexity: O(1).\nfunc daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}\n\n/// Calculates the number of days between two dates.\n/// - Parameters:\n//",
      "/// Returns the sum of all numbers in a string.\n/// - Parameter str: A string containing numbers.\n/// - Returns: The sum of all numbers in the string.\n/// - Complexity: O(n) where n is the length of the string.\n\n/// - Parameter str: A string containing numbers.\n/// - Returns: The sum of all numbers in the string.\nfunc sumOfNumbersInString(_ str: String) -> Int {\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.reduce(0, +)\n}\n\n/// Returns the sum of all numbers in a string.\n/// - Parameter str: A string containing numbers.\n/// - Returns: The sum of all numbers in the string.\nfunc sumOfNumbersInString(_ str: String) -> Int {\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.reduce(0, +)\n}\n\n/// Returns the sum of all numbers in a string.\n/// - Parameter str: A string containing numbers.\n"
    ],
    "REFERENCES": [
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–æ–∫–µ–Ω–∞ –≤ UserDefaults.\n/// - Returns: true, –µ—Å–ª–∏ —Ç–æ–∫–µ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –Ω–µ –∏—Å—Ç—ë–∫.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞\n    return !token.isEmpty\n}"
      ],
      [
        "/// –§–æ—Ä–º–∏—Ä—É–µ—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ —Å—É—Ç–æ–∫.\n/// - Parameter name: –ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Returns: –ü–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ.\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ, \\(name)\"\n    case 12..<18: return \"–î–æ–±—Ä—ã–π –¥–µ–Ω—å, \\(name)\"\n    case 18..<23: return \"–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä, \\(name)\"\n    default: return \"–î–æ–±—Ä–æ–π –Ω–æ—á–∏, \\(name)\"\n    }\n}"
      ],
      [
        "/// –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å—É–º–º—É –≤ —Ä—É–±–ª—è—Ö –≤ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É —Å –≤–∞–ª—é—Ç–æ–π.\n/// - Parameter amount: –°—É–º–º–∞ –≤ —Ä—É–±–ª—è—Ö.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —Å–∏–º–≤–æ–ª–æ–º —Ä—É–±–ª—è.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"‚ÇΩ\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ‚ÇΩ\"\n}"
      ],
      [
        "/// –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å –∑–∞–¥–∞–Ω–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º.\n/// - Parameter message: –¢–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}"
      ],
      [
        "/// –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å onboarding –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–ª–∞–≥–∞ –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ.\n/// - Returns: true, –µ—Å–ª–∏ onboarding –µ—â—ë –Ω–µ –ø—Ä–æ–π–¥–µ–Ω.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}"
      ],
      [
        "/// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞.\n/// - Parameter productId: ID —Ç–æ–≤–∞—Ä–∞.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}"
      ],
      [
        "/// –û—Ü–µ–Ω–∏–≤–∞–µ—Ç, —Å–ª–µ–¥—É–µ—Ç –ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –≤—Å–ø–ª—ã–≤–∞—é—â–µ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.\n/// - Returns: true, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤–∏–¥–µ–ª –±–∞–Ω–Ω–µ—Ä –±–æ–ª–µ–µ —Å—É—Ç–æ–∫.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ —Å—Ç—Ä–æ–∫—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ UI.\n/// - Parameters:\n///   - lat: –®–∏—Ä–æ—Ç–∞.\n///   - lon: –î–æ–ª–≥–æ—Ç–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∑–∞–ø–æ–ª–Ω–µ–Ω—ã –ª–∏ –≤—Å–µ –ø–æ–ª—è –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Parameter profile: –°–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏ –ø—Ä–æ—Ñ–∏–ª—è.\n/// - Returns: true, –µ—Å–ª–∏ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –Ω–µ –ø—É—Å—Ç—ã–µ.\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}"
      ],
      [
        "/// –í–∞–ª–∏–¥–∏—Ä—É–µ—Ç –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ä–æ—Å—Å–∏–π—Å–∫–æ–º—É —Ñ–æ—Ä–º–∞—Ç—É.\n/// - Parameter phone: –°—Ç—Ä–æ–∫–∞ –Ω–æ–º–µ—Ä–∞.\n/// - Returns: true, –µ—Å–ª–∏ –Ω–æ–º–µ—Ä –≤–∞–ª–∏–¥–µ–Ω.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Ä–µ–π—Ç–∏–Ω–≥ (–æ—Ç 0 –¥–æ 5) –≤ —Å—Ç—Ä–æ–∫—É —Å —ç–º–æ–¥–∑–∏-–∑–≤–µ–∑–¥–∞–º–∏.\n/// - Parameter rating: –ó–Ω–∞—á–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ –∏–∑ –∑–≤—ë–∑–¥.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"‚òÖ\", count: filledStars) + String(repeating: \"‚òÜ\", count: emptyStars)\n}"
      ],
      [
        "/// –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –µ—Å—Ç—å –ª–∏ –∞–∫—Ç–∏–≤–Ω–∞—è –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–µ—Å—Å–∏—è.\n/// - Returns: true, –µ—Å–ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω.\nfunc isInternetAvailable() -> Bool {\n    // –£–ø—Ä–æ—â—ë–Ω–Ω–æ, –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞ ‚Äî —Ä–µ–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ–±—É–µ—Ç Reachability\n    return true\n}"
      ],
      [
        "/// –°—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç –¥–∞—Ç—É –¥–æ—Å—Ç–∞–≤–∫–∏ —Å —Ç–µ–∫—É—â–µ–π –¥–∞—Ç–æ–π –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å.\n/// - Parameter deliveryDate: –î–∞—Ç–∞ –¥–æ—Å—Ç–∞–≤–∫–∏.\n/// - Returns: –°—Ç–∞—Ç—É—Å —Å—Ç—Ä–æ–∫–∏: \"–°–µ–≥–æ–¥–Ω—è\", \"–ó–∞–≤—Ç—Ä–∞\", \"–ü–æ–∑–∂–µ\".\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"–°–µ–≥–æ–¥–Ω—è\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"–ó–∞–≤—Ç—Ä–∞\"\n    } else {\n        return \"–ü–æ–∑–∂–µ\"\n    }\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å–ø–∏—Å–æ–∫ —Ç–µ–≥–æ–≤ –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É —Å —Ö–µ—à—Ç–µ–≥–∞–º–∏.\n/// - Parameter tags: –°–ø–∏—Å–æ–∫ —Ç–µ–≥–æ–≤.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —Ö–µ—à—Ç–µ–≥–∞–º–∏.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}"
      ],
      [
        "/// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é —Å–∫—Ä–æ–ª–ª–∞ –≤ —Å–ø–∏—Å–∫–µ —Ç–æ–≤–∞—Ä–æ–≤.\n/// - Parameter offset: –ó–Ω–∞—á–µ–Ω–∏–µ —Å–º–µ—â–µ–Ω–∏—è.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –∑–æ–Ω–µ –¥–æ—Å—Ç–∞–≤–∫–∏ (–ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º).\n/// - Parameters:\n///   - lat: –®–∏—Ä–æ—Ç–∞.\n///   - lon: –î–æ–ª–≥–æ—Ç–∞.\n/// - Returns: true, –µ—Å–ª–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤—Ö–æ–¥—è—Ç –≤ —Ä–∞–¥–∏—É—Å.\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // –ú–æ—Å–∫–≤–∞\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}"
      ],
      [
        "/// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç URL –¥–ª—è deeplink —Å –∑–∞–¥–∞–Ω–Ω—ã–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º —Ç–æ–≤–∞—Ä–∞.\n/// - Parameter productId: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä.\n/// - Returns: URL –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–ª –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏.\n/// - Parameter lastViewedId: –ü–æ—Å–ª–µ–¥–Ω–∏–π –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω—ã–π ID.\n/// - Parameter newMessageId: ID –Ω–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è.\n/// - Returns: true, –µ—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.\nfunc hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}"
      ],
      [
        "/// –í—ã—á–∏—Å–ª—è–µ—Ç –ø—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ —Ü–µ–ª–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–π).\n/// - Parameters:\n///   - current: –¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.\n///   - target: –¶–µ–ª–µ–≤–∞—è —Å—É–º–º–∞.\n/// - Returns: –ü—Ä–æ—Ü–µ–Ω—Ç –æ—Ç 0 –¥–æ 100.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–æ–∫–µ–Ω–∞ –≤ UserDefaults.\n/// - Returns: true, –µ—Å–ª–∏ —Ç–æ–∫–µ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –Ω–µ –∏—Å—Ç—ë–∫.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞\n    return !token.isEmpty\n}"
      ],
      [
        "/// –§–æ—Ä–º–∏—Ä—É–µ—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ —Å—É—Ç–æ–∫.\n/// - Parameter name: –ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Returns: –ü–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ.\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ, \\(name)\"\n    case 12..<18: return \"–î–æ–±—Ä—ã–π –¥–µ–Ω—å, \\(name)\"\n    case 18..<23: return \"–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä, \\(name)\"\n    default: return \"–î–æ–±—Ä–æ–π –Ω–æ—á–∏, \\(name)\"\n    }\n}"
      ],
      [
        "/// –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å—É–º–º—É –≤ —Ä—É–±–ª—è—Ö –≤ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É —Å –≤–∞–ª—é—Ç–æ–π.\n/// - Parameter amount: –°—É–º–º–∞ –≤ —Ä—É–±–ª—è—Ö.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —Å–∏–º–≤–æ–ª–æ–º —Ä—É–±–ª—è.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"‚ÇΩ\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ‚ÇΩ\"\n}"
      ],
      [
        "/// –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å –∑–∞–¥–∞–Ω–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º.\n/// - Parameter message: –¢–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}"
      ],
      [
        "/// –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å onboarding –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–ª–∞–≥–∞ –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ.\n/// - Returns: true, –µ—Å–ª–∏ onboarding –µ—â—ë –Ω–µ –ø—Ä–æ–π–¥–µ–Ω.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}"
      ],
      [
        "/// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞.\n/// - Parameter productId: ID —Ç–æ–≤–∞—Ä–∞.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}"
      ],
      [
        "/// –û—Ü–µ–Ω–∏–≤–∞–µ—Ç, —Å–ª–µ–¥—É–µ—Ç –ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –≤—Å–ø–ª—ã–≤–∞—é—â–µ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.\n/// - Returns: true, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤–∏–¥–µ–ª –±–∞–Ω–Ω–µ—Ä –±–æ–ª–µ–µ —Å—É—Ç–æ–∫.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ —Å—Ç—Ä–æ–∫—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ UI.\n/// - Parameters:\n///   - lat: –®–∏—Ä–æ—Ç–∞.\n///   - lon: –î–æ–ª–≥–æ—Ç–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"üìç %.4f, %.4f\", lat, lon)\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∑–∞–ø–æ–ª–Ω–µ–Ω—ã –ª–∏ –≤—Å–µ –ø–æ–ª—è –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Parameter profile: –°–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏ –ø—Ä–æ—Ñ–∏–ª—è.\n/// - Returns: true, –µ—Å–ª–∏ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –Ω–µ –ø—É—Å—Ç—ã–µ.\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}"
      ],
      [
        "/// –í–∞–ª–∏–¥–∏—Ä—É–µ—Ç –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ä–æ—Å—Å–∏–π—Å–∫–æ–º—É —Ñ–æ—Ä–º–∞—Ç—É.\n/// - Parameter phone: –°—Ç—Ä–æ–∫–∞ –Ω–æ–º–µ—Ä–∞.\n/// - Returns: true, –µ—Å–ª–∏ –Ω–æ–º–µ—Ä –≤–∞–ª–∏–¥–µ–Ω.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Ä–µ–π—Ç–∏–Ω–≥ (–æ—Ç 0 –¥–æ 5) –≤ —Å—Ç—Ä–æ–∫—É —Å —ç–º–æ–¥–∑–∏-–∑–≤–µ–∑–¥–∞–º–∏.\n/// - Parameter rating: –ó–Ω–∞—á–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ –∏–∑ –∑–≤—ë–∑–¥.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"‚òÖ\", count: filledStars) + String(repeating: \"‚òÜ\", count: emptyStars)\n}"
      ],
      [
        "/// –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –µ—Å—Ç—å –ª–∏ –∞–∫—Ç–∏–≤–Ω–∞—è –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–µ—Å—Å–∏—è.\n/// - Returns: true, –µ—Å–ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω.\nfunc isInternetAvailable() -> Bool {\n    // –£–ø—Ä–æ—â—ë–Ω–Ω–æ, –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞ ‚Äî —Ä–µ–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ–±—É–µ—Ç Reachability\n    return true\n}"
      ],
      [
        "/// –°—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç –¥–∞—Ç—É –¥–æ—Å—Ç–∞–≤–∫–∏ —Å —Ç–µ–∫—É—â–µ–π –¥–∞—Ç–æ–π –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å.\n/// - Parameter deliveryDate: –î–∞—Ç–∞ –¥–æ—Å—Ç–∞–≤–∫–∏.\n/// - Returns: –°—Ç–∞—Ç—É—Å —Å—Ç—Ä–æ–∫–∏: \"–°–µ–≥–æ–¥–Ω—è\", \"–ó–∞–≤—Ç—Ä–∞\", \"–ü–æ–∑–∂–µ\".\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"–°–µ–≥–æ–¥–Ω—è\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"–ó–∞–≤—Ç—Ä–∞\"\n    } else {\n        return \"–ü–æ–∑–∂–µ\"\n    }\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å–ø–∏—Å–æ–∫ —Ç–µ–≥–æ–≤ –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É —Å —Ö–µ—à—Ç–µ–≥–∞–º–∏.\n/// - Parameter tags: –°–ø–∏—Å–æ–∫ —Ç–µ–≥–æ–≤.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —Ö–µ—à—Ç–µ–≥–∞–º–∏.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}"
      ],
      [
        "/// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é —Å–∫—Ä–æ–ª–ª–∞ –≤ —Å–ø–∏—Å–∫–µ —Ç–æ–≤–∞—Ä–æ–≤.\n/// - Parameter offset: –ó–Ω–∞—á–µ–Ω–∏–µ —Å–º–µ—â–µ–Ω–∏—è.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –∑–æ–Ω–µ –¥–æ—Å—Ç–∞–≤–∫–∏ (–ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º).\n/// - Parameters:\n///   - lat: –®–∏—Ä–æ—Ç–∞.\n///   - lon: –î–æ–ª–≥–æ—Ç–∞.\n/// - Returns: true, –µ—Å–ª–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤—Ö–æ–¥—è—Ç –≤ —Ä–∞–¥–∏—É—Å.\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // –ú–æ—Å–∫–≤–∞\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}"
      ],
      [
        "/// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç URL –¥–ª—è deeplink —Å –∑–∞–¥–∞–Ω–Ω—ã–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º —Ç–æ–≤–∞—Ä–∞.\n/// - Parameter productId: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä.\n/// - Returns: URL –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–ª –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏.\n/// - Parameter lastViewedId: –ü–æ—Å–ª–µ–¥–Ω–∏–π –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω—ã–π ID.\n/// - Parameter newMessageId: ID –Ω–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è.\n/// - Returns: true, –µ—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.\nfunc hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}"
      ],
      [
        "/// –í—ã—á–∏—Å–ª—è–µ—Ç –ø—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ —Ü–µ–ª–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–π).\n/// - Parameters:\n///   - current: –¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.\n///   - target: –¶–µ–ª–µ–≤–∞—è —Å—É–º–º–∞.\n/// - Returns: –ü—Ä–æ—Ü–µ–Ω—Ç –æ—Ç 0 –¥–æ 100.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ Terms & Conditions –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ª–æ–∫–∞–ª–∏.\n/// - Returns: URL —Å—Ç—Ä–∞–Ω–∏—Ü—ã —É—Å–ª–æ–≤–∏–π –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è.\nfunc termsAndConditionsURL() -> URL? {\n    let locale = Locale.current.languageCode ?? \"en\"\n    return URL(string: \"https://example.com/terms_\\(locale).html\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–∞—Å—Ç—É–ø–∏–ª–æ –ª–∏ –≤—Ä–µ–º—è –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Å–æ–±—ã—Ç–∏—è.\n/// - Parameter date: –î–∞—Ç–∞ —Å–æ–±—ã—Ç–∏—è.\n/// - Returns: true, –µ—Å–ª–∏ —Å–æ–±—ã—Ç–∏–µ —É–∂–µ –Ω–∞—á–∞–ª–æ—Å—å.\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}"
      ],
      [
        "/// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—É—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º —Ç–µ–º—É –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è.\n/// - Parameter theme: –ù–∞–∑–≤–∞–Ω–∏–µ —Ç–µ–º—ã.\nfunc saveUserTheme(_ theme: String) {\n    UserDefaults.standard.set(theme, forKey: \"appTheme\")\n}"
      ],
      [
        "/// –ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—É—â—É—é —Ç–µ–º—É –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è.\n/// - Returns: –ù–∞–∑–≤–∞–Ω–∏–µ —Ç–µ–º—ã –∏–ª–∏ nil.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}"
      ],
      [
        "/// –û—á–∏—â–∞–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞.\nfunc clearUserSession() {\n    let keys = [\"authToken\", \"userProfile\", \"lastViewedProduct\"]\n    keys.forEach { UserDefaults.standard.removeObject(forKey: $0) }\n}"
      ],
      [
        "/// –§–æ—Ä–º–∏—Ä—É–µ—Ç —Å—Ç—Ä–æ–∫—É –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.\n/// - Returns: –¢–µ–∫—Å—Ç –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏.\nfunc generateFeedbackTemplate() -> String {\n    let systemVersion = UIDevice.current.systemVersion\n    let model = UIDevice.current.model\n    return \"–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: \\(model)\\n–í–µ—Ä—Å–∏—è iOS: \\(systemVersion)\\n–í–∞—à –æ—Ç–∑—ã–≤: \"\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –¥–æ—Å—Ç–∏–≥ –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ª–∏–º–∏—Ç–∞ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π.\n/// - Parameter count: –¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ–π—Å—Ç–≤–∏–π.\n/// - Returns: true, –µ—Å–ª–∏ –ª–∏–º–∏—Ç –¥–æ—Å—Ç–∏–≥–Ω—É—Ç.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}"
      ],
      [
        "/// –§–æ—Ä–º–∏—Ä—É–µ—Ç —Å—Ç—Ä–æ–∫—É –¥–∞—Ç—ã –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏ –∑–∞–∫–∞–∑–æ–≤.\n/// - Parameter date: –î–∞—Ç–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ \"dd MMM yyyy\".\nfunc formatOrderDate(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd MMM yyyy\"\n    return formatter.string(from: date)\n}"
      ],
      [
        "/// –í—ã—á–∏—Å–ª—è–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –º–µ–∂–¥—É –¥–≤—É–º—è –¥–∞—Ç–∞–º–∏.\n/// - Parameters:\n///   - from: –ù–∞—á–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞.\n///   - to: –ö–æ–Ω–µ—á–Ω–∞—è –¥–∞—Ç–∞.\n/// - Returns: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π.\nfunc daysBetween(_ from: Date, _ to: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: from, to: to).day ?? 0\n}"
      ],
      [
        "/// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω–æ–≥–æ –±–∞–Ω–Ω–µ—Ä–∞.\n/// - Parameter id: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –±–∞–Ω–Ω–µ—Ä–∞.\nfunc saveLastSeenBannerId(_ id: String) {\n    UserDefaults.standard.set(id, forKey: \"lastSeenBannerId\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å–ª–µ–¥—É–µ—Ç –ª–∏ –æ–±–Ω–æ–≤–∏—Ç—å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.\n/// - Parameter lastUpdate: –î–∞—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.\n/// - Returns: true, –µ—Å–ª–∏ –ø—Ä–æ—à–ª–æ –±–æ–ª—å—à–µ 6 —á–∞—Å–æ–≤.\nfunc shouldRefreshCache(since lastUpdate: Date) -> Bool {\n    return Date().timeIntervalSince(lastUpdate) > 6 * 3600\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–æ–∫–µ–Ω–∞ –≤ UserDefaults.\n/// - Returns: true, –µ—Å–ª–∏ —Ç–æ–∫–µ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –Ω–µ –∏—Å—Ç—ë–∫.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // –ó–¥–µ—Å—å –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞\n    return !token.isEmpty\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–æ–≤—ã–º (–Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞—Ç—ã —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏).\n/// - Parameter registrationDate: –î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Returns: true, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –º–µ–Ω–µ–µ 7 –¥–Ω–µ–π –Ω–∞–∑–∞–¥.\nfunc isNewUser(registrationDate: Date) -> Bool {\n    return Date().timeIntervalSince(registrationDate) < 7 * 86400\n}"
      ],
      [
        "/// –ü–æ–ª—É—á–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—É—Å–∫–æ–≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.\n/// - Returns: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—É—Å–∫–æ–≤.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}"
      ],
      [
        "/// –£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Å—á—ë—Ç—á–∏–∫ –∑–∞–ø—É—Å–∫–æ–≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.\nfunc incrementAppLaunchCount() {\n    let count = getAppLaunchCount() + 1\n    UserDefaults.standard.set(count, forKey: \"launchCount\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –¥–æ—Å—Ç—É–ø–µ–Ω –ª–∏ Face ID –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.\n/// - Returns: true, –µ—Å–ª–∏ Face ID –¥–æ—Å—Ç—É–ø–µ–Ω.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}"
      ],
      [
        "/// –ü–æ–ª—É—á–∞–µ—Ç –∏–º—è –º–µ—Å—è—Ü–∞ –Ω–∞ —Ä—É—Å—Å–∫–æ–º –ø–æ –Ω–æ–º–µ—Ä—É.\n/// - Parameter month: –ù–æ–º–µ—Ä –º–µ—Å—è—Ü–∞ –æ—Ç 1 –¥–æ 12.\n/// - Returns: –ù–∞–∑–≤–∞–Ω–∏–µ –º–µ—Å—è—Ü–∞.\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.monthSymbols[safe: month - 1] ?? \"\"\n}"
      ],
      [
        "/// –§–æ—Ä–º–∏—Ä—É–µ—Ç URL –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ –∏—Å—Ç–æ—Ä–∏–∏ –∑–∞–∫–∞–∑–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Parameter userId: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Returns: URL —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º userId.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}"
      ],
      [
        "/// –ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ \"darkMode\".\n/// - Returns: true, –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–∞ —Ç—ë–º–Ω–∞—è —Ç–µ–º–∞.\nfunc isDarkModeEnabled() -> Bool {\n    return UserDefaults.standard.bool(forKey: \"darkMode\")\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –µ—Å—Ç—å –ª–∏ –¥–æ—Å—Ç—É–ø –∫ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏.\n/// - Returns: true, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø —Ä–∞–∑—Ä–µ—à—ë–Ω.\nfunc isLocationAccessGranted() -> Bool {\n    return CLLocationManager.authorizationStatus() == .authorizedWhenInUse || CLLocationManager.authorizationStatus() == .authorizedAlways\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å–µ–∫—É–Ω–¥—ã –≤ —Å—Ç—Ä–æ–∫—É —Ñ–æ—Ä–º–∞—Ç–∞ \"–º–º:—Å—Å\".\n/// - Parameter seconds: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–∫—É–Ω–¥.\n/// - Returns: –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–æ –ª–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –≤–≤–æ–¥–∞ PIN-–∫–æ–¥–∞.\n/// - Parameter attempts: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫.\n/// - Returns: true, –µ—Å–ª–∏ –ª–∏–º–∏—Ç –ø—Ä–µ–≤—ã—à–µ–Ω.\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}"
      ],
      [
        "/// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å—Ç—Ä–æ–∫—É —Å—Ç–∞—Ç—É—Å–∞ –¥–æ—Å—Ç–∞–≤–∫–∏ –ø–æ —Ç–µ–∫—É—â–µ–º—É —ç—Ç–∞–ø—É.\n/// - Parameter status: –¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å.\n/// - Returns: –°—Ç—Ä–æ–∫–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ.\nfunc deliveryStatusText(for status: String) -> String {\n    switch status {\n    case \"pending\": return \"–û–∂–∏–¥–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏\"\n    case \"shipped\": return \"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ\"\n    case \"delivered\": return \"–î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ\"\n    default: return \"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ\"\n    }\n}"
      ],
      [
        "/// –£–¥–∞–ª—è–µ—Ç –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã UserDefaults –¥–ª—è —Å–±—Ä–æ—Å–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.\nfunc resetAppData() {\n    if let appDomain = Bundle.main.bundleIdentifier {\n        UserDefaults.standard.removePersistentDomain(forName: appDomain)\n    }\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Ä–∞–±–æ—Ç–∞–µ—Ç –ª–∏ —Å–µ—Ä–≤–µ—Ä API.\n/// - Parameter completion: –ó–∞–º—ã–∫–∞–Ω–∏–µ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏.\nfunc pingServer(completion: @escaping (Bool) -> Void) {\n    let url = URL(string: \"https://api.example.com/ping\")!\n    URLSession.shared.dataTask(with: url) { _, response, error in\n        let httpResponse = response as? HTTPURLResponse\n        completion(httpResponse?.statusCode == 200 && error == nil)\n    }.resume()\n}"
      ],
      [
        "/// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º—ã–π —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Parameter languageCode: –ö–æ–¥ —è–∑—ã–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, \"ru\", \"en\").\nfunc savePreferredLanguage(_ languageCode: String) {\n    UserDefaults.standard.set(languageCode, forKey: \"preferredLanguage\")\n}"
      ],
      [
        "/// –ü–æ–ª—É—á–∞–µ—Ç –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º—ã–π —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n/// - Returns: –ö–æ–¥ —è–∑—ã–∫–∞ –∏–ª–∏ \"ru\" –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"ru\"\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ —á–∏—Å–ª–æ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º, –∫–æ—Ç–æ—Ä–æ–µ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Ü–µ–ª—ã–º —á–∏—Å–ª–æ–º.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —á–∏—Å–ª–æ —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π, false ‚Äî —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –∏–ª–∏ –Ω–µ —á–∏—Å–ª–æ.\nfunc isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor(number) != number\n    }\n    return false\n}"
      ],
      [
        "/// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å—Ç—Ä–æ–∫—É, —Å–æ–¥–µ—Ä–∂–∞—â—É—é –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–π—Å—è —Å–∏–º–≤–æ–ª –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞–∑.\n/// - Parameters:\n///   - character: –°–∏–º–≤–æ–ª –¥–ª—è –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è.\n///   - count: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–º–∏—Å—è —Å–∏–º–≤–æ–ª–∞–º–∏.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ–π –≤ –º–∞—Å—Å–∏–≤–µ —Å—Ç—Ä–æ–∫.\n/// - Parameters:\n///   - text: –°—Ç—Ä–æ–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏.\n///   - array: –ú–∞—Å—Å–∏–≤ —Å—Ç—Ä–æ–∫.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è –≤ –º–∞—Å—Å–∏–≤–µ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑.\nfunc isUniqueString(_ text: String, in array: [String]) -> Bool {\n    return array.filter { $0 == text }.count == 1\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ —á–∏—Å–ª–æ —Å –∑–∞–¥–∞–Ω–Ω—ã–º –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ–º –¥–æ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ —á–∏—Å–ª–∞ –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π.\n/// - Parameters:\n///   - text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n///   - decimals: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π.\n/// - Returns: –û–∫—Ä—É–≥–ª—ë–Ω–Ω–æ–µ —á–∏—Å–ª–æ.\nfunc roundedNumber(from text: String, decimals: Int) -> Double? {\n    guard let number = Double(text) else { return nil }\n    return round(number * pow(10, Double(decimals))) / pow(10, Double(decimals))\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, —Å–æ–¥–µ—Ä–∂–∞—â—É—é –≤—Å–µ —Ü–∏—Ñ—Ä—ã –∏–∑ —Å—Ç—Ä–æ–∫–∏ –≤ –ø–æ—Ä—è–¥–∫–µ –∏—Ö –ø–æ—è–≤–ª–µ–Ω–∏—è.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞, —Å–æ–¥–µ—Ä–∂–∞—â–∞—è —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã.\nfunc extractDigitsInOrder(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}"
      ],
      [
        "/// –ü–µ—Ä–µ–≤–æ–¥–∏—Ç —Å—Ç—Ä–æ–∫—É –≤ \"–∫–æ–±–æ–ª—å–¥—Å–∫–∏–π\" —Ä–µ–≥–∏—Å—Ç—Ä (–∫–∞–∂–¥–æ–µ —Å–ª–æ–≤–æ —Å –º–∞–ª–µ–Ω—å–∫–æ–π –±—É–∫–≤—ã, –∫—Ä–æ–º–µ –ø–µ—Ä–≤–æ–≥–æ).\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ –≤ \"–∫–æ–±–æ–ª—å–¥—Å–∫–æ–º\" —Ä–µ–≥–∏—Å—Ç—Ä–µ.\nfunc toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É —Å —É–¥–∞–ª–µ–Ω–∏–µ–º –≤—Å–µ—Ö —Å–∏–º–≤–æ–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è –≤ –¥—Ä—É–≥–æ–π —Å—Ç—Ä–æ–∫–µ.\n/// - Parameters:\n///   - text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n///   - charactersToRemove: –°—Ç—Ä–æ–∫–∞ —Å —Å–∏–º–≤–æ–ª–∞–º–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ –±–µ–∑ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤.\nfunc removeCharactersFromString(_ text: String, charactersToRemove: String) -> String {\n    return text.filter { !charactersToRemove.contains($0) }\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø–æ–ª–Ω—ã–º —á–∏—Å–ª–æ–º –±–µ–∑ –¥–µ—Å—è—Ç–∏—á–Ω–æ–π —Ç–æ—á–∫–∏.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø–æ–¥—Å—Ç—Ä–æ–∫–æ–π –¥—Ä—É–≥–æ–π —Å—Ç—Ä–æ–∫–∏.\n/// - Parameters:\n///   - substring: –ü–æ–¥—Å—Ç—Ä–æ–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏.\n///   - text: –ò—Å—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ –ø–æ–¥—Å—Ç—Ä–æ–∫–∞ –Ω–∞–π–¥–µ–Ω–∞ –≤ —Å—Ç—Ä–æ–∫–µ.\nfunc containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤ —Å —É—á—ë—Ç–æ–º –∑–∞–≥–ª–∞–≤–Ω—ã—Ö –±—É–∫–≤ (–∫–∞–∂–¥–æ–µ –Ω–æ–≤–æ–µ —Å–ª–æ–≤–æ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –∑–∞–≥–ª–∞–≤–Ω–æ–π –±—É–∫–≤—ã).\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –ú–∞—Å—Å–∏–≤ —Å–ª–æ–≤ —Å —É—á—ë—Ç–æ–º –∑–∞–≥–ª–∞–≤–Ω—ã—Ö –±—É–∫–≤.\nfunc stringToCapitalizedWords(_ text: String) -> [String] {\n    return text.split(separator: \" \").map { $0.capitalized }\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ —Å—Ç—Ä–æ–∫—É —Å —á–µ—Ä–µ–¥—É—é—â–∏–º–∏—Å—è –±—É–∫–≤–∞–º–∏ –≤ –≤–µ—Ä—Ö–Ω–µ–º –∏ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ö.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —á–µ—Ä–µ–¥—É—é—â–∏–º–∏—Å—è –∑–∞–≥–ª–∞–≤–Ω—ã–º–∏ –∏ —Å—Ç—Ä–æ—á–Ω—ã–º–∏ –±—É–∫–≤–∞–º–∏.\nfunc alternatingCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, character) in\n        index % 2 == 0 ? character.lowercased() : character.uppercased()\n    })\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–Ω–¥–µ–∫—Å –ø–µ—Ä–≤–æ–≥–æ –≤—Ö–æ–∂–¥–µ–Ω–∏—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ –≤ —Å—Ç—Ä–æ–∫—É.\n/// - Parameters:\n///   - substring: –ü–æ–¥—Å—Ç—Ä–æ–∫–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞.\n///   - text: –ò—Å—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –ò–Ω–¥–µ–∫—Å –ø–µ—Ä–≤–æ–≥–æ –≤—Ö–æ–∂–¥–µ–Ω–∏—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ –∏–ª–∏ nil, –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.\nfunc indexOfSubstring(_ substring: String, in text: String) -> Int? {\n    return text.range(of: substring)?.lowerBound.utf16Offset(in: text)\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–æ–º, —É—á–∏—Ç—ã–≤–∞—è —Ç–æ–ª—å–∫–æ –∞–ª—Ñ–∞–≤–∏—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –∏ –∏–≥–Ω–æ—Ä–∏—Ä—É—è —Ä–µ–≥–∏—Å—Ç—Ä.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —è–≤–ª—è–µ—Ç—Å—è –ø–∞–ª–∏–Ω–¥—Ä–æ–º–æ–º.\nfunc isAlphaOnlyPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, —Å–æ–¥–µ—Ä–∂–∞—â—É—é —Ç–æ–ª—å–∫–æ –∑–∞–≥–ª–∞–≤–Ω—ã–µ –±—É–∫–≤—ã –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞, —Å–æ–¥–µ—Ä–∂–∞—â–∞—è —Ç–æ–ª—å–∫–æ –∑–∞–≥–ª–∞–≤–Ω—ã–µ –±—É–∫–≤—ã.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —è–≤–ª—è–µ—Ç—Å—è —á–∏—Å–ª–æ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º –≤ –¥–≤–æ–∏—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —è–≤–ª—è–µ—Ç—Å—è –¥–≤–æ–∏—á–Ω—ã–º —á–∏—Å–ª–æ–º.\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É —Å –ø–µ—Ä–≤—ã–º —Å–∏–º–≤–æ–ª–æ–º, –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–Ω—ã–º –≤ –∑–∞–≥–ª–∞–≤–Ω—É—é –±—É–∫–≤—É.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å –ø–µ—Ä–≤—ã–º —Å–∏–º–≤–æ–ª–æ–º –≤ –≤–µ—Ä—Ö–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ –º–∞—Å—Å–∏–≤, —Ä–∞–∑–±–∏–≤–∞—è –ø–æ –∫–∞–∂–¥–æ–º—É —Å–∏–º–≤–æ–ª—É.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –ú–∞—Å—Å–∏–≤ —Å–∏–º–≤–æ–ª–æ–≤.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, –∫–æ—Ç–æ—Ä–∞—è —è–≤–ª—è–µ—Ç—Å—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è —Å—Ç—Ä–æ–∫–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑.\n/// - Parameters:\n///   - text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n///   - count: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π.\n/// - Returns: –ü–æ–≤—Ç–æ—Ä—ë–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\nfunc repeatString(_ text: String, count: Int) -> String {\n    return String(repeating: text, count: count)\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ–º –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ \"HH:mm\".\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —è–≤–ª—è–µ—Ç—Å—è –≤—Ä–µ–º–µ–Ω–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç–µ \"HH:mm\".\nfunc isValidTime(_ text: String) -> Bool {\n    let pattern = \"^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$\"\n    return matchesRegex(text, pattern: pattern)\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, —Å–æ—Å—Ç–æ—è—â—É—é —Ç–æ–ª—å–∫–æ –∏–∑ —Ü–∏—Ñ—Ä –∏ —Å–∏–º–≤–æ–ª–æ–≤ —Ç–∏—Ä–µ, –µ—Å–ª–∏ –æ–Ω–∏ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç –≤ —Å—Ç—Ä–æ–∫–µ.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —Ü–∏—Ñ—Ä–∞–º–∏ –∏ —Ç–∏—Ä–µ.\nfunc extractDigitsAndDashes(from text: String) -> String {\n    return text.filter { $0.isNumber || $0 == \"-\" }\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ —Å–∏–º–≤–æ–ª—ã —Å—Ç—Ä–æ–∫–∏ –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ, –∫—Ä–æ–º–µ —á–∏—Å–µ–ª.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å –±—É–∫–≤–∞–º–∏ –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ.\nfunc lowercaseLettersWithoutNumbers(from text: String) -> String {\n    return text.filter { $0.isLetter }.lowercased()\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –≤—Å–µ –ª–∏ —Å—Ç—Ä–æ–∫–∏ –≤ –º–∞—Å—Å–∏–≤–µ –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—É—é –¥–ª–∏–Ω—É.\n/// - Parameter array: –ú–∞—Å—Å–∏–≤ —Å—Ç—Ä–æ–∫.\n/// - Returns: true, –µ—Å–ª–∏ –≤—Å–µ —Å—Ç—Ä–æ–∫–∏ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π –¥–ª–∏–Ω—ã.\nfunc allStringsHaveEqualLength(_ array: [String]) -> Bool {\n    guard let firstLength = array.first?.count else { return true }\n    return array.allSatisfy { $0.count == firstLength }\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–æ–∫, —Ä–∞–∑–¥–µ–ª—ë–Ω–Ω—ã—Ö –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–º —Å–∏–º–≤–æ–ª–æ–º.\n/// - Parameters:\n///   - text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n///   - separator: –°–∏–º–≤–æ–ª –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è.\n/// - Returns: –ú–∞—Å—Å–∏–≤ —Å—Ç—Ä–æ–∫.\nfunc splitStringByCharacter(_ text: String, separator: Character) -> [String] {\n    return text.split(separator: separator).map { String($0) }\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ —á–∏—Å–ª–æ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º –≤ —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —è–≤–ª—è–µ—Ç—Å—è —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–º —á–∏—Å–ª–æ–º.\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ –¥–∞—Ç—É —Å —É—á—ë—Ç–æ–º –≤—Ä–µ–º–µ–Ω–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ \"yyyy-MM-dd HH:mm:ss\".\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –î–∞—Ç–∞, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç—É.\nfunc stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    return formatter.date(from: text)\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ —Å—Ç—Ä–æ–∫—É —Å —É–¥–∞–ª—ë–Ω–Ω—ã–º–∏ –ø—Ä–æ–±–µ–ª–∞–º–∏, –∑–Ω–∞–∫–∞–º–∏ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è –∏ —Å–∏–º–≤–æ–ª–∞–º–∏ –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ –±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤ –∏ –∑–Ω–∞–∫–æ–≤ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è.\nfunc cleanString(_ text: String) -> String {\n    let charactersToRemove = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)\n    return text.filter { !charactersToRemove.contains($0.unicodeScalars.first!) }\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ —á–∏—Å–ª–æ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∑–∞–¥–∞–Ω–Ω–æ–π –±–∞–∑—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, 2 –¥–ª—è –¥–≤–æ–∏—á–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã).\n/// - Parameters:\n///   - text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n///   - base: –ë–∞–∑–∞ —á–∏—Å–ª–∞.\n/// - Returns: –ß–∏—Å–ª–æ –≤ –∑–∞–¥–∞–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ —Å—á–∏—Å–ª–µ–Ω–∏—è.\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ –º–∞—Å—Å–∏–≤ —Å–∏–º–≤–æ–ª–æ–≤ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤.\nfunc countUniqueCharacters(in text: String) -> Int {\n    return Set(text).count\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, —Å–æ—Å—Ç–æ—è—â—É—é –∏–∑ —Å–∏–º–≤–æ–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è –≤ —Å—Ç—Ä–æ–∫–µ –Ω–µ –±–æ–ª–µ–µ –æ–¥–Ω–æ–≥–æ —Ä–∞–∑–∞.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ —Å–∏–º–≤–æ–ª–∞–º–∏.\nfunc uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text.reduce(into: [:]) { counts, char in counts[char, default: 0] += 1 }\n    return String(text.filter { characterCount[$0] == 1 })\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ —Å—Ç—Ä–æ–∫–æ–π, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–µ–π –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π email-–∞–¥—Ä–µ—Å.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ ‚Äî –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π email.\nfunc isValidEmail(_ text: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"\n    return matchesRegex(text, pattern: emailRegex)\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, –∫–æ—Ç–æ—Ä–∞—è —è–≤–ª—è–µ—Ç—Å—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º —Å–∫–ª–µ–∏–≤–∞–Ω–∏—è –≤—Å–µ—Ö —á–∏—Å–µ–ª –∏–∑ —Å—Ç—Ä–æ–∫–∏.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞, —Å–æ–¥–µ—Ä–∂–∞—â–∞—è —Ç–æ–ª—å–∫–æ —á–∏—Å–ª–∞ –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É —Å —á–∏—Å–ª–æ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º –≤ –ø—Ä–æ—Ü–µ–Ω—Ç—ã.\n/// - Parameters:\n///   - text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n///   - precision: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å –ø—Ä–æ—Ü–µ–Ω—Ç–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º.\nfunc stringToPercentage(_ text: String, precision: Int) -> String? {\n    guard let number = Double(text) else { return nil }\n    let percentage = number * 100\n    return String(format: \"%.\\(precision)f%%\", percentage)\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, –≥–¥–µ —Å–∏–º–≤–æ–ª—ã —á–µ—Ä–µ–¥—É—é—Ç—Å—è –º–µ–∂–¥—É –≤–µ—Ä—Ö–Ω–∏–º –∏ –Ω–∏–∂–Ω–∏–º —Ä–µ–≥–∏—Å—Ç—Ä–æ–º.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—Ç—Ä–æ–∫–∞ —Å —á–µ—Ä–µ–¥—É—é—â–∏–º–∏—Å—è –±—É–∫–≤–∞–º–∏.\nfunc alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ —á–∏—Å–ª–æ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º, –≤–∫–ª—é—á–∞—è –¥–µ—Å—è—Ç–∏—á–Ω—É—é —Ç–æ—á–∫—É.\n/// - Parameter text: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: true, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —è–≤–ª—è–µ—Ç—Å—è —á–∏—Å–ª–æ–º.\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–ª–µ–º–µ–Ω—Ç—ã –º–∞—Å—Å–∏–≤–∞ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ.\n/// - Parameter array: –ú–∞—Å—Å–∏–≤.\n/// - Returns: –ú–∞—Å—Å–∏–≤ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ.\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}"
      ],
      [
        "/// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ —Å–ª–æ–≤–∞—Ä—è –ø–æ –µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è–º.\n/// - Parameter dictionary: –°–ª–æ–≤–∞—Ä—å.\n/// - Returns: –°–ª—É—á–∞–π–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç —Å–ª–æ–≤–∞—Ä—è.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}"
      ],
      [
        "/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–ª—é—á–∏ –∏–∑ —Å–ª–æ–≤–∞—Ä—è, –∫–æ—Ç–æ—Ä—ã–µ —Å–≤—è–∑–∞–Ω—ã —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏.\n/// - Parameter dictionary: –°–ª–æ–≤–∞—Ä—å.\n/// - Returns: –ö–ª—é—á–∏ —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏.\nfunc keysWithMinValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable, Value: Comparable {\n    guard let minValue = dictionary.values.min() else { return [] }\n    return dictionary.filter { $0.value == minValue }.map { $0.key }\n}"
      ],
      [
        "/// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–µ—Ä–µ–¥–∞–Ω–Ω–∞—è –¥–∞—Ç–∞ –≤ –±—É–¥—É—â–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ç–µ–∫—É—â–µ–π.\n/// - Parameter date: –î–∞—Ç–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏.\n/// - Returns: `true`, –µ—Å–ª–∏ –¥–∞—Ç–∞ –≤ –±—É–¥—É—â–µ–º.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ –º–∞—Å—Å–∏–≤ —Å–∏–º–≤–æ–ª–æ–≤, —Ñ–∏–ª—å—Ç—Ä—É—è —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã.\n/// - Parameter str: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –ú–∞—Å—Å–∏–≤ —Å–∏–º–≤–æ–ª–æ–≤, —Å–æ–¥–µ—Ä–∂–∞—â–∏—Ö —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã.\nfunc stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}"
      ],
      [
        "/// –ù–∞—Ö–æ–¥–∏—Ç —Ä–∞–∑–Ω–∏—Ü—É –º–µ–∂–¥—É –¥–≤—É–º—è –¥–∞—Ç–∞–º–∏ –≤ –¥–Ω—è—Ö.\n/// - Parameters:\n///   - startDate: –ù–∞—á–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞.\n///   - endDate: –ö–æ–Ω–µ—á–Ω–∞—è –¥–∞—Ç–∞.\n/// - Returns: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –º–µ–∂–¥—É –¥–∞—Ç–∞–º–∏.\nfunc daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}"
      ],
      [
        "/// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ –º–∞—Å—Å–∏–≤ —á–∏—Å–µ–ª, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö –ø—Ä–æ–±–µ–ª–∞–º–∏, –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—É–º–º—É.\n/// - Parameter str: –í—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞.\n/// - Returns: –°—É–º–º–∞ —á–∏—Å–µ–ª –≤ —Å—Ç—Ä–æ–∫–µ.\nfunc sumOfNumbersInString(_ str: String) -> Int {\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.reduce(0, +)\n}"
      ]
    ]
  }
}